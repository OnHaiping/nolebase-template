---
tags: 
comment: true
---
## 引言与例题分析

在时序逻辑电路中，应当都具备有下面三个方程：

$$
输出方程：O = f_{1}(I,S)
$$
$$
激励方程：E = f_{2}(I,S)
$$
$$
状态方程：S^{n+1} = f_{3}(E,S^{n})
$$
从大的角度来说，时序逻辑电路分成：**同步**时序逻辑电路和**异步**时序逻辑电路

同步，意味着多个触发器的 $CP$ 都是由一个 $CP$ 总线控制的。

异步，相对比较复杂，除了考虑状态变换之外还需要考虑 $CP$ 脉冲的位置。

![|550](imgs/Pasted%20image%2020250913153413.png)

下面来分析一个时序逻辑电路：

![|600](imgs/Pasted%20image%2020250913154120.png)

上图中列出来的方程就是全部的方程。

下面根据方程，画出真值表：

![|275](imgs/Pasted%20image%2020250913154216.png)

而**状态表**或者是**状态图**也都是根据真值表得到的：

![|550](imgs/Pasted%20image%2020250913154743.png)

状态表要注意的是，里面的内容代表的是下一时刻的状态，下划线是对应的输出是什么。

换句话说，就是现在的状态由输入和前一时刻的状态决定。现在状态的输出同理。

**状态图**：

![|375](imgs/Pasted%20image%2020250913155721.png)

对于状态图，无论是对照真值表还是状态表，都是可以得到的。

> [!note]
> 圆圈内代表的是状态。箭头则是代表从当前的状态变化到下一个状态，在变化的过程中，斜线上面的代表的是**输入**，而斜线下面的代表的是**输出**。

**时序图**：

![|450](imgs/Pasted%20image%2020250913161540.png)

> [!important]
> 这里需要注意的是， $Z$ 也就是输出与前一时刻没有关系，也与 $CP$ 脉冲没有关系
> 
> 原因在于这里的输出是将输入与两个输出**与**到一起的，并不属于时序的范围内。

## 时序逻辑电路的分析

### 同步时序逻辑电路的分析

#### 一般步骤与例题

时序电路的分析是从图得到其功能如何。

> [!note]
> 一般步骤：
> 
> 1. 列方程组（3 个）
> 
> 2. 列状态表（功能表），画状态图
> 
> 3. 功能的说明（该电路的逻辑功能）

下面以一个例子来分析：

![|525](imgs/Pasted%20image%2020250913163405.png)

首先是将每一步的方程都写出来，包括每一个层级的输出。

写出方程之后，根据方程表达式画出真值表。

再根据真值表，将状态表画出：

![|525](imgs/Pasted%20image%2020250913162840.png)

最后根据状态表将状态图画出来。

> [!note]
> 对于一个**状态**来讲，有几个输入无所谓，但只能有**两个输出**

![|525](imgs/Pasted%20image%2020250913165432.png)

如果需要的话，还可以画一下**时序图**：

对于任意的输入 $A$ ：

根据状态表、状态图可以得到时序图：

![|525](imgs/Pasted%20image%2020250913165729.png)

最后，就是说明这个实现的功能是什么

只要讲得通，找到它的规律就可以。可以通过观察**状态图**：

当输入为 $0$ 的时候，维持状态不变。

当输出为 $1$ 的时候，由本位状态加一得到下一状态。并且以 4 为循环

**再来一个例子**：

![|550](imgs/Pasted%20image%2020250914151737.png)

思路是一样的，依然是先写出特征方程。

然后根据特征方程将真值表画出来。

再根据真值表将状态表画出来。

> [!note]
> 由于这个输出与状态转换（不严谨，理解意思即可）没有关系，所以在画状态表的时候，习惯上将输出 $Z$ 单独一列

最后是将状态图画出来。

![|525](imgs/Pasted%20image%2020250914152633.png)

在画状态图的时候，依然是因为输出只与连个触发器的状态有关，与转换没有直接关联。

所以可以直接在每个状态下面写上输出是什么。

最后如果有需要可以再写出时序图。

> [!note]
> 最后说明它的功能：受 $A$ 控制的**可加可减**电路。

#### 用触发器实现计数器

> [!important]
> *状态转换真值表*对于**同步**的电路分析来说比较好，如果是异步的，不是很合适

用一个例题来说明：

首先在思路上，是与之前的几乎一样。

![|550](imgs/Pasted%20image%2020250914153824.png)

先将方程写出来，包括输入和输出方程。

然后是写出真值表。（注意，这里**没有输入**，完全是由 $CP$ **脉冲控制** ）

就可以发现，它是从 $000$ 依次进一的。而到了 $100$ ，则又回到了 $000$ 。可以得到这是一个五进制计数器（**注意，不一定是依次进一的，只要是五个一循环就叫做五进制计数器**）。

而对于剩下的三个状态，因为输入的时候是有可能处于剩下的三个状态中，如果这三个状态可以恢复到**五进制**的循环当中，那么就称之为**无挂起**，反之，如果有某个状态的下一个状态还是它自己，那么就导致了**挂起**状态。

上面这个就叫做**无挂起同步五进制计数器**

下面再用一个例题来说明更简单的计算方法。

当然首先要做的还是写出输入方程等**特征方程**。

![|575](imgs/Pasted%20image%2020250914162432.png)

在写出特征方程之后，就要进行分析。

而在这里，就不再用之前的那种分析方法了，而是用：**状态转换真值表**

这个表的关键在于其中包括前一时刻的输入，直接按照 BCD 码的形式写下来即可。

然后是每个触发器的输入，分别是 $J_{1}K_{1}$ ， $J_{2}K_{2}$ 、 $J_{3}K_{3}$

最后面是要计算得到的 $Q_{1}^{n+1}$ 、 $Q_{2}^{n+1}$ 、 $Q_{3}^{n+1}$ 

其中的 $J_{1}K_{1}$ ， $J_{2}K_{2}$ 、 $J_{3}K_{3}$ 利用已经写出来的方程直接计算得到。

> [!note]
> 注意，在这里默认 $Q_{3}$ 为**最高位**

而接下来的分析，则是直接画出**状态转换图**：

![|550](imgs/Pasted%20image%2020250914163255.png)

进而得到功能

如果再加一个输出，也是没问题的：

![|600](imgs/Pasted%20image%2020250914163513.png)

> [!note]
> 当出现**挂起**状态的时候。
> 
> 解决方法有两个，一个是**置初始值**。
> 
> 另外一个则是使用**修正电路**（后面会讲的）

### 异步时序逻辑电路的分析

> [!note]
> 步时序逻辑电路的分析一般来说不能使用同步中使用的**状态转换真值表**。
> 
> 但是也不是绝对的，我们需要考虑是否有反馈，一般来说，如果没有反馈，那么是可以逐步分析触发器。
> 
> 当异步的部分，没有反馈线到前面的部分，那么可以将前面那部分当作同步的来分析，最后再来分析异步的部分。

依然是用例子来说明：

![|500](imgs/Pasted%20image%2020250914165214.png)

在这个电路中，前面两个触发器就组成了一个同步电路，最后面的哪个触发器才会结合成异步。而这个异步的并没有反馈给前面的触发器，这样就可以分两部分来分析。

> [!note]
> 个人感觉不如使用脉冲线的方法来分析来的直观，这样直接分析比较容易出错。

对于 $Q_{2}$ 来说，要注意的是：由于它被 $Q_{1}$ 控制 $CP$ 端。且是**下降沿**触发。所以只有在 $Q_{1}$ 在从 $1$ 跳变到 $0$ 的时候才会发生触发。

下面画状态图：

![|575](imgs/Pasted%20image%2020250914171228.png)

注意，在分析完循环的状态之后，还需要分析以下没有出现的状态的情况，会不会回到循环里面。

综上所述，可以得到上面这个是一个**无挂起异步六进制计数器**

再来一个例子说明：

![|550](imgs/Pasted%20image%2020250914181521.png)

这里的关键点在于 $Q_{1}$ 是受到 $Q_{0}$ 的下降沿控制的。也就是当 $Q_{0}$ 从 $1$ 变成 $0$ 的时候，就会触发变化。

下面画出状态图：

![|550](imgs/Pasted%20image%2020250914182739.png)

##  同步时序逻辑电路的设计

理论上说，只要是能描述出来的问题都可以用时序逻辑电路来实现。

### 一般步骤

一般步骤：

1. 根据一般问题描述，得到原始的状态图（状态表）**重中之重**
2. 状态化简（等效的，合二为一）
3. 状态分配
4. 选触发器（ $D$ 、 $JK$ ）
5. 确定激励方程组和输出方程组 （求解 $J_{1}$ 、 $k_{1}$ 等）
6. 画图以及确定能否自启动（如果挂起如何修复）

### 序列检测器

序列检测器要实现的是对于输入进来的一组序列，当出现要检测到的 $1001$ （任意的），当满足此序列，就输出为 $1$ ，否则输出为 $0$ 。当然，有可能会出现下面图中的：出现**重叠**的情况，这种需要额外确定，**是否可以重叠**。

![|525](imgs/Pasted%20image%2020250915153231.png)

下面用一个例子来说明：

设计一个检测 $1001$ 序列**可重迭**的电路：

对于这种**序列检测电路**，针对一开始的**初始状态**，一般设置为**要检测序列的第一位元素的相反状态**。

![|500](imgs/Pasted%20image%2020250915153914.png)

注意，对于每一个现有状态来说，存在两种情况，一种是输入为 $0$ ，一种是输入为 $1$ 。这意味着对于每个状态都只有**两条输出**：

![|550](imgs/Pasted%20image%2020250915154506.png)

![|550](imgs/Pasted%20image%2020250915155359.png)

状态图和状态表如上所示。

> [!note]
> **这里之所以是四个状态，原因在于它要检测的有四位，也就是至少要有四个状态**。
> 
> 而对于每一个现在的状态，对于不同的输出要做出不同的反应。、
> 
> 一般来说，当在现在的状态下面，如果输入了一个对检测序列有用的，那么就需要转向下一个状态。
> 
> 反过来，如果输入了一个打破检测序列的，那么就需要考虑到多层输入。
> 
> 比如说，在这里要检测 $1001$ ，如果输出一个 $11111101001$ ，那么对于 $1$ 这个状态来说，下一个输入如果还是 $1$ ，那么就需要在自身这个状态这里循环，如果来的是 $0$ ，就需要跳到下一个状态。
> 
> 如果现在的状态是 $0$ ，那么对于再输入为 $0$ 的，它满足跳转到下一个序列。而对于再输入一个 $1$ 的。就需要回到 $B$ 了。避免出现 $0111$ 这类的情况。

> [!important]
> 这里存在的问题是，对于 $C$ 这个状态，当输入为 $0$ 的时候，为什么要跳转到 $D$ 。
> 
> 原因在于当输入为 $01001$ 的时候，如果是遇到输入为 $0$ 反馈给本身，那么对于另外一种情况：输入为 $1$ 来说，就无法判断输出为 $1$ 还是输出为 $0$ ，因为当序列的第一个为 $0$ ，第二个为 $1$ 的时候，对于输入 $1$ 来说应该是输出为 $0$ ，但是如果已经输入了 $0100$ ，最后一个输入为 $1$ 的时候，这时候的输出应该为 $1$ ，自相矛盾。

下面就是需要分析可不可以进行化简的问题。

> [!note]
> 如果表中的状态存在两部分的效果是一样的。那么就可以化简。

很明显，在这里是不需要化简的。

然后是进行**状态分配**

理论上来说， $ABCD$ 是随便放的。

而如何才算是**好**呢？

有三个原则：

1. 输出完全相同，现态**相邻**（ABC 两两相邻，在这里是矛盾的）
2. 同一个现态，次态**相邻**（对于 $A$ 来说，它的两个次态要相邻）
3. 次态相同，现态**相邻**（在这里只有 $AD$ 的一个次态都是 $A$ ）

![|500](imgs/Pasted%20image%2020250915163311.png)

分配之后，所有 $A$ 都是 $00$ ，所有 $B$ 都是 $01$ ，所有 $C$ 都是 $11$ ，所有 $D$ 都是 $10$

然后是根据分配的结果，得到**二进制化的状态表**：

![|575](imgs/Pasted%20image%2020250915163926.png)

接下来是将其对于每一个输出项： $Q_{1}^{n+1}$ 、 $Q_{2}^{n+1}$ 、 $Z$

将他们的**卡诺图**画出来。

> [!important]
> 注意，卡诺图的变量分配顺序是按照 BCD 码的顺序来分配的： $00$ 、 $01$ 、 $11$ 、 $10$ 。
> 
> 这也就意味着，我们在提取变量的时候，必须按照卡诺图的格式来提取。
> 
> 在这里，刚好 $C$ 是 $11$ ，不需要变换顺序。
> 
> 而如果 $D$ 是 $11$ ， $C$ 是 $10$ ，那么需要手动在后面将他们两个的顺序进行颠倒。 
> 
> 目的就是为了要得到卡诺图的状态。


![|575](imgs/Pasted%20image%2020250915164610.png)

得到卡诺图之后的，就是参照 $JK$ 触发器的特征方程：

$$
Q^{n+1} = J\overline{Q^{n}} + \overline{K}Q^{n}
$$
将每一个的特征方程的出来：

> [!note]
> **注意，在这里进行的不是卡诺图的化简，而是要在凑形式**

![|575](imgs/Pasted%20image%2020250915165237.png)

最后就是将触发器的图画出来：

![|625](imgs/Pasted%20image%2020250915165658.png)

### 任意进制计数器

下面以五进制计数器为例子来说明：

这五个状态如果题目没有说，那就是随机的，五进制的意思是有五个状态再进行循环，并非是从 0 加到 4.

而第一步是将真值表画出来。

![|350](imgs/Pasted%20image%2020250917140327.png)

然后是用卡诺图来化简。

注意题目是用 $JK$ 还是 $D$ 触发器。

![|600](imgs/Pasted%20image%2020250917140801.png)

如果题目中没有提到无关状态是否会**自启**，或者**挂起**，那么一般设为 $d$ 来处理。

> [!note]
> 注意，这里必须要进行分析**多余状态**。
> 
> 一种方法是将多余的状态直接代入到特征方程中，进而得到是否能进入到循环中。
> 
> 如果是用卡诺图的方法来判断，那么就之间观察这个输入对应的卡诺图上的位置是什么，如果这个值被圈起来了，代表是 $1$ ，如果没有被圈起来就是代表为 $0$
> 
> 所以在这里 $000$ 的次态是 $011$

![|500](imgs/Pasted%20image%2020250917142614.png)

而 $010$ 的次态输出为 $111$ ， $100$ 的次态输出为 $111$ 。也就是都是自启的，没有挂起状态。

最后就是画图即可。将 JK 触发器连接起来。

### 挂起的修复

如果分析出来，存在挂起的状态，那么在设计的过程中还需要进行修复。

下面还是以一个例子来分析：

![|550](imgs/Pasted%20image%2020250917143331.png)

首先在得到电路图之后，要先把特征方程写出来。

然后利用特征方程，再将**状态转换真值表**列出来。

然后是状态转换关系表、关系图：

![|575](imgs/Pasted%20image%2020250917143618.png)

然后可以发现出现了挂起问题。

> [!note]
> 解决方法则是将其中一个状态的**次态**变成**循环**中的任意一个状态即可。
> 
> 例如将 $100$ 的次态由原来的 $111$ 换成 $110$

![|525](imgs/Pasted%20image%2020250917144908.png)

因为改变的是 $Q_{0}^{n+1}$ 在 $Q_{2}Q_{1}Q_{0}$ 在 $100$ 状态下的值，所以如果要进行改变，可以使用卡诺图的方法来改变。

![|350](imgs/Pasted%20image%2020250917145017.png)

然后再按照改变之后 $J$ 和 $\overline{K}$ 将电路进行修改即可修正**挂起状态**

### 状态化简

状态化简主要解决的问题是将电路中可能出现相同作用的部分统一起来，减少元器件的使用。

#### 等价状态

> [!note]
> 等价状态，这里指的是**现态相等**，如果满足下面的条件，则可以得到现态相等
> 
> 有两个条件：
> 
> 1. 输出完全相同
> 
> 2. 次态等效

首先是**输出完全相同**，这部分比较起来还是比较简单的。只需要看最后的结果即可。

然后是**次态等效**，这里又分成好几种情况：

第一种是**次态相同**，或者各自**维持原状**。

![|400](imgs/Pasted%20image%2020250918153501.png)

> [!note]
> 维持原状的意思本质上是次电路实现的公式是一样：就是保持输出不变。

第二种是**次态交错**：

![|350](imgs/Pasted%20image%2020250918153131.png)

第三种是**次态循环**

![|525](imgs/Pasted%20image%2020250918153914.png)

更复杂一点是：

![|475](imgs/Pasted%20image%2020250918153955.png)

$A$ 、 $B$ 是否等效取决于 $C$ 、 $D$ 

$C$ 、 $D$ 是否等效取决于 $E$ 、 $F$ 

$E$ 、 $F$ 是否等效又反过来取决于 $A$ 、 $B$

这就构成了**循环次态**。

但是，如果最后面的 $E$ 、 $F$ 之间如果不是**等效**的，那么前面的所有都不是等效的了。

![|425](imgs/Pasted%20image%2020250918154355.png) \

#### 等价特性

##### 传递性

$$
(A,B),(B,C) \rightarrow (A,C)
$$
$A$ 、 $B$ 等效， $B$ 、 $C$ 等效，那么可以推断出 $A$ 、 $C$ **等效**。

##### 等价类

等价类是**等价状态的集合**

比如上面的 $A$ 、 $B$ 等效， $B$ 、 $C$ 等效，那么可以推断出 $A$ 、 $C$ **等效**，那么可以认为是两两等效。

用集合的形式表示就是： $(A,B,C)$

当然如果 $D$ 是单独的一个，也就是**没有等效**的，也是一个集合： $(D)$

##### 最大等价类

最大等价类就是我们最后要找的目标。

例如： $(A,B,C)(D,E)(F)(G)$ ，这就是四个**等价类**。他们就构成了**最大等价类**。

$$
(A,B,C)(D,E)(F)(G) \Rightarrow A^{\prime}B^{\prime}C^{\prime}D^{\prime}
$$


#### 例子

下面这个例子是比较简单，可以直接看出来。

![](imgs/Pasted%20image%2020250918155523.png)

第二种方法是针对比较复杂的情况：使用的方法是**隐含表法**

#### 隐含表法

> [!note]
> 方法叫做：**取“头”少“尾”**

列一个表，形如：

![|375](imgs/Pasted%20image%2020250918155906.png)

方法是：

1. 做表
2. 顺序比较
3. 关联比较
4. 写出最大等价位

下面用一个例子来说明：

![|600](imgs/Pasted%20image%2020250918160615.png)

到上面这个表这一步已经完成了前两步，接下来是后面两步：

![|600](imgs/Pasted%20image%2020250918161058.png)

先将上面表中需要进行判断的判断出来。

然后是利用**传递性**将**最大等价类**求出来

得到最大等价类是：

$$
(ADF)(BE)(CG)
$$

然后在用得到的这三个最大等价类画一个新的状态表。

![|475](imgs/Pasted%20image%2020250918161857.png)

> [!note]
> 还是要对着原来的表将最大等价类的表画出来。
> 
> 注意替换问题：
> 
> 以 $s_{0}$ 为例。现在的 $s_{0}$ 由 $ADF$ 组成，所以输出就是 $ADF$ 中任意一个的输出。
> 
> **次态**则也是由 $ADF$ 决定。原来 $A$ 的次态是还是 $A$ ，而 $A$ 属于 $s_{0}$ ，所以 $s_{0}$ 的次态就是 $s_{0}$
> 
> 只需要理解他们都是**等价状态**（次态和输出都是一样的）即可

再来一个例子：

![|625](imgs/Pasted%20image%2020250918162654.png)

然后就是画出改进后的状态图。

### 设计中 Mealy 型和 Moore 型的区别

常见的输出与变化有关的是 $Mealy$ 型，它的输出受到脉冲的调控。

而 $Moore$ 型，则只与状态有关。

所以在画图的时候， $Moore$ 型的状态会比 $Mealy$ 型的多一些。此外 $Moore$ 型的输出标在每个**状态**的下面。如下图：

![|600](imgs/Pasted%20image%2020250918164040.png)

> [!note]
> 注意，在这里的，这两种形式的区别还是比较大的。
> 
> 因为 $Moore$ 型，因为有 $5$ 个状态，所以需要 $3$ 个触发器。
> 
> 而 $Mealy$ 型只需要 $2$ 个即可。

当然也要**具体情况具体分析**

## 异步时序电路的设计

> [!important]
> 这部分不算是重点

流程上还是一样，依然是先画出**状态转换图**或者**状态转换表**。

而在过程上，用触发器的激励表来显示比较合适。

![|170](imgs/Pasted%20image%2020250921171434.png)

> [!note]
> 而在过程中，我们发现，在进行状态转换的时候，我们将其中一部分的触发器的 $JK$ 都设置为 $1$ ，那么意味着，只要来一个 $CP$ 脉冲，就会在原来输出的基础上进行翻转。那么可以设计电路去控制 $CP$ ，但是最少要有一个触发器的 $CP$ 是受外部控制的，这样才能构成**异步触发器**

下面用例子来说明：

首先是高位的触发器。

![|600](imgs/Pasted%20image%2020250921172052.png)

由于这里依然是按照有外部 $CP$ 的方法来进行判断。所以依据的是 $JK$ 触发器的**激励表**

从 $Q_{0}^{n}$ 到 $Q_{0}^{n+1}$ ， $JK$ 分别为 $0$ 和 $d$ （无关项）

![|600](imgs/Pasted%20image%2020250921172407.png)

这一部分，完全是按照同步时序逻辑电路的设计方法来实现的。

下面则是来设计 $CP_{1}$ 和 $CP_{2}$ 控制这两部分脉冲的电路。

这部分的电路设计的主要依据是当有 $CP$ 脉冲的时候，才会发生跳变。

![|600](imgs/Pasted%20image%2020250921174315.png)

> [!important]
> 总体的设计思路就是令其中的至少一个为同步时序逻辑电路设计。
> 
> 其他的触发器让 $JK$ 保持为 $1$ ，用 $CP$ 以及根据它的状态转换表实现控制 $CP$ 实现状态转换。

这里发现对于 $CP$ 的门电路设计过于复杂。那么可以适当的对 $JK$ 也进行控制，不再一直保持 $1$ 。那么在这样的情况下，就需要结合 $CP$ 的真值表和 $J$ 、 $K$ 的真值表来一起分析。

首先是无关项，这个直接先写上，然后是分析 $CP$ 脉冲的真值表，因为我们现在是要化简，所以根据之前得到真值表，其中一部分状态下 $CP$ 是等于 $0$ 的。所以这个时候 $J$ 、 $K$ 是无关项。

然后是分析当 $CP = 1$ 的时候，会发生变化，这个时候就要对 $JK$ 进行重新设计，设计的过程还是要对照 $JK$ **激励表**

![|600](imgs/Pasted%20image%2020250921180200.png)

然后是 $Q_{2}$ 的触发器：

![|600](imgs/Pasted%20image%2020250921180609.png)

当然，除此之外，可以直接让 $Q_{2}$ 的触发器接外面的 $CP$ ，也就是换成同步时序电路。

这样总体上来看也是异步的。

## 时序逻辑集成电路

### 寄存器

芯片为 8 位 CMOS **74 HC 374**

![|650](imgs/Pasted%20image%2020250923155130.png)

上面这个图是内部结构。

主要是**由 $D$ 触发器**构成。

并且这个是一个**并入、并出**形的结构。**并行输入，并行输出**

此外，这是一个**边沿触发**，（上升沿触发）

![|625](imgs/Pasted%20image%2020250923155725.png)

### 移位寄存器

#### 单向移动

> [!note]
> 这里将 $Q_{0}$ （**低位**）放到**左边**， $Q_{3}$ （**高位**）放到**右边**
> 
> 从低位向高位移动，因为低位在左边，所以叫做**右移**
> 
> 反之，从高位向低位移动，低位在左边，就叫做**左移**
> 
> 单向移动，就只能是**左移**或者**右移**
> 
> 不同教材上，针对**向右移动**的定义是不一样的，根本区别在于低位在左边还是右边。

![|600](imgs/Pasted%20image%2020250925140125.png)

在这里，如果输入为 $1101$ ，这个叫做**串行输入**

![|600](imgs/Pasted%20image%2020250925140655.png)

当来到第四个脉冲 $CP$ 的时候，四个输出端，刚好输出输入的四位二进制数。那么这个就叫做**并行输出**。

综合起来叫做**串行输入，并行输出**

此外，当**最高位**一位一位输出的时候，这就叫做**串行输入，串行输**出。

如果是 $4$ 位二进制数，那么就需要 $8$ 次脉冲才会完全输出。

##### 集成块 74 HC 164

![|600](imgs/Pasted%20image%2020250925141456.png)

其中的 $D_{SB}$ 在正常工作中，置 $1$ 。

$\overline{CR}$ 作为**置零端**。

下面是一些移位寄存器的应用：

如果将高位的 $Q_{7}$ 与 $D_{SA}$ **相连**，就形成了**循环**

![|600](imgs/Pasted%20image%2020250925141856.png)

如果在连接的基础上加一个**非门**，那就形成了**钮环**：

原来如果是 $4$ 位，那就是 $4$ 位一循环。加一个非门就变成了 $2\times 4 = 8$ 位一循环。 

![|600](imgs/Pasted%20image%2020250925142209.png)

#### 双向移位

即能左移，也能右移。很明显，需要一个控制端来对左移还是右移进行控制。

而这里就是使用**二选一数据选择器**来实现。

![|625](imgs/Pasted%20image%2020250925145206.png)

而对于实现此功能的集成电路是 **74 HC 194**

##### 集成块 74 HC 194

194 这个芯片比较重要，它有**四位输入**，**四个功能**。

![|600](imgs/Pasted%20image%2020250925145720.png)

分别来看这四个功能：

1. 首先 $00$ 就不需要考虑：是保持不变。

2. 然后是 $11$ ，实现的功能是将 $D_{0}$ 、 $D_{1}$ 、 $D_{2}$ 、 $D_{3}$ 的输入，从 $Q_{0}$ 、 $Q_{1}$ 、 $Q_{2}$ 、 $Q_{3}$ 输出。

3. 下面是 $10$ ， $10$ 代表着**左移**，意味着是**从高位向低位移动**（这里的移动指的是下一次脉冲来之后，相对于上一次脉冲的四个输出的位置。）需要在 $D_{SL}$ 上加入**数据**。

4.  $01$ 是类似的。是**右移**，意味着是**从低位向高位移动**。需要在 $D_{SR}$ 上加入**数据**。

 此外还要清零端 $\overline{CR}$ ，平常清零端置 $1$ ，如果置零则意味着无条件输出为 $0$

##### 194 的应用

在左移或者右移的过程中，将其中的几个输出通过一些门电路，然后接到输入上。

本质上是构成进制计数器。

![|600](imgs/Pasted%20image%2020250925153050.png)

> [!note]
> 这里有点规律。
> 
> 如果是将相邻的两个与非到一起作为最低端的输入，那么一般都是**奇数进制计数器**
> 
> 如果是间隔一个的两个输出与非到一起作为最低端的输入，那么一般是**偶数进制计数器**

当然，这里接入的可以是随意结合的门电路，当然，本质上还是循环移位。所以只需要判断最低位上的变换即可。

### 计数器 - 161

#### 四位二进制计数器 - 161

一般来说，同步计数器使用的范围比较大，异步计数器不怎么用

功能表：

> [!note]
> **异步清零，同步置数**
> 
> 在这里**清零**是不需要看脉冲的，只要清零端有效，立马变成零

![image.png|525](https://picture-typora.obs.cn-north-4.myhuaweicloud.com/images/20250926190146.png)

其中 $CET$ 和 $CEP$ 可以认为是计数控制端。当他们都为 $1$ 的时候才会开始计数。

> [!note]
> 计数：不需要考虑输入是什么，只要满足计数的条件，那么来一个**脉冲**，就开始从 $0$ 一直计数到 $15$ ，也就是从 $0000$ 到 $1111$ 。

而当 $\overline{PE}$ 为 $0$ ，也就是它**有效**的时候，在有**脉冲的时候**，其作用就是**置数**，输入是什么，输出就是什么。

![|550](imgs/Pasted%20image%2020250926150348.png)

#### 实现十六进制以内的计数器

这里实现任意进制比较简单，只要是在**计数状态**下，那么输出计数只与脉冲有关系。

##### 反馈清零法

第一种方法是**反馈清零**：

这里实现的方法就是，是几位进制，那就将此二进制数的 $1$ **与非**到一起连接到置零端。

> [!important]
> 由于这里的置零是异步置零，也就是只要置零端有效，那么直接将结果置零。
> 
> 这也就意味着，如果我们要设计一个 $13$ 进制的计数器，那么就不能在 $1100$ 这里置零，这样会导致只要出现 $12$ 就置零了，只能实现 $12$ 进制的计数器。所以需要进一位到 $13$ ，也就是 $1101$ ，才能实现 $13$ 进制

这样就会导致 $13$ 这个状态是出现就结束，所以在状态图中的 $13$ 是虚线，实际上只到 $12$

![|625](imgs/Pasted%20image%2020250926160538.png)

> [!note]
> 清零法一定是从 $0$ 开始计数的。

##### 反馈置数法

第二种方法是**反馈置数**

反馈置数，运用的就是**置数端**，而置数端是**同步置数**

当然这里的置数，置的是 $0000$ 。

然后对于控制置数，则是将第 $12$ 个状态**与非**到一起。与**反馈清零法**不一样。

本质上是因为反馈置数是受 $CP$ 脉冲的控制。

![|625](imgs/Pasted%20image%2020250926161710.png)

当然，下面的置数不一定非要从 $0000$ 开始。当然可以是任意的，但是这个时候就要从这个置数的数开始计算进制是多少。

![image.png|625](https://picture-typora.obs.cn-north-4.myhuaweicloud.com/images/20250926180836.png)

这样就能得到一个公式：

$$
X - M  + 1 = 进制
$$
其中， $X$ 是要用与非门连接起来的二进制数。 $M$ 是下面输入端接的二进制数，也就是置数的时候从什么时候开始。

![image.png|625](https://picture-typora.obs.cn-north-4.myhuaweicloud.com/images/20250926181213.png)

> [!note]
> 在上面这种情况中，上面的四个输出是 $1111$ ，这就导致了 $TC$ 是为 $1$ 的，那么就可以直接使用 $TC$ 来控制。

![image.png|600](https://picture-typora.obs.cn-north-4.myhuaweicloud.com/images/20250926182013.png)

> [!important]
> 只要是在 16 进制以内的，都可以使用一片 161 来实现进制计数器。

但是如果超过 16 进制，那么就需要多片 161 来实现。

#### 任意进制计数器（多片 161）

单片的功能表：

![image.png|525](https://picture-typora.obs.cn-north-4.myhuaweicloud.com/images/20250926190146.png)

##### 整体反馈法

![image.png|600](https://picture-typora.obs.cn-north-4.myhuaweicloud.com/images/20250926183211.png)

将两块 161 进行串联，实现 $256$ 进制内的计数器。

这里需要注意的是右边的是高位，左边的是低位。

只有当低位满 $16$ 也就是输出为 $1111$ ， $TC = 1$ 的时候，连接方法是将低位的 $TC$ 连接到 $CEP$ 和 $CET$ （**计数控制端**）上

> [!note]
> 当低位的 $TC = 1$ 的时候，会让高位开始计数，而当下一个 $CP$ 来的时候，低位就又从 $0$ 开始了，导致低位的 $TC \neq 1$ ，导致高位是**保持状态**（注意，**功能控制端**无论是清零还是置数，都是低电平有效。），直到下一次低位又满进制为止，高位再进一位。

然后，无论是使用**反馈清零法**还是**反馈置数法**都跟一片的时候是一样的。

##### 级联法

> [!note]
> 当要求的进制可以拆成两个数相乘的时候，可以使用级联法，比如：
> 
> $$ 72 = 8 \times 9 $$

级联法的核心是将一个多进制的计数器拆成两个小的计数器，例如 $21 = 3\times 7$ 。

> [!note]
> 级联法为了避免过程复杂，一般都使用**反馈置数法**

首先是用两片分别实现一个 $3$ 进制，一个 $7$ 进制的计数器。

想办法实现当低位计数器达到 $7$ 之后使高位的 $3$ 进制进一位。

所以，要找一个低位满进制之后输出为 $1$ 的，去控制高位的计数控制端，使其计一次数。可以发现当**与非**之后为 $0$ ，再取反就是 $1$ 。所以将它连接到高位的计数控制端。

连接方法如下图所示（这里是从 $0001$ 开始 ）

![image.png](https://picture-typora.obs.cn-north-4.myhuaweicloud.com/images/20250926195255.png)

而上面多出来的连接到**高位与非门**上的是为了避免出现高位一到 $0011$ （ $3$ ）就因为达到进位的要求从而变成 $0001$ 。

> [!important]
> 注意，这里并不能将高位改成 $4$ 位进制。原因在于当高位已经是 $3$ 的时候，低位也**满进制**的时候，那么就会导致下一次来脉冲，高位又进了一位，但是它想要再回到原来的位置还需要在等 $CP$ 脉冲，这也就导致了出现不正确的情况。

