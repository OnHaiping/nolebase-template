---
tags: 
comment: true
---
## 数电模电的区别

首先是电子电路分类：

1. 模拟电路
2. 数字电路

模拟信号是在时间上和幅度上都**连续变换**的信号

数字信号是在时间上和幅度上都**断续变化**的信号

模拟电路研究的是输出与输入信号之间的大小、相位、失真等方面的关系；

数字电路研究的是输出与输入间的逻辑关系（因果关系）

数字电路中的**三极管工作**在饱和或者截止状态，**起开关作用**

![|425](imgs/Pasted%20image%2020250411174925.png)

## 描述方法

**二值数字逻辑和逻辑电平**

![|425](imgs/Pasted%20image%2020250411175100.png)

**逻辑代数**

用于描述客观事物逻辑关系的工具。

**逻辑体制**

正逻辑体制：规定高电平为逻辑 1，低电平为逻辑 0

负逻辑体制：规定高电平为逻辑 0，低电平为逻辑 1

通常，如没有加说明，一般以正逻辑来处理

## 数制

### 十进制（Decimal）

不过多描述，就是基本十进制，不过要注意的是下标除了用 $10$ 来表示，还可能用 $D$ 来表示。

数码所处的**位置不同**，所代表的数值不同。

![|375](imgs/Pasted%20image%2020250411175727.png)

$10^{i}$ 称为十进制的权， $10$ 称为基数， $0\sim 9$ 十个数码称为系数。

**数码与权的乘积，称为加权系数**

十进制数可以表示为各位加权系数之和，称为**按权展开式**

$$
(385.64)_{10} = 3\times 10^{2} + 8 \times 10^{1} + 5\times 10^{0} + 6\times 10^{-1} + 4\times 10^{-2}
$$
### 二进制（Binary）

跟十进制类似，表示方式是右下角标识 $2$ 或者 $B$ ，如： $(1011.11)_{2}$ 、 $(1011.11)_{B}$

二进制的数码： $0$ 、 $1$ ，**权**： $2^{i}$ ，基数： $2$

进位规律：逢二进一

将按位权展开式按照**十进制规律**相加，即得到**对应的十进制数**，例如：

$$
\begin{aligned}
(1011.11)_{2} &= 1\times 2^{3}  + 0\times 2^{2} + 1\times 2^{1} + 1\times 2^{0 } + 1\times 2^{-1} + 1\times 2^{-2}\\
& = 8 + 0 + 2 + 1 + 0.5 + 0.25\\
& = 11.75
\end{aligned}
$$

### 八进制（Octal）

表示方法为 $(XXX)_{8}$ 或者 $(XXX)_{O}$

数码是从 $o\sim 7$ ，**权**是 $8^{i}$ ，基数是 $8$

进位规律是**逢 8 进 1**

将按位权展开相加，即可以得到对应的**十进制数**

$$
(573.46)_{8}  = 5 \times 8^{2} + 7\times 8^{1} + 3\times 8^{0} + 4\times 8^{-1} + 6\times 8^{-2}
$$
### 十六进制（Hexadecimal）

$H$ 作为其下标，或者 $16$ 作为其下标。

数码从 $0\sim 9$ ，以及 $A(10),B(11),C(12),D(13),E(14),F(15)$

**权**是 $16^{i}$ ，基数是 $16$ ，进位规律是**逢 16 进 1**

**这里的加减法不太好算**

同样的，这个也可以按位权展开相加，即得到对应的十进制数。

$$
(5EC.D4)_{16} = 5\times 16^{2} + 14 \times 16^{1} + 12 \times 16^{0} + 13\times 16^{-1} + 4\times 16^{-2}
$$
### 不同进制之间的相互转换

#### 转换为十进制

主要**方法**就是**按位权展开再求和**，上面例子中有说明

#### 十进制到其他进制

> [!note]
> 这部分的方法是：
> 
> 整数部分采用：**除基取余法**
> 
> 
> 小数部分采用：**乘基取整法**

如何理解，其实不难。

如果是转换成二进制，就将十进制**整数部分**除以二（**短除法**），八进制就是整数部分除以八，十六进制就是整数部分除以十六。当然，除完之后，还要取余数。

而小数部分就是成以基数，再取整。

例如：将 $(36.375)_{10}$ 转换为二进制。

![|275](imgs/Pasted%20image%2020250412162010.png)

按照上面的除法一直向下除下去，每一次都能得到一个余数，直到商为 0 为止。

而读取的时候，要**从下面往上面读**。

![|525](imgs/Pasted%20image%2020250412162226.png)

然后是计算小数部分。

小数部分则是将十进制小数部分的数字拿过来，乘以 $2$ ，然后将得到的整数部分拿过来。**注意，无论得到的整数部分是 $0$ 还是 $1$ ，都要拿出来。**

![|275](imgs/Pasted%20image%2020250412162424.png)

但是，这里有一点需要注意，也是经常会错的地方。

注意看第二次乘以 $2$ ， $0.75\times 2 = 1.5$ ，这里要把整数部分**拿出来**。而拿出来之后，**剩下的部分**再进行乘 $2$ 。 $1.5$ 把 $1$ 拿出来之后就只剩下 $0.5$ 了，所以后面再乘以 2 的部分是 $0.5$

直到最后得到的是 $0$ 乘以 $2$ 。当然，也有可能永远也得不到 $0$ ，那么只需要保留上几位小数即可。（注意看上图中的最后一次乘 $2$ ， $0.5\times 2 = 1$ ，而这里还是要把 $1$ 拿出来，最后剩下一个 $0$ 才算结束 ）

而读取的顺序则是和**整数部分**正好**相反**。

**整数部分是从下往上读，而小数部分则是从上往下读**。

下面是这个例题：

![|650](imgs/Pasted%20image%2020250412163304.png)

其他进制也是一样的方法，就是**基**变了而已。

#### 二进制与八\十六进制快速转换

首先是二进制、八进制和十六进制之间的相互对照表。

![|275](imgs/Pasted%20image%2020250412163818.png)

根据相互对照表，可以得到：**一位八进制数需要 3 位二进制数来表示**

下面是全部的对照：

![|450](imgs/Pasted%20image%2020250412164513.png)

可以得到：**1 位十六进制数需要用 4 位二进制数来表示**

##### 二进制与八进制

二进制到八进制：

> [!note]
> 
> 从小数点开始，整数部分向左、小数部分向右**三位一组**，不足三位的加 $0$ 补足（两边）三位，再按照顺序写出各组对应的**八进制数**

例如：

$$
(11100101.11101011)_{2} = ()_{8}
$$
整数部分和小数部分分别按照上面的方法，三位一组划分开来，得到：

![|550](imgs/Pasted%20image%2020250412165113.png)

由于是转换到八进制上，所以是**三个一组**，而根据对应表（421）的方法就可以得到八进制数是多少。

八进制到二进制：

> [!note]
> **将每位八进制数用三位二进制数代替，再按照原来的顺序排序。**

例如：

$$
(745.361)_{8} = (111100101.011110001)_{2}
$$
##### 二进制与十六进制

注意，一位十六进制数对应 4 位二进制数，因此二进制数 4 位为一组。

二进制到十六进制：

> [!note]
> 从小数点开始，整数部分向左、小数部分向右**四位一组**，不足四位的加 $0$ 补齐四位，再按照顺序写出各组对应的十六进制数。

例如：

![](imgs/Pasted%20image%2020250412165703.png)

十六进制到二进制：

> [!note]
> 每位十六进制数用四位二进制数代替，再按照原顺序排列

例如：

![|525](imgs/Pasted%20image%2020250412172016.png)

#### 八进制与十六进制

这两个之间没有快速转换，只能是利用中间桥梁来实现转换。（比如二进制）

例如：

$$
(653.12)_{8} = (110101011。001010)_{2} = (1AB.28)_{16}
$$
## 码制

### 二进制代码

用数码的特定组合表示特定信息的过程称为**编码**

![|500](imgs/Pasted%20image%2020250412172612.png)

![|475](imgs/Pasted%20image%2020250412172654.png)

### BCD 码（二进制表示十进制）

四位二进制码有十六种组合，表示 $0\sim 9$ 十个数有多种方案，所以 $BCD$ 码有多种

![](imgs/Pasted%20image%2020250412173451.png)

#### 8421 BCD 码

这个是恒权码，取 4 位自然二进制数的前 10 种组合。

这个就是比较常见的哪个 BCD 码

#### 2421 BCD 码和 5421 BCD 码

有权码，从高位到低位的权值分别为 $2、4、2、1$ 和 $5、4、2、1$

#### 余 3 BCD 码

这个是**无权码**

无权码表示不能用之前 8421 之类的一样的去乘，没有这样的规律。

**比 8421 BCD 码多余 3 (0011)**

8421 BCD 是从 0000 开始的，而余 3 BCD 码是从 0011 开始的

#### 例题

用 BCD 码来表示十进制数码

$$
(36)_{10} = (00110110)_{8421BCD}
$$
> [!important]
> 注意，转换成 8421 BCD 数，每一位都要变换。比如有两位数，那么就是分别对这两位进行变换。

例如下面这个：

$$
(10)_{10} = (00010000)_{8421BCD}
$$
$$
(9)_{10} =(1001)_{8421BCD}
$$
$$
(4.79)_{10} = (0100.01111001)_{8421BCD}
$$
当然，反过来也是很简单的，比如：

$$
(01010000)_{8421BCD} = (50)_{10}
$$

![|500](imgs/Pasted%20image%2020250413153107.png)

### 可靠性代码

#### 格雷码

格雷码（Gray 码，又称为循环码）

最次位（最右边一位）以 $0110$ 为循环节一直循环四次

此低位（右边数第二个）以 $00111100$ 为循环节一直循环两次

第三位 （右边数第三个）以 $0000111111110000$ 为循环节

最高位（右边数第四个）以 $0000000011111111$ 为循环节

![|525](imgs/Pasted%20image%2020250413153940.png)

后面在卡诺图那里会用到，其**特点**是**相邻项之间**只有 **1** 位不同

##### 二进制与格雷码互转

首先是二进制转格雷码

从二进制的左边开始，右边一位与左边的一位进行**异或**，如果不同变成 1，如果相同变成 0；**最高位不变**

直接上例题：

$$
(101110)_{B} \rightarrow (111001)_{G}
$$

然后是格雷码转二进制代码。

这个稍微比较复杂

方法是：高位不变，后面的低位，由前一高位与二进制数中对应位**异或**得来。

比如说，要求二进制中的第二高位，则是由二进制中的第一高位与格雷码中的第二高位**异或**，得到的值就是二进制的第二高位。

直接上例题：

$$
(11010)_{G} = (10011)
$$
图解：

![|350](imgs/Pasted%20image%2020250908141838.png)

#### 奇偶校验码

奇偶校验码由两部分组成：

1. 信息码：需要传送的信息本身
2. 1 位校验码：取值为 $0$ 或者为 $1$ ，以使整个代码中 $1$ 的个数为奇数或者偶数

使 " $1$ "的个数为奇数的称为**奇校验**，使 " $1$ "的个数为偶数的称为**偶校验**

> [!note]
> 举个例子：如果信息码是 $0110$ ，并且使用 8421 奇校验码，那么还要再加上一个校验码 $1$ ，原因是信息码 $0110$ 中有两个 $1$ ，是偶数，但是使用的是奇校验，所以要再加上一个 $1$ 。反之，如果还是使用奇校验，且信息码是 $1110$ ，那么校验码就是 $0$ ，因为信息码中 $1$ 的个数已经是奇数了，不需要加上一个校验码凑出奇数来了。

![|500](imgs/Pasted%20image%2020250413154815.png)

## 基本逻辑运算与复合逻辑运算

### 与运算

> [!note]
> 当决定某一件事的所有条件都满足的时候，该事件才会发生。

例子：

![|475](imgs/Pasted%20image%2020250413155157.png)

**记忆：有 0 出 0，全 1 为 1**

其逻辑表达式为：

$$
Y = A \cdot B = AB
$$
当然，还有相对应的电路符号。在下图中。其实就是 c 语言中的 `&`

![|500](imgs/Pasted%20image%2020250413155706.png)

### 或运算

> [!note]
> 当决定某一件事情的诸多条件中，只要有一个或者一个以上的条件具备时，该事件就发生。

![|500](imgs/Pasted%20image%2020250413155849.png)

记忆：有 1 出 1，全 0 出 0

逻辑表达式为：

$$
Y = A + B
$$
电路符号表达在下图中：

![|500](imgs/Pasted%20image%2020250413161358.png)

### 非运算

当决定某件事的条件满足时，事件不发生；反之事件发生。

![|475](imgs/Pasted%20image%2020250413161515.png)

记忆：入 0 出 1，入 1 出 0

逻辑表达式：

$$
A = \overline{A}
$$
电路符号表达在下图中：

![|500](imgs/Pasted%20image%2020250413161644.png)

### 与非运算（NAND）

记忆：有 0 出 1，全 1 出 0

其本质上就是 **先与后非**

逻辑表达式为：

$$
Y = \overline{AB}
$$
电路符号表达在下图中

![|525](imgs/Pasted%20image%2020250413161858.png)

### 或非运算（NOR）

记忆：有 1 出 0 ，全 0 出 1

其本质上是 **先或后非**

逻辑表达式为：

$$
Y = \overline{A+B}
$$
电路符号表达在下图中

![|525](imgs/Pasted%20image%2020250413162013.png)

### 异或运算（Exclusive-OR）

记忆：**相同为 0，不同为 1**

逻辑表达式为：

$$
Y= A \oplus B = \overline{A}B+A\overline{B}
$$
电路符号表达在下图中：

![|525](imgs/Pasted%20image%2020250413162420.png)

> [!note]
> 这里需要注意的是，在电子元器件中，异或运算的输入只有两个，所有如果要设计三变量之间的异或运算，需要组合逻辑电路，在后面会学到。

异或器还能组成**反相器**

$$
1 \oplus A = \overline{A}
$$
$$
0 \oplus A = A
$$

### 同或运算（Exclusive-NOR）

记忆：**相同为 1，不同为 0**

本质上就是异或运算取非运算得到的。

逻辑表达式：

$$
\begin{aligned}
Y &= A \odot B \\
& = \overline{A\oplus B}\\
& = \overline{A}\overline{B} + A B
\end{aligned}
$$

电路符号表达在下图中：

![|525](imgs/Pasted%20image%2020250413163044.png)

### 与或非运算（AND-OR-INVERT）

其本质上是**先与后或再非**

逻辑符号为：

$$
Y = \overline{AB+CD}
$$

![|450](imgs/Pasted%20image%2020250413163247.png)

### 逻辑符号对照

![|475](imgs/Pasted%20image%2020250413163408.png)

## 逻辑代数的基本定律与规则

### 常量之间的运算

与运算、或运算、非运算：

![|450](imgs/Pasted%20image%2020250415153511.png)

### 逻辑变量与常量之间的运算

#### 0-1 律

如果之间是**与运算**，**如果与 1 则是本身，与 0 则是 0**

如果之间是**或运算**，**如果或 1 则是 1，或 0 则是本身**

![|250](imgs/Pasted%20image%2020250415153842.png)

换种记忆方法：

可以将上面的与运算和或运算就当成**乘法和加法**。（除了 $1+A=A$ ）

> [!note]
> 0 加任何数都是任何数，0 乘任何数都是 0，1 乘任何数都是任何数，当然，1 加 A 是等于 A 的

#### 同一律

这个很好理解：

$$
A +  A = A
$$
$$
A \cdot A = A
$$
将其展开就是 $0\cdot 0 = 0$ ， $1\cdot 1 = 1$ ， $0+0=0$ ， $1+1=1$

#### 互补律

$$
A + \overline{A}  = 1
$$
$$
A\cdot \overline{A} = 0
$$
理解起来也不难，首先是第一个，无论如何，里面肯定有 1，而或运算只要有 1 那就是 1。

第二个，无论如何，里面肯定有 0，而与运算只要有 0 那就是 0。

#### 还原律

$$
\overline{\overline{A}} = A
$$


### 与普通代数类似的定律

#### 交换律

$A+B = B+A$

$A\cdot B =B \cdot A$

#### 结合律

$(A+B)+C = AB+AC$

$(A\cdot B)\cdot C = A\cdot (B \cdot C)$

#### 分配律

$A(B+C) = AB+AC$

$A + BC = (A+B)(A+C)$
$AB +C = (A+C)(B+C)$

特别需要注意的是**第二个**，要把后面**与**的部分拆开。

> [!important]
> 注意，这里一定要**拆开计算**，合起来计算是计算错误的。不能直接先计算 $AB$ 再进行**或运算**

### 摩根定律（反演律）

$$
\overline{(A\cdot B)} = \overline{A} + \overline{B}
$$
$$
\overline{A+B} = \overline{A} \cdot \overline{B}
$$

> [!note]
> 这里的定律一定要记住，这个在后面化简公式的时候经常用

推广公式：

$$
\overline{A\cdot B \cdot C \cdots} = \overline{A}+\overline{B} +\overline{C} + \cdots
$$

$$
\overline{A+B+C\cdots}=\overline{A}\cdot\overline{B}\cdot\overline{C}\cdots
$$
如何正面两个公式相等呢？

第一种方法就是列真值表来对比：

![|450](imgs/Pasted%20image%2020250416191746.png)

第二种就是公式法：

$$
\begin{aligned}
(A+B)(A+C) &= AA + AC +BA + BC\\
& = A + AC + AB + BC\\
& = A(1+C+B) +BC\\
& = A +BC
\end{aligned}
$$

### 逻辑代数的常用公式

#### 吸收律

一、

$$
AB + A\overline{B} = A
$$
解释： $AB + A\overline{B} = A(B+\overline{B}) = A$

二、

$$
A +AB = A
$$
解释： $A+AB= A(1+B) = A$

三、

$$
A + \overline{A}B = A +B
$$
解释：（用的分配律） $A + \overline{A}B = (A+\overline{A})(A+B) = A+B$

记忆的时候，**如果出现一个变量与它的反变量，则直接划去这个反变量就是最后的结果。**

**推广公式：** $\overline{A}+ AB = \overline{A} + B$

#### 冗余律

$$
AB + \overline{A}C + BC = AB + \overline{A}C
$$
这个需要记住的是如何**找到冗余项**，首先找到主变量，就是 $A$ ，其特点是式子中存在其相反变量 $\overline{A}$ ，那么主变量和主变量取反**与**的这两项合起来就是**冗余项**

下面是证明：

$$
\begin{aligned}
AB+\overline{A}C+BC & =AB+AC+BC(A+\overline{A}) \\
 & =AB+\overline{A}C+ABC+\overline{A}BC \\
 & =AB(1+C)+\overline{A}C(1+B) \\
 & =AB+\overline{A}C
\end{aligned}
$$
推广公式：

$$
AB+\overline{A}C+BCD\cdots=AB+\overline{A}C
$$
证明：

$$
\begin{aligned}
AB+\overline{A}C+BCD\cdots & =AB + \overline{A}C + BC + BCD\cdots\\
& = AB + \overline{A}C + BC(1+D\cdots)\\
& = AB + \overline{A}C + BC\\
& = AB + \overline{A}C
\end{aligned}
$$
上面这个其实是原公式中的右边展开了。

#### $\overline{A\overline{B}+\overline{A}B} = \overline{A}\overline{B} + AB$

证明其实也不难：

$$
\begin{aligned}
\overline{A\overline{B}+\overline{A}B}=\overline{A\overline{B}}\cdot\overline{\overline{A}B} & =(\overline{A}+B)(A+\overline{B}) \\
 & =\overline{A}A+\overline{A}\overline{B}+AB+B\overline{B} \\
 & =\overline{A}\cdot\overline{B}+AB
\end{aligned}
$$

其本质是

$$
\overline{A\overline{B}+\overline{A}B} = \overline{A\oplus B}=A\odot B=\overline{A}\overline{B}+AB
$$
下面来一个**推广公式**：

$$
\overline{AB + \overline{A}C} = A\overline{B} + \overline{A}\overline{C}
$$

**上面这个推广公式比较重要，可以记下来**

> [!note]
> 思考：
> 
> 若已知 $A+B = A+C$ ，则 $B\neq C$
> 
> 若已知 $AB= AC$ ，则 $B\neq C$
> 
> ![|425](imgs/Pasted%20image%2020250416204029.png)

#### 关于异或运算的一些公式

**交换律：**

$$
A\oplus B=B\oplus A
$$
**结合律：**

$$
(A\oplus B)\oplus C=A\oplus(B\oplus C)
$$
**分配律：**

$$
A\cdot(B\oplus C)=AB\oplus AC
$$
**常量和变量的异或运算：**

$$
A\oplus\mathbf{1}=\overline{A}\quad A\oplus\mathbf{0}=A\quad A\oplus A=\mathbf{0}\quad A\oplus\overline{A}=\mathbf{1}
$$
异或：相同为 0，不同为 1

同或：相同为 1，不同为 0

**因果互换律：**

如果 $A\oplus B=C$ 则有 $\left\{\begin{aligned}A\oplus C&=\boldsymbol{B}\\\boldsymbol{B}\oplus\boldsymbol{C}&=\boldsymbol{A}\end{aligned}\right.$

### 逻辑代数的基本规则

#### 代入规则

将逻辑等式两边的某一变量均用同一个逻辑函数替代，等式仍然成立。

例如：

$$
A+\overline{A}B=A+B
$$

将 $A$ 均用 $\overline{A}$ 来代替，则得到： $\overline{A}+AB=\overline{A}+B$

亦或者，将 $B$ 均用 $C$ 来代替，则得到： $A+\overline{A}C=A+C$

再来一个例子：

$$
\overline{A+B}=\overline{A}\cdot\overline{B}
$$
将上面公式中的 $B$ 交均用 $B+C$ 来代替，则得到： $\overline{A+B+C}=\overline{A}\cdot\overline{B+C}$

> [!note]
> 利用代入规则，可以扩展基本定理的应用

#### 反演律

对任一个逻辑函数式 $Y$ ，将式中所有的 “.”换成“+”，“+”换成“.”，“0”换成“1”，“1”换成“0”,，原变量换成反变量，反变量换成原变量，则得到原逻辑函数的反函数 $\overline Y$ 。

> [!important]
> 注意：
> 
> 变换的时候不能改变其**运算顺序**
> 
> 原变量变成反变量，反变量换成原变量只对**单个变量**有效，而对**长非号保持不变**。

例题：

$$
Y_1=A\cdot\overline{B+C}+CD
$$

![|550](imgs/Pasted%20image%2020250416210823.png)

另外一个例题：

$$
Y_2=\overline{\overline{A\overline{B}+C}+D}+E
$$

![|400](imgs/Pasted%20image%2020250416211435.png)

> [!note]
> 求逻辑函数的反函数有两种方法：利用反演规则或者摩根定律来求解。

#### 对偶规则

对任一个逻辑函数式 $Y$ , 将式中所有的“.”换成“+”，“+”换成“.”，“0”换成“1”，“1”换成“0”，则得到原逻辑函数的对偶式 $Y^\prime$ 。

> [!important]
> 变换时需要注意的是：
> 
> 不能改变原来的**运算顺序**
> 
> 变量上的非号**均不改变**

**主要作用是定律扩展**

![|525](imgs/Pasted%20image%2020250416212104.png)

例题：

![|300](imgs/Pasted%20image%2020250416212135.png)

> [!note]
> 利用对偶规则可以将基本公式和定律扩展一倍

## 逻辑函数的表达方法及其转换

### 逻辑函数的建立

下面利用这个例题来：

![|500](imgs/Pasted%20image%2020250416213010.png)


一、分析逻辑问题，建立逻辑函数的真值表

首先要找出**输入变量**和**输出函数**，对它们的取值做出**逻辑规定**，然后根据**逻辑关系**列出真值表。

在上面这个题中：

![|350](imgs/Pasted%20image%2020250416213242.png)

那么真值表就是：

![|175](imgs/Pasted%20image%2020250416213323.png)

很明显上面这个是一个**同或**

二、根据真值表写出逻辑式

$$
Y=AB+\overline{A}\overline{B}=A\odot B=\overline{A\oplus B}
$$

三、分析逻辑式以及画出逻辑图

分析**逻辑式**

![|525](imgs/Pasted%20image%2020250416213624.png)

画**逻辑图**

![|675](imgs/Pasted%20image%2020250416213809.png)

> [!note]
> 设计逻辑电路的基本原则是**使电路最简**


### 逻辑函数的表示

> [!note]
> 
> 逻辑函数是用以描述数字逻辑系统输出与输入变量之间逻辑关系的表达式
> 
> 换成表达式为： $Y = F(A,B,C,\cdots)$

逻辑函数由**与、或、非** 3 种基本逻辑运算构成

![|500](imgs/Pasted%20image%2020250417153757.png)

#### 逻辑表达式

表示输出函数和输入变量逻辑关系的表达式，称为逻辑表达式，简称为逻辑式。

逻辑表达式一般根据真值表、卡诺图或者逻辑图写出。

##### 常见表达形式

![|475](imgs/Pasted%20image%2020250417154223.png)

转换方法 ：

与 - 或表达式到与非 - 与非表达式

> [!note]
> 主要方法是使用**还原律（两次取反）**

例如：

$$
\begin{aligned}
Y &= A\overline{B} + BC\\
& = \overline{\overline{A\overline{B}+BC}}\\
& = \overline{\overline{A\overline{B}}\cdot \overline{BC}}
\end{aligned}
$$
上面第二行用的是**还原律（两次取反）**，第三行用**摩根定律**

#### 逻辑函数的标准表达式（最小项）

这里最主要的问题是**最小项**的问题。

> [!important]
> 最小项的定义：在逻辑函数中，如果一个**与**项（乘积项）包含该逻辑函数的全部变量，且每个变量以原变量或反变量形式只出现一次，则称该**与**项为最小项。对于 $n$ 个变量的逻辑函数共有 $2^{n}$ 个最小项。

![|525](imgs/Pasted%20image%2020250417155504.png)

##### 最小项的基本性质

1. 对于变量的任一组取值，只有一个最小项的值为 1
2. 不同的最小项，使其值为 1 的那组变量取值也不同
3. 对于变量的同一组取值，任意两个最小项**与**的结果为 0
4. 对于变量的同一组取值，任意两个最小项**或**的结果为 1

##### 最小项编号

最小项用 $m_i$ 表示，通常用十进制数作最小项的下标编号 $i$ 。编号方法是：将最小项中的原变量当作 1，反变量当作 0，则得一组**二进制数**，其对应的**十进制数**便为最小项的编号 $i$ 。

![|400](imgs/Pasted%20image%2020250417160005.png)

![|525](imgs/Pasted%20image%2020250417160047.png)

##### 最小项表达式

这个就是**标准与或表达式**

任何逻辑函数都是由其变量的若干个最小项构成的，都可以表示成**最小项之和**的形式

而且这种形式是**唯一的**

> [!note]
> 在与或表达式中，有时与项并不是最小项，可以利用 $\overline{A}+A = 1$ 的形式来补充缺少的变量，将逻辑函数变成最小项之和的形式

例如下面这个：

$$
Y=F(A,B,C)=AB+AC
$$
结果：

$$
\begin{aligned}
\mathrm{Y} & =AB(\overline{C}+C)+\overline{A}C(\overline{B}+B) \\
 & =AB\overline{C}+ABC+\overline{A}\overline{B}C+\overline{A}BC \\
 & =m_1+m_3+m_6+m_7 \\
 & =\sum m(1,3,6,7)
\end{aligned}
$$
#### 真值表

列出输入变量的各种取值组合及其对应输出逻辑函数值的表格称为真值表。

真值表能够直观的反应输出、输入变量的逻辑关系，在分析与设计电路时都要写出真值表。

列出真值表的方法有两种：

1. 按照 $n$ 位二进制数递增的方法列出输入变量的各种取值组合。

2. 分别求出各种组合对应的输出逻辑值填入表格

**知道逻辑函数，求真值表以及结果**

直接上例题：

![|525](imgs/Pasted%20image%2020250417183902.png)

核心在于计算上面的公式中的逻辑运算。

**知道真值表，求逻辑表达式。**

方法如下：

1. 找出函数值为 1 的项。

2. 将输入变量取值为 1 的用原变量代替，取值为 0 的用反变量代替，则得到一系列**与**项。

3. 将这些**与**项相加（相或）就得到逻辑式

例题：

![|525](imgs/Pasted%20image%2020250417184503.png)

#### 逻辑图*

逻辑图是由逻辑符号以及相应连线构成的电路图。

逻辑图一般根据逻辑式画出，将各级逻辑运算用相应的门电路实现

直接上例题：

![|525](imgs/Pasted%20image%2020250417185006.png)

> [!note]
> 画图的时候，要注意美观问题
> 
> 当然，最重要的是，这部分考试会经常考，要多注意

#### 波形图

波形图代表输入变量和对应的输出变量随时间变化的波形。

画波形图的时候需要注意，其横坐标是**时间轴**，纵坐标是**变量取值**，由于变量取值只有 0 和 1，一般在图中不用标出坐标轴，但输入、输出变量要**对应画出**。如下图所示。

![|300](imgs/Pasted%20image%2020250417185329.png)

当然，主要问题是**从波形图到逻辑表达式的转换**是如何的。

![|525](imgs/Pasted%20image%2020250417185541.png)

其次，反过来从逻辑表达式转换到波形图，也是需要解决的问题。

例题：

![|500](imgs/Pasted%20image%2020250417185909.png)

### 逻辑函数的化简

#### 逻辑函数化简的意义与标准

其主要意义在于让逻辑式最简，以便设计出最简的逻辑电路，从而节省元器件、优化生产工艺、降低成本和提高系统可靠性。

直接上例题：

![|475](imgs/Pasted%20image%2020250417191925.png)

很明显，上面的电路比较复杂，所以尽可能的对其进行化简。

直接将公式化简：

$$
Y = AB + A\overline{B} = A(B+\overline{B}) = A
$$

而得到的结果不需要任何门电路。

![|425](imgs/Pasted%20image%2020250417192100.png)

> [!note]
> 不同形式的逻辑式有不同的最简式，一般要先求取**最简与或式**，然后通过变换得到所需要的最简式。

最简与或式：

1. 乘积项（即**与项**）的**个数**最少，使**与门**个数最少。

2. 每个乘积项中的**变量数**最少，使**与门**的输入端最少。

最简与非 - 与非式

1. **非号**个数最少，使得**与非门**个数最少

2. 每个非号中的变量数最少，使与非门的输入端数最少。

> [!note]
> 主要方法是使用**还原律（两次取反）**
> 
> 在 [ 常见表达形式](#常见表达形式) 中提到

#### 逻辑函数的公式化简法

这个主要是运用**逻辑代数的基本定理**和**公式**来对逻辑表达式进行化简

##### 并项法

运用 $AB+A\overline{B} = A(B+\overline{B}) = A$ ，将两项合并为一项，并消去一个变量。

例题：

$$
Y_1=A\overline{B}C+A\overline{B}\overline{C} = A\overline{B}(C+\overline{C}) = A\overline{B}
$$

$$
\begin{aligned}
Y_2&=A(BC+\overline{B}\overline{C})+A(\underline{B\overline{C}+\overline{B}C})\\
&=A\overline{B\oplus C}+A(B\oplus C)\\
&=A

\end{aligned}
$$

##### 吸收法

运用 $A+AB=A(1+B)=A$ 和 $AB+\overline AC+BC=AB+\overline{A}C$ ，消去多余的**与项**。

上面这句话中的第一个公式还好理解，主要是**第二个**

其实就是之前学到的[冗余律](#冗余律)

例如：

$$
Y_{1} = AB + AB(E+F) = AB(1+E+F) = AB
$$
$$
\begin{aligned}
Y_{2} &= \overline{AB}  + \overline{A} D + \overline{B} E \\
&= \overline{A} + \overline{B} +\overline{A}D + \overline{B}E \\
&= (\overline{A} + \overline{A}D) + (\overline{B} + \overline{B}E) \\
&= \overline{A} + \overline{B} \\
& = \overline{AB}

\end{aligned}
$$
上面的 $Y_{2}$ 主要是用了摩根定律。

$$
Y_{3} = \overline{A}B + AC +\overline{B}\cdot \overline{C} +A\overline{B} + \overline{A}\cdot \overline{C} + BC = \overline{A} B + AC + \overline{B}\cdot \overline{C}
$$
这道题目用的就是[冗余律]，当然用同一种方法，但是过程不一样，得到最后的结果也**可能不一样**

![|375](imgs/Pasted%20image%2020250418211404.png)

最后可以使用真值表来判断是否相等。

> [!important]
> 逻辑函数化简结果不唯一，但是结果真值表肯定一样。

##### 消去法

运用 $A+\overline{A}B = A +B$ 或者 $\overline{A}+AB = \overline{A}+B$ ，消去多余因子

例如：

$$
Y_{1} = \overline{A} + AB + \overline{B}C = \overline{A}+B+\overline{B}C  = \overline{A} + B+C
$$

$$
\begin{aligned}
Y_{2} &=\overline{AB} + AC + BD = \overline{A }+ \overline{ B} +AC +BD\\
& = (\overline{A} + AC) + (\overline{B} + BD)\\
& = \overline{A}  + \overline{B}  + C +D \\
& = \overline{ AB\overline{C} \overline{D}}

\end{aligned}
$$

$$
\begin{aligned}
Y_{3} &= AB + \overline{A}C + \overline{B}C \\
&= AB + (\overline{A} + \overline{B})C\\
& = AB + \overline{AB}C\\
& = AB +C
\end{aligned}
$$

上面第二行用到了摩根定律

##### 配项法

在函数某一项乘以 $A+\overline{A}=1$ ，将一项展开两项，或利用 $A\boldsymbol{B}+ \overline {A}C= A\boldsymbol{B}+ \overline {A}C+ \boldsymbol{B}C$ ，增加冗余项 ${BC}$ 。

例题：

$$
\begin{aligned}
Y_{1} &= AB + \overline{B}\overline{C} + A\overline{C}D\\
& = AB + \overline{B}\overline{C} +  A\overline{C}D(B+\overline{B})\\
& = AB + \overline{B}\overline{C} + AB\overline{C}D + A\overline{B}\overline{C}D\\
& = (AB + AB\overline{C}D) + (\overline{B}\overline{C} + A\overline{B}\overline{C}D)\\
& = AB + \overline{B}\overline{C}
\end{aligned}
$$

其实上面这道题不需要这么麻烦的。直接使用冗余律就可以

$$
\begin{aligned}
Y_{1} &= AB + \overline{B}\overline{C} + A\overline{C}D\\
& = BA  + \overline{B}\cdot \overline{C} + A\overline{C}D\\
& = BA  + \overline{B}\cdot \overline{C}
\end{aligned}
$$

第二个：

$$
\begin{aligned}
Y_{2} = A\overline{B} + \overline{A}B + B\overline{C} + \overline{B}C
\end{aligned}
$$
这道题目是否是最简单形式不太确定，其直观性不强。

![|525](imgs/Pasted%20image%2020250419204543.png)

主要是使用冗余律的逆用，得到的结果就是这样的。

当然还可以针对第一个和第三个来逆用冗余律

![|525](imgs/Pasted%20image%2020250419204709.png)

化简结果是不唯一的。

##### 综合运用

$$
\begin{aligned}
Y_1&=AD+A\overline{D}+AB+\overline{A}C+BD+ACEF+\overline{B}E+DEF\\
&=A(D+\overline{D}+B+CEF)+\overline{A}C+BD+\overline{B}E+DEF\\
& =A+\overline{A}C+BD+\overline{B}E+DEF\\
&=A+C+BD+\overline{B}E+DEF\\
& = A+C+BD+\overline{B}E

\end{aligned}
$$
上面的第三行是消去法，第四行到第五行是使用了吸收法

再来一个例题：

$$
\begin{aligned}
Y_{2} & = AC+\overline{A}D+\overline{B}D+B\overline{C}\\
& = AC+B\overline{C}+(\overline{A}+\overline{B})D\\
& =AC+B\overline{C}+\overline{AB}D\\
& =AC+B\overline{C}+ AB + \overline{AB}D\\
& = AC+B\overline{C}+ AB + D \\
& = AC+B\overline{C}+ D
\end{aligned}
$$
上面的第三行到第四行是逆向使用冗余律，然后与后面哪一项使用消去律。最后再把冗余项吸收进去。

> [!note]
> 拿到题目之后，先看有没有能**合并**的，然后再看一下有什么可以**拆开**的，然后看下有没有可以**消去**的，最后看看能不能添加一个**冗余项**

**使用公式法化简很难判定结果是否为最简，不够直观。**

#### 卡诺图化简*

##### 最小项卡诺图的组成

**相邻最小项**

两个最小项中只有一个变量互为反变量，奇遇变量均相同，称为相邻最小项，简称为**相邻项**

相邻最小项的**重要特点**是：

两个相邻最小项相加（相或）可合并为一项，消去**互反变量**

$$
ABC + AB\overline{C} = AB(C + \overline{C}) = AB
$$

**卡诺图的组成**

1. $n$ 个变量，有 $2^n$ 个最小项，每个最小项都要用 $1$ 个小方格表示。
2. 按循环码的编码顺序（格雷码）排列这个是关键，使相邻最小项在几何位置上也相邻且**循环相邻**

##### 二变量卡诺图

![|500](imgs/Pasted%20image%2020250421171940.png)

画卡托图的时候，左上角是按照**顺时针**的方式去写的，比如 $AB$ ，左边就是 $A$ ，右边就是 $B$ ，当然，读的时候也是按照**顺时针**的方法去读的。

需要注意的是，循环码的方法，是每次只有一个变量与上一个不同，从 $0$ 开始。

**可以看到循环码是按照镜像的方法得到的，上面补 0，下面补 1；得到的正好是卡诺图顺时针读到的数。**

而上面图中的第三个图则是用 $m_{i}$ 的形式来表示的。
 
##### 三变量卡诺图

![|500](imgs/Pasted%20image%2020250421172847.png)

如果这八个格子是有 4 列，则把后两个变量放到一起，如果这个八个格子有四行，则把前两个变量放到一起。

而这个反射码则是将二变量得到的反射码**镜像一下**，然后在上面补 0，下面补 1。这样就得到了最后的结果。这个结果就是卡诺图中**顺时针**写出来的。

同时，需要特别注意下面这个图，后续用的次数非常多，比较难区分的就是**顺序**

![|236](imgs/Pasted%20image%2020250421173214.png)

##### 四变量卡诺图

![|500](imgs/Pasted%20image%2020250421173613.png)

四变量卡诺图的循环码，同样的，是由三变量镜像之后，上面补 0，下面补 1 得到的。

而书写顺序则是两个顺时针圆圈。（如上面图中是黄线所示）

然后再用最小项的方法写出来就是下面这个图（**非常重要，需要记住**）

![|300](imgs/Pasted%20image%2020250421173825.png)

对于上面这个图，最需要注意的地方是**注意 8 所在的哪一行**（在最后一行，而不是倒数第二行）


##### 卡诺图中的相邻项（几何相邻）

![|475](imgs/Pasted%20image%2020250421174143.png)

来个题目：
已知最小项如何找对应小方格？如何写出卡诺图方格对应的最小项。

如 $A\overline{B}\overline{C}D$

![|425](imgs/Pasted%20image%2020250421174429.png)

##### 用卡诺图表示逻辑函数*

> [!note]
> 基本步骤：
> 
> 首先求逻辑函数的**真值表**、**标准**或**一般与或式**；
> 
> 根据变量个数画出**变量卡诺图**
> 
> 根据真值表、标准或一般与或式来**填写卡诺图**。

**直接上例题：**

![|475](imgs/Pasted%20image%2020250421181618.png)

> [!important]
> 卡诺图其实就是一个变相的真值表。

**解题步骤：**

首先是根据题目中的真值表，画出卡诺图。

![|300](imgs/Pasted%20image%2020250421181839.png)

然后找出真值表中 $Y=1$ 对应的最小项，在卡诺图相应方格中填 $1$ ，其他部分不写任何东西。

![|350](imgs/Pasted%20image%2020250421181920.png)

上面得到的这个卡诺图就是最后的结果。

**然后再来看一个例题：**

![|425](imgs/Pasted%20image%2020250421182029.png)

注意到，上面的 $\sum m(0,1,12,13,15)$ 是最小项之和。这个逻辑函数是标准与或式。

当然，首先要做的是先把基础卡诺图画出来。

![|250](imgs/Pasted%20image%2020250421182354.png)

然后要做的是，将逻辑式中的最小项 $m_{0}、m_{1}、m_{12}、m_{13}、m_{15}$ 对应的方格填上 1，其他的方格不写任何东西。

![|500](imgs/Pasted%20image%2020250421182509.png)

**再来一个难题：**

![|525](imgs/Pasted%20image%2020250421182532.png)

上面这个很明显不是一个标准与或式，需要先将其换成标准与或式，或者直接不转换，直接在图上进行**找交集**

首先是画出标准的四变量卡诺图。然后找**交集**。

首先看第一个变量 $AB$ ，这个代表着 $CD$ 可以任意取值。

再看第二个变量 $\overline{A}D$ ，这个代表着可以同时满足 $A=0$ ， $D= 1$ 的小方格。

最后看最后一个变量 $B\overline{C}D$ ，这个代表着可以满足 $B=1$ ， $C = 0$ ， $D = 1$ 的小方格。

最后的结果如下：

![|475](imgs/Pasted%20image%2020250421183342.png)

##### 卡诺图化简逻辑函数*

###### 化简依据

其原理在于利用卡诺图的相邻性，对相邻最小项进行合并，消去互反变量，以达到化简的目的。

###### 化简规律

1. 当 2 个小方块相邻（包括处于同一行或同一列的两端），有 1 个变量相异，相加可以消去这**一个变量**，从而合并为一项
   
   ![|400](imgs/Pasted%20image%2020250421185741.png)
   
   当然，上面这种还需要提取出来计算的方法还是比较慢的，下面的这个方法相对来说是比较快的。
   
   就是这个口诀是：**消异存同**
   
   ![|400](imgs/Pasted%20image%2020250421190635.png)

2. 4 个小方块组成一个大方块，或组成**同一行/列**，或组成**两行/列的两端**，或处于**四个角上**，都是可以合并的，**消去两个变量**
   
   当然，用到的方法还是**消异存同**
   
   ![|475](imgs/Pasted%20image%2020250421191455.png)
   
3. 8 个小方块组成两行/列，或组成两边的两行/列，可以合并，消去 3 个变量
   
   用到的方法也是**消异存同**
   
   ![|500](imgs/Pasted%20image%2020250421191826.png)

###### 化简步骤

> [!note]
> 首先是**画出函数的卡诺图**
> 
> 然后，画卡诺圈，将相邻的 $1$ 方格按照 $2^{n}$ 圈为一组，直到**所有的 $1$ 被圈完**
> 
> 然后，将各个卡诺圈分别化简。
> 
> 最后，将各卡诺圈的化简结果**逻辑加**

> [!important]
> 卡诺圈的**数量要越少越好，圈越大越好** 
> 
> 一个圈中的小方格**至少有一个小方格不为其它圈所圈**。

直接上例题：

![|525](imgs/Pasted%20image%2020250421192551.png)

再来一个例题：

![|525](imgs/Pasted%20image%2020250421193030.png)

上面这题，主要说明的形式是第二个，一个卡诺圈内的 1（变量）至少有一个没有被其他圈给圈起来，这也就导致了中间的哪个大圈其实是多余的。

###### 画卡诺圈规则

1. 每个圈中所包含“1”的小方块数只能为 $2^n$ 个，如 $2、4、8$ ;

2. 画圈的时候，应该**将圈画的尽量大**，**圈数最少**

3. 一些为 1 的小方块，可以被圈一次以上

4. 一个圈内至少要有一个之前没有被圈过的 1 的小方块

5. 所有的 1 都要被圈起来，孤立的 1 也不能**漏掉**

再来几个例题：

![|475](imgs/Pasted%20image%2020250421194125.png)

###### 特殊情况

有可能出现，多种花圈的方式，进而导致后面的结果也是不一样的。

![|500](imgs/Pasted%20image%2020250421194404.png)

> [!note]
> 逻辑函数化简的结果不唯一

再来一个例题：

![|500](imgs/Pasted%20image%2020250421194711.png)

上面这个题目说明，可以使用两种圈卡诺圈的方式来化简。

但是，上面第二种方法中，0 必须是相邻项才行，当 1 比较多的时候，可以考虑

###### 有约束的逻辑函数的卡诺图化简

> [!note]
> 约束条件当作备胎来用，需要的时候就用，不需要的时候就不用。

有些题目中，会提供某些选项不能同时出现，比如说之前 8421 BCD 码，后面 6 种都是约束项，不能同时出现。

而约束条件，用 $d$ 来表示

![|500](imgs/Pasted%20image%2020250421201357.png)

由于其约束项的值恒为 0，将这些为 0 的最小项加入到逻辑函数与或式中，或者不加进去，都不会影响函数的值，所以在化简的时候将其看成 1 或者 0 都是可以的，使圈最少且最大即可，从而将结果最简。

直接上例题比较好理解：

![|325](imgs/Pasted%20image%2020250421201708.png)

![|475](imgs/Pasted%20image%2020250421202017.png)

在来一个例题：

![|450](imgs/Pasted%20image%2020250421202140.png)

再来例题：

![|500](imgs/Pasted%20image%2020250421202411.png)

最后一个比较难的题目：

![|500](imgs/Pasted%20image%2020250421202756.png)
