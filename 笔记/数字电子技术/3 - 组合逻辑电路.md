---
tags: 
comment: true
---
数字电路根据逻辑功能特点分为：**组合逻辑电路**、**时序逻辑电路**

> [!note]
> 组合逻辑电路：任一时刻的输出只取决于该时刻的输入信号，而与电路原有的状态无关的电路
> 
> 时序逻辑电路：任一时刻的输出不仅取决于该时刻的输入信号，而且与电路原有的状态有关的电路
> 
> 区分组合和时序电路的重要一点是：**电路中是否具有触发器**

这一章学的是组合逻辑电路。

![|500](imgs/Pasted%20image%2020250426154953.png)

## 组合逻辑电路的竞争冒险

### 产生的原因

看下面这个电路：

![|300](imgs/Pasted%20image%2020250813164150.png)

当在**静态**的时候，很明显，结果为 $A\cdot \overline{A} = 0$ ，当然，这个前提就是静态。

但是，当是动态的时候，每个信号进来的时间都是需要时间的。

还是上面这个图，因为上面那条线还经过了一个**非门**，相比较下面那条线多经过了一个元器件，这样就会出现**延迟问题**。

分析下来，以 $A$ 信号为例，因为有延迟，就会导致结果偏差：

![|275](imgs/Pasted%20image%2020250813164625.png)

这里就是竞争与冒险，我们把**有错误发生的竞争称为冒险**

![|275](imgs/Pasted%20image%2020250813164804.png)

### 消除方法

#### 改变表达式形式

第一种方法就是**改变表达式形式**。

避免出现 $A\cdot \overline{A}$ 和 $A + \overline{A}$ 的形式。

例如：

$$
F = ( A + \overline{ B}) \cdot ( \overline{ A} + C)
$$
当 $B = 1$ ， $C = 0$ 的时候，就会出现 $A \cdot \overline{ A}$

为了避免竞争冒险，不要使用**或与式子**

将这个式子展开，就可以得到：

$$
F = AC  + \overline{A}\cdot \overline{B} + \overline{B}C
$$
但其实上面这个也会出现，就是当 $C = 1$ ， $B =0$ 的时候，会出现 $A+\overline{A}$ 。但这个时候 $\overline{B}C \equiv 1$ ，那 $A+\overline{A} + 1 \equiv 1$ ，这也就算是同样避免了这个问题。

#### 人为消除一项（卡诺图）

这个主要是在卡诺图上使用。

假设函数化简出现下面这种情况。

![|197](imgs/Pasted%20image%2020250813170801.png)

其最简形式就是图上两个圈。但是这样就会出现竞争冒险问题，想要避免此类问题。就是避免**圈与圈之间相切**

再上图中，就出现了圈与圈相切。解决方法就是用另外一个圈将这两个相切的圈连接起来。如下图所示：

![|211](imgs/Pasted%20image%2020250813171130.png)

当然，还有下面这种情况：

![|199](imgs/Pasted%20image%2020250813171217.png)

左边的和右边的本质上也是相切的，想要避免竞争冒险，同样的方法就是用另外一个圈将这两个相切的连接起来。

> [!note]
> 主要，如果是**函数化简**的，那么必须是利用卡托图将其化简到最简形式。
> 
> 如果是要**避免竞争冒险**的，那么就需要有几个多余的“圈”。

#### 在输出端接电容

![|292](imgs/Pasted%20image%2020250813171646.png)

当然，添加电容是最后的办法，原因在于添加电容不只是会对冒险问题进行优化，同样的对于正常的信号也会导致“优化”。

所以电容的选择也是需要考虑的。

## 组合电路的分析与设计

### 组合逻辑电路的分析

根据给定的逻辑电路，找出输出与输入之间的逻辑关系，从而确定电路的逻辑功能，比如加法器、减法器等等

**基本步骤**

![|500](imgs/Pasted%20image%2020250426155232.png)

#### 例一

通过例题来实现理解：

![|475](imgs/Pasted%20image%2020250426155254.png)

直接计算不方便，所以采用分段计算的方法来求最后的 $Y$ ，将每个门电路后面的输出分别计算出来，最后再进行组合，就是最后的 $Y$

![|500](imgs/Pasted%20image%2020250426155537.png)

可以得到逻辑函数式：

$$
\begin{aligned}
\mathrm{Y} & =\overline{Y_2+Y_3+Y_4}=\overline{A\cdot\overline{ABC}+B\cdot\overline{ABC}+C\cdot\overline{ABC}} \\
 & =\overline{\overline{ABC}\cdot(A+B+C)}\\
 &  =ABC+\overline{A+B+C}\\
 & = ABC + \overline{A}\overline{B}\overline{C}
\end{aligned}
$$
下面开始**列真值表**

![|475](imgs/Pasted%20image%2020250426155932.png)

然后是**分析逻辑功能**

很明显，根据真值表，当 $A$ 、 $B$ 、 $C$ 三个输入变量取值**一致**的时候（全为 0 或者全为 1），输出 $Y=1$ ，否则为 $0$ 。此电路为**一致判断电路**

#### 例二

再来一个例题：

![|475](imgs/Pasted%20image%2020250426160223.png)

当然了，虽然上面这个图看上去非常复杂，但是不要担心，计算方法还是一样的，首先就是逐级写出逻辑函数式：

先看左边这部分电路：

![|475](imgs/Pasted%20image%2020250426160750.png)

可以得到：

$$
\begin{aligned}
\boldsymbol{W} & =\overline{\overline{A\cdot\overline{AB}}\cdot\overline{B\cdot\overline{AB}}}=A\cdot\overline{AB}+B\cdot\overline{AB} \\
 & =A\cdot(\overline{A}+\overline{B})+B\cdot(\overline{A}+\overline{B})=A\overline{B}+\overline{A}B=A\oplus B
\end{aligned}
$$
通过观察电路结构发现这三部分的电路结构都是一样的。

其实现的功能也是一样的：将两个输入信号进行**异或**

所以可以直接得到：

![|500](imgs/Pasted%20image%2020250426161056.png)

综上所述，我们就得到了最后的结果：

$$
Y=A\oplus B\oplus C\oplus D
$$

然后，下面来写出真值表。

> [!note]
> 异或的运算规则是：**相同为 $0$ ，不同为 $1$ **
> 
> 同时，在这里补充一个：
> 
> 奇数个 1 进行异或，结果为 1
> 
> 偶数个 1 进行异或，结果为 0

慢慢计算之后得到的结果是：

![|575](imgs/Pasted%20image%2020250426161632.png)

然是进行功能说明：

通过观察真值表，可以得到：当 4 个输入变量中，1 的个数为奇数的时，输出为 1，当 1 的个数为偶数时，输出为 0，所以判断电路为**检奇电路**

### 组合逻辑电路的设计

基本设计步骤：

设计思路：分析给定的逻辑要求，设计出能够实现该功能的组合逻辑电路。

基本步骤：

![|525](imgs/Pasted%20image%2020250426170827.png)

其中的逻辑抽象是需要额外注意的地方。

> [!important]
> 首先是分析给定问题，确定输入变量和输出变量，并进行状态赋值（什么时候取值 0，什么时候取值 1），然后分析输出变量和输入变量之间的逻辑关系，列出真值表。
> 
> 得到真值表之后，使用代数法或者卡诺图法来求**最简与或式**
> 
> 然后根据题目中要求的门电路，将最简与或式变换成要求门类型对应的最简式。

#### 例一 - 三人表决器

直接根据例题：

![|525](imgs/Pasted%20image%2020250426171333.png)

首先是将逻辑抽象。

设定变量：有三个人，所以要有三个变量输入，同时输出为 $Y$

然后进行状态赋值。

因为要设计一个表决器，那就有两种状态，一种是赞同，一种是不赞同。结果也有两种，一种是通过，一种是不通过。

![|500](imgs/Pasted%20image%2020250426171609.png)

当然，在这个题目中，其实说明的不是很具体，应该是有三分之二的人表示同意，则表决通过，反之，不通过。满足少数服从多数。

下面来列出真值表。

![|250](imgs/Pasted%20image%2020250426171810.png)

下面进行化简真值表，其中最好的方法其实就是卡诺图。（注意用**循环码**的方法来画卡诺图）

![|275](https://picture-typora.obs.cn-north-4.myhuaweicloud.com/images/Pasted%20image%2020250426172029.png)

得到最简与或式之后，还要分析题目中的要求，题目中要求用与非门来实现这个电路

所以要对卡诺图化简得到的结果进行变换。

> [!note]
> 求与非门的一个技巧是对**原与或式**进行**两次取反**。

$$
\begin{aligned}
Y&=BC+AC+AB\\
&=\overline{\overline{AB+BC+AC}}\\
&=\overline{\overline{AB}\cdot\overline{BC}\cdot\overline{AC}}
\end{aligned}
$$


最后就是来画**电路逻辑图**了。

![|450](https://picture-typora.obs.cn-north-4.myhuaweicloud.com/images/Pasted%20image%2020250426172438.png)

#### 例二 - 四位二进制转格雷码

再来一个例题：

![|525](https://picture-typora.obs.cn-north-4.myhuaweicloud.com/images/Pasted%20image%2020250426172653.png)

还是按照步骤，首先是进行逻辑抽象，先设定变量：

四位二进制代码用 $A_{3}$ 、 $A_{2}$ 、 $A_{1}$ 、 $A_{0}$ 来表示。输出格雷码用 $Y_{3}$ 、 $Y_{2}$ 、 $Y_{1}$ 、 $Y_{0}$ 来表示。

> [!note]
> [格雷码](#格雷码)：两个相邻码之间只有一位不同
> 
> 那如何实现将二进制码转换为格雷码呢？
> 
> 有两种方法：
> 
> 1. 第一个是使用公式法： $G_i=B_{i+1}\oplus B_i$
>    
>    ![|225](https://picture-typora.obs.cn-north-4.myhuaweicloud.com/images/Pasted%20image%2020250426173240.png)
>    
> 2. 用卡诺图
>     
>    ![|225](https://picture-typora.obs.cn-north-4.myhuaweicloud.com/images/Pasted%20image%2020250426173846.png)
>     
>    这个方法最主要的是需要知道其循环的顺序，这个顺序就是最后的真值表的结果。

下面开始列真值表：

![|550](https://picture-typora.obs.cn-north-4.myhuaweicloud.com/images/Pasted%20image%2020250426174129.png)

按照右边卡诺图上的顺序在左边的输出上依次写出来就是最后的答案。

**下面根据上面的真值表来使用卡诺图进行化简**

当然，尽管上面的真值表中是四个输出，只需要将这四个输出拆开即可。

![|225](https://picture-typora.obs.cn-north-4.myhuaweicloud.com/images/Pasted%20image%2020250426174541.png) 

![|225](https://picture-typora.obs.cn-north-4.myhuaweicloud.com/images/Pasted%20image%2020250426174624.png)

根据上面的化简，得到的结果是：

$Y_{3}= A_{3}$ ， $Y_2=A_3\oplus A_2$ ， $Y_1=A_2\oplus A_1$ ， $Y_0=A_1\oplus A_0$

**然后来画电路逻辑图**

![|425](imgs/Pasted%20image%2020250426174832.png)

### 算数运算电路 - 加法器和数值比较器

数字系统中除了进行逻辑运算之外，还经常需要进行数值的算术运算，而在系统中的加、减、乘、除都是利用加法器来进行的，所以加法器便成为了数字系统中最基本的运算单元。

#### 半加器

两个 $1$ 位的二进制数相加，不考虑**低位进位**的加法。（注意，这里还是有高位进位的，当作一个输出，只是不考虑低位进位。）

实现半加功能的电路称为**半加器**。

> [!note]
> 半加的规则：两个 1 位二进制数想加，结果有 2 个输出：**半加和** $S$ （本位和）、**半加进位** $C$

![|400](imgs/Pasted%20image%2020250426175556.png)

所以，根据上面描述，得到真值表：

![|525](imgs/Pasted%20image%2020250426175640.png)

很明显，根据真值表，可以得到：

$$
\Bigg[\begin{aligned}
S&=A\overline{B}+\overline{A}B=A\oplus B \\
C&=AB
\end{aligned}
$$

然后来画电路逻辑图：

![|400](imgs/Pasted%20image%2020250426180823.png)

当然，在一些电路中，可以将上面这个半加器化简成一个符号来表示：

![|200](imgs/Pasted%20image%2020250426181435.png)

#### 全加器

将本位的 2 个二进制数和相邻地位来的进位数进行相加的加法。

实现全加功能的电路称为全加器。

![|525](imgs/Pasted%20image%2020250426181759.png)

> [!note]
> 这里需要注意，虽然看上去是两个二进制数在进行相加，但是还隐藏了一个地位进位的输入，所以在真值表上其实是有三个输入。

![|350](imgs/Pasted%20image%2020250907125745.png)

> [!important]
> $A_i,B_i$ 表示 $A$ 、 $B\textbf{两 个 数 中 的 第 }i$ 位， $C_i- 1\textbf{表 }$ 示来自低位 (第 $i-1$ 位) 的进位， $S_{i}$ 表示全加和， $C_i$ 表示送给高位 (第 $i+1$ 位) 的进位。

![|475](imgs/Pasted%20image%2020250426182409.png)

注意看，上面真值表中的第三个输入代表是否有进位，如果有进位，则需要将进位也计算在内。

后面的输出部分，本质上是把一次运算的结果拆成两部分，一部分（ $S_{i}$ ）是本位得到的，一部分 $C_{i}$ 是向上一位送去的。

然后，再仔细观察真值表，发现当三个输入中有奇数个 1 的时候， $S_{i}$ 为 1，当输入中有偶数个 $1$ 的时候， $S_{i}$ 为 0

所以根据经验就可以得到：

$$
\begin{aligned}
S_i  &= \overline{A_{i}}\cdot \overline{B_{i}} C_{i-1} + \overline{A_{i}} B_{i}\overline{C_{i-1}} + A_{i} \overline{B_{i}}\cdot \overline{C_{i}} + A_{i}B_{i} \cdot \overline{C_{i-1}}\\ 
& = \overline{A_{i}}(B_{i}\oplus C_{i-1}) + A\cdot \overline{(B_{i} + C_{i-1})}\\
& =A_i\oplus B_i\oplus C_{i-1}\\
\end{aligned}
$$
当然也可以用卡诺图的方法计算出来，其结果是一样的。

![|425](imgs/Pasted%20image%2020250907135911.png)

$C_{i}$ 同样可以使用卡诺图的方法得到：

$$
\begin{aligned}
C_i  &= A_{i}B_{i}\overline{C_{i}} + A_{i}\overline{B_{i}}C_{i-1} + \overline{A_{i}}B_{i}C_{i-1} + A_{i}B_{i}C_{i}\\
&=(A_i\oplus B_i)C_{i-1}+A_iB_i
\end{aligned}
$$
然后其符号如下：

![|250](imgs/Pasted%20image%2020250426184251.png)

实现全加器的逻辑电路如下：

![|475](imgs/Pasted%20image%2020250907135258.png)

##### 使用半加器实现全加器

 主要使用的是半加器的性质，两个输出一个是**进位输出**（与），一个是**本位和**（异或）

![|400](imgs/Pasted%20image%2020250426180823.png)

这样，按照功能其实就能得到**连接方法**：

![|500](imgs/Pasted%20image%2020250907140726.png)

用两个半加器和一个或门就能得到一个全加器。

##### 全加器实现二进制乘法

![|500](imgs/Pasted%20image%2020250426184803.png)

注意，除了最后一位，其他位上相加都会有进位的存在。

因为在计算中存在进位的问题，所以不能简单的用与或来表示，要用到之前提到的全加器。

注意，全加器有两个输出，分别代表本位输出和进位输出。

综上所述，乘法的电子逻辑图为：

![|400](imgs/Pasted%20image%2020250426185402.png)

#### 多位加法器

实现多位二进制加法运算的电路，进位方式有逐位进位（串行进位）和超前进位（并行进位）两种

> [!note]
> 串行进位加法器：低位进位输出端**依次**连至相邻高位的进位**输入端**，最低位进位输入端接地。因此，高位数的相加必须等到低位运算完成后才能进行，运算速度较慢。
> 
> 超前进位加法器：进位数直接由加法、被加数和最低位进位数形成。各位运算并行进行，运算速度快。

##### 串行进位加法器

![|525](imgs/Pasted%20image%2020250426190546.png)

特点是 1. 电路简单，连接方便 2. 速度低

![|425](imgs/Pasted%20image%2020250426190650.png)

##### 超前进位加法器 - 74 LS 283

![|500](imgs/Pasted%20image%2020250426190801.png)

![](imgs/Pasted%20image%2020250907142443.png)

这里可以认为是利用递归的思想来实现的。

是直接将高位中需要等待低位输入的部分直接换成最低位的输入，这样就不存在等待了，因为最低位的输入部分是已知的。

不过一般是直接使用集成块来实现功能。

##### 集成块 283 加法器的应用 

**应用 1 -- 8 位二进制数相加**

首先是 8 位二进制数相加，原 283 加法器是 4 位二进制数相加。

![|475](imgs/Pasted%20image%2020250907143147.png)

连接的方法比较简单，但是需要注意的是，两块 283 加法器之间是串联的，所以这也就导致高位需要等低位完成之后才能进行。

但 283 加法器内部是高速并行的。

**应用 2 -- 8421 BCD 码转余 3 码**

![|500](imgs/Pasted%20image%2020250907143502.png)

8421 BCD 码与余 3 码之间，只需要对 8421 BCD 码加 3 即可得到余 3 码

#### 减法器

减法运算要用到补码。以及负数的表示。

直接用例子来说明：

设 $A = 0,110$ ， $B = 0,010$ ， $A$ 是 $+6$ ， $B$ 是 $+2$

注意，无论是 $A$ 还是 $B$ ，前面的哪个 $0$ 代表的是这是个**正数**，这一位是**符号位**

然后是运算 $A - B$ ， $A-B = A + (-B)$

接下来看如何求 $-{B}$

在进行减法运算的时候，无论是谁减谁，都需要换成**补码**来运算

对于正数 $A$ ，它的补码就是它本身： $A = 0110$

然后是对于要求的 $-B$ ，由于 $B$ 本身是正数，取它的负数要对补码进行处理。首先是将标志位原来的 $0$ 换成 $1$ ，然后在进行**取反加一**

$$
0010 \rightarrow 1010 \rightarrow 1101 \rightarrow 1101 + 1 = 1110
$$
然后就是进行加法运算：

$$
0110 + 1110 = 1,0100
$$
重点来了，在上面的加法运算中，出现了**进位**，那么就可以直接得到结果为 $0,100$ ；注意，这里最前面的 $0$ 依然是代表着**符号位**。，意思是正数.

反之，如果是 $B - A = 0010 - 0110 = -2$

首先还是 $B$ ， $B$ 是个正数，所以它的补码就是它本身，得到 $0010$ 。

然后是 $A$ ，在这里需要对 $A$ 进行处理：

$$
0110 \rightarrow 1110 \rightarrow 1001 \rightarrow 1001 + 1 = 1010
$$
其中，第一步是将标志位换成 1，代表负数，然后就是再进行**取反加一**。

然后是计算 $0010 + 1010 = 01100$ ，最前面的代表是否有进位，如果有进位就是 $1$ ，如果没有进位就是 $0$ 。

很明显，这里是没有进位的。并且我们通过加法计算得到的其实是结果的**补码**： $1100$ 。

我们已知这个是负数，负数的补码再进行取反加一得到的就是原码。

注意，这里 $1100$ 前面的 $1$ 是代表负数，在进行取反加一的时候，不参与运算。

得到最后的结果是： $100 \rightarrow 011 \rightarrow 011 + 1= 100$

下面是使用加法器实现减法器。

![|475](imgs/Pasted%20image%2020250907152253.png)

逻辑上是一样的，如果得到的结果有进位，那么就不需要再取反加一了，如果得到的结果没有进位，那么需要在进行一边取反加一。

取反使用的性质是异或门的**取反性质**。

#### 数值比较器

数值比较器用于对两个数字的大小或者是否相等进行比较的逻辑电路

##### 一位二进制数值比较器

当然，还是按照之前的分析方法来设计电路。

首先是分析设计要求，列出功能表。

设输入的两个 1 位二进制数为 $A、B$ ，输出比较的结果有三种情况： $Y_{(A>B)}$ 、 $Y_{(A=B)}$ 、 $Y_{(A<B)}$ ，有输出时为 1，否则为 0

下面直接列出真值表

![|525](imgs/Pasted%20image%2020250427172603.png)

然后是根据真值表来写出逻辑函数表达式

$$
\begin{aligned}
 & Y_{(A>B)}=A\overline{B} \\
 & Y_{(A<B)}=\overline{A}B \\
 & Y_{(A=B)}=\overline{A}\cdot\overline{B}+AB=\overline{A\oplus B}
\end{aligned}
$$

甚至于，我们可以得到这三个输出之间的关系：

$$
F_{A=B} = \overline{F_{A>B} + F_{A<B}}
$$

最后是画出电路逻辑图：

![|450](imgs/Pasted%20image%2020250427172858.png)

下面推广到多位数值比较器。

##### 二位二进制数值比较器

当然，首先比较高位，然后是低位。

![](imgs/Pasted%20image%2020250901171000.png)

$$
F_{A>B}  = (A_{1}>B_{1}) + (A_{1}=B_{1}) \cdot (A_{0}>B_{0}) = A_{1}\overline{B_{1}} +(\overline{A_{1}}\cdot \overline{B_{1}} + A_{1}B_{1})\cdot(A_{0}\overline{B_{0}})
$$
$$
F_{A=B} = (\overline{A_{1}}\cdot \overline{B_{1}} + A_{1}B_{1}) \cdot(\overline{A_{0}}\cdot \overline{A_{0}}+A_{0}B_{0})
$$
$$
F_{A<B} = (\overline{A_{1}}B_{1})+(\overline{A_{1}}\cdot \overline{B_{1}} + A_{1}B_{1})\cdot(\overline{A_{0}}B_{0})
$$

如何使用两个一位二进制数值比较器来实现二位二进制数值的比较呢？

具体接线如下图所示。

![|400](imgs/Pasted%20image%2020250901180244.png)

##### 多位数值比较器

> [!note]
> 比较原理：从**最高位**开始逐位向低位进行比较
> 
> 举个例子：
> 
> 比较 $A = A_{3}A_{2}A_{1}A_{0}$ 和 $B = B_{3}B_{2}B_{1}B_{0}$ 的大小：
> 
> 若 $A_{3}>B_{3}$ ，则 $A>B$ ；若 $A_{3}<B_{3}$ ，则 $A<B$ ；若 $A_{3}=B_{3}$ ，则需要比较**次高位**
> 
> 若次高位 $A_2>B_2$ ，则 $A> B$ ；若 $A_2< B_2$ ，则 $A<B$ ；若 $A_2= B_2$ ，则再去比较更低位。
> 
> 以此类推，直到最低位比较结束

这里就需要使用集成块来实现了

![|500](imgs/Pasted%20image%2020250427173456.png)

在上面这个比较器中，有三个级联输入端，意味着如果这个两个四位二进制数，都相等，那么最后的结果则是根据这个级联输入端来判断的。具体看下面这个功能表。

![|600](imgs/Pasted%20image%2020250427173830.png)

下面是 74 LS 85 的使用说明：

1. 当只比较两个 4 位二进制数时，或**不使用扩展端**（意味着此比较器作为低位使用）时，将扩展端的 $I_{(A=B)}$ 接 1， $I_{(A<B)}$ 和 $I_{(A>B)}$ 接 $0$ 。其实 $I_{(A<B)}$ 和 $I_{(A>B)}$ 在这时取什么都是可以的，但是为了方便来说，取 $0$ ；这样的话，对于低位来说，相当于**再低位**的比较结果是**相等的**，那么就再去比较高位即可。

2. 当比较两个 4 位以上 8 位以下的二进制数时，应先比较两个高 4 位的二进制数，在高位相等时，才能比较低 4 位数。只有在两个 4 位二进制数相等时，输出才由扩展端 $I_{(A>B)}、 I_{(A<B)}、 I_{(A=B)}$ （相当于再去**由低位决定**）决定。

下面是用两个 74 LS 85 来级联成 8 位数值比较器

![|625](imgs/Pasted%20image%2020250427174456.png)

![](imgs/Pasted%20image%2020250901215032.png)

如果是十六位的，那么可以将四个 4 位二进制数值比较器串联起来，也是可以实现十六位的二进制数值比较。

下面是使用并联的形式，来实现十六位的二进制数值的比较

并联，就需要使用 5 个二进制数值比较器。

连接方法如下：

![|425](imgs/Pasted%20image%2020250901220245.png)

> [!note]
> 关键在于第二级连接，由于第一级输出的是逻辑结果，那么只需要比较是否存在大于小于的情况，至于等于的情况，不需要考虑在内，原因在于如果在第一级上出现等于，那么相应的，大于小于的输出一定是 $0$ ，再输入到二级中的时候，输入就已经相当于是**相等**的了

### 编码器和译码器

#### 编码器

> [!note]
> 编码：用文字、符号或数字来表示特定对象的过程。
> 
> 在数字电路中，采用**二进制**进行编码

![|525](imgs/Pasted%20image%2020250427174747.png)

下面来看一下**输入信号**与**输出位数**之间的关系

![|500](imgs/Pasted%20image%2020250505164854.png)

这个说明的是如果有 8 个待编码的信号，那么至少需要 3 位二进制代码数。

如果只有 6 个待编码的信号，那么也需要 3 位二进制代码数。

##### 二进制编码器

二进制编码器是将 $N = 2^{n}$ 个输入信号转换成 $n$ 位二进制代码的逻辑电路。

比如说下面这个例题：

![|450](imgs/Pasted%20image%2020250505165311.png)

当然，这个例题依然是按照之前求解实际问题的方法（组合逻辑电路的设计）来解决。

首先是分析设计要求，列出功能表。

由题意可知，该编码器有 8 个输入信号，分别是 $I_0$ 、 $I_1...$ $I_7$ ，有编码请求时，输入信号用 1 表示，没有时为 0。根据 $2^n\geq N=8$ 可求得输出 $n=3$ ,为 3 位二进制代码，分别用 $Y_0$ 、 $Y_1$ 、 $Y_2$ 表示。

> [!note]
> 普通的二进制编码器是一种多输入、多输出的组合电路，在某一时刻只能对**一个输入信号**进行编码，不允许有两个或两个以上的信号**同时**有效，具有**相互排斥性**。

如下面的真值表。

![|525](imgs/Pasted%20image%2020250505165804.png)

然后是根据真值表写出输出逻辑函数表达式；

$$
\begin{aligned}
Y_2&=I_4+I_5+I_6+I_7\\
Y_1&=I_2+I_3+I_6+I_7\\
Y_0&=I_1+I_3+I_5+I_7

\end{aligned}
$$
这里直接就看其输出为 1 的对应的输入上的信号即可。本质上是**吸收律**

然后换到与非式：

$$
\begin{aligned}
Y_{2}&=\overline{\overline{I_{4}}\cdot\overline{I_{5}}\cdot\overline{I_{6}}\cdot\overline{I_{7}}}\\
Y_{1}&=\overline{\overline{I_{2}}\cdot\overline{I_{3}}\cdot\overline{I_{6}}\cdot\overline{I_{7}}}\\
Y_{0}&=\overline{\overline{I_{1}}\cdot\overline{I_{3}}\cdot\overline{I_{5}}\cdot\overline{I_{7}}}
\end{aligned}
$$
下面画出逻辑图

![|525](imgs/Pasted%20image%2020250505170629.png)

下面这个是以 4 个信号为例子，用卡诺图化简的方法实现为什么 $Y_{1} = I_{2} + I_{3}$

![|500](imgs/Pasted%20image%2020250505212019.png)

进而得到的结果是下面这个，后续可以直接使用这种方法从而快速的求解输出对应输入之间的关系。

![|500](imgs/Pasted%20image%2020250505212313.png)



##### 二-十进制编码器

用二进制数对十进制数进行编码

依然是通过例题来解答：

![|525](imgs/Pasted%20image%2020250505170755.png)

下面来分析设计要求，列出功能表。

由题意可知，该编码器有 $I_0$ 、 $I_1...I_9$ 10 个输入信号，有编码请求时，输入信号为 1，没有时为 0。根据 $2^n\geq N=10$ 可求得输出 $n=4$ ，故有 4 个输出端，分别用 $Y_0$ 、 $Y_1$ 、 $Y_2$ 、 $Y_3$ 表示。

这种编码是**不完全编码**

> [!important]
> 注意，在这种编码中，不一定是用什么方法来进行编码，这个题目是编码成 8421 BCD 码，当然可以能是其他的顺序。

![|350](imgs/Pasted%20image%2020250505171236.png)

然后是根据真值表来写出逻辑函数表达式

$$
\begin{aligned}
  Y_{3} & =I_8+I_9 \\
  Y_2 & =I_4+I_5+I_6+I_7 \\
  Y_{1} & =I_2+I_3+I_6+I_7 \\
  Y_0&=I_1+I_3+I_5+I_7+I_9
\end{aligned}
$$
然后换成与非表达式得到：

$$
\begin{aligned}
 & Y_{3}=\overline{\overline{I_8}\cdot\overline{I_9}} \\
 & Y_2=\overline{\overline{I_4}\cdot\overline{I_5}\cdot\overline{I_6}\cdot\overline{I_7}} \\
 & Y_1=\overline{\overline{I_2}\cdot\overline{I_3}\cdot\overline{I_6}\cdot\overline{I_7}} \\
 & Y_{0}=\overline{\overline{I_1}\cdot\overline{I_3}\cdot\overline{I_5}\cdot\overline{I_7}\cdot\overline{I_9}}
\end{aligned}
$$
下面是画出电路逻辑图

![|550](imgs/Pasted%20image%2020250505171635.png)

按照题目的要求是要用与非门来实现，但是上面图中用的不全是与非门，当然也可以用直接用与非门来表示非门，具体方法在上面图中的右上角。

##### 十进制编码器补充

针对十进制编码器，其主要实现的逻辑电路如下图所示。

![](imgs/Pasted%20image%2020250820185912.png)

这里的问题在于对于输入 $0$ 的编码，设置成了 $0000$ ，但是在电路中，如果什么也不按，其输出的编码结果与 $0000$ 的编码结果是一样的。这样会无法区分是什么也没按，还是只按了 $0$

所以添加一个**标志位**，当标志位为 $0$ 的时候，表示什么也没按。

其逻辑设计也在上面图中表示。

其功能表图下图所示：

![](imgs/Pasted%20image%2020250820190245.png)



##### 优先编码器

###### 基本优先编码器

之前讲的编码器都是只能单个信号有效，但是在很多场合不只是单个信号，而多个信号就涉及到**优先级**的问题

优先编码器允许同时输入多个编码信号，并且只对其中优先级别高的信号进行编码输出的信号。

> [!note]
> 下面假设 $I_{7}$ 的优先级最高， $I_{6}$ 次之，依次到 $I_{0}$ 最低。优先级高的信号排优先级低的，具有单方面排斥的特性。
> 
> 而在优先级之后的部分无论是有效还是无效都无所谓了。用 $X$ 来表示。

真值表如下图所示。

![|525](imgs/Pasted%20image%2020250505172606.png)

**需要注意的是**，在输出表达的时候，是根据优先级来计算出来的，依然是看对应的部分是如何取值的。而推导则是上面图中的**红色部分**，用到的是**吸收率**

$$
\begin{gathered}
Y_2=I_7+I_6+I_5+I_4 \\
Y_1=I_7+I_6+\overline{I_5}\overline{I_4}I_3+\overline{I_5}\overline{I_4}I_2 \\
Y_{0}=I_{7}+\overline{I_{6}}I_{5}+\overline{I_{6}}\overline{I_{4}}I_{3}+\overline{I_{6}}\overline{I_{4}}\overline{I_{2}}I_{1}
\end{gathered}
$$
> [!note]
> 注意，上面这里不是全部的**非**都被消去了。有一部分没办法被消去。

下面用四个输入信号作为例子以卡诺图化简的方法来进行说明，

首先需要注意的是，在输出部分，由于 $I_{3}$ 输入为 1，后面的输入无论是什么都不影响输出，将这个时候的输出都设置为 1，所以 $Y_{1}=Y_{0}=1$ 。

然后是当 $I_{3}=0$ 、 $I_{2} = 1$ 的时候，后面的输入无论是什么都不影响输出，设置这个时候的输出为 $Y_{1}=0$ ， $Y_0 = 0$

以此类推，当 $I_{3} = 0$ ， $I_{2} = 0$ ， $I_{1} = 1$ 的时候，后面的输入无论是什么都不影响输出，设置这个时候的输出为 $Y_{1} = 0$ ， $Y_{0}=1$

当 $I_{3} = 0$ ， $I_{2} = 0$ ， $I_{1} = 0$ 、 $I_{0} = 1$ 的时候，后面的输入无论是什么都不影响输出，设置这个时候的输出为 $Y_{1} = 0$ ， $Y_{0}=0$

而当输入都为 0 的时候，输出的结果就是无关项了。

![|475](imgs/Pasted%20image%2020250505213600.png)

然后将上面的真值表化简一下，得到右侧的真值表。

最后在这个真值表上找规律：

![|475](imgs/Pasted%20image%2020250505214620.png)

> [!note]
> 在进行计算的时候，只看交叉 (X) 前面的部分，例如 $Y_{1} = I_{3} +\overline{I_{3}}\cdot I_{2}=I_{3} + I_{2}$ ， $Y_{2} = I_{3} +\overline{I_{3}}\cdot \overline{I_{2}}\cdot I_{1} = I_{3}+\overline{I_{2}}\cdot I_{1}$

通过上面这个方法，再将其推广到八个变量。

![](imgs/Pasted%20image%2020250505215113.png)

###### 74 LS 148 优先编码器

这里就不再是传统的门电路了，而是下面这种集成电路：

![|450](imgs/Pasted%20image%2020250505174136.png)

右边的是示意图。

下面对引脚进行说明：

![|550](imgs/Pasted%20image%2020250505174241.png)

下面是功能表：

![|500](imgs/Pasted%20image%2020250505174723.png)

当 $\overline{ST}$ 为 1 的时候，代表不工作，所以无论输入是什么，输出都是 1

只有当 $\overline{ST}$ 为 0 的时候，代表工作，才能进行编码。

而第二行都是 1，代表没有一个信号有效（没有信号输入），因为这里是低电平有效，所以，全 1 其实是全 0

当 $\overline{ST}$ 为 0 代表工作的时候， $Y_{s}$ 和 $\overline{Y_{ES}}$ 则**相反**的。

当输入无效的时候（输入全是 0，取反之后为全 1）， $Y_{s}$ 为 0， $\overline{Y_{ES}}$ 为 1。

从上面图中的第三行开始则是**正常进行编码**

****

下面是 CD 4532 的功能表

其功能于 148 一样，唯一不同不就是这个是高电平有效，148 是低电平有效

![](imgs/Pasted%20image%2020250821201223.png)

其中的 $GS$ 是判断是否有输入的，如果芯片没有输入或者输入使能端为 $0$ ，那么 $GS$ 的输出也是 $0$

$EI$ 代表的是输入使能端，当它为 $0$ 的时候，相当于芯片没有启动，无论输入如何，其功能相当于**无作用**。

$EO$ 代表输出使能端，当芯片有输出的时候， $EO$ 为 $0$ ，反之，当芯片**启动并且没有输入**的时候， $EO$ 为 $1$
###### 148 级联成 16-4 优先编码器

首先来看级联之后的真值表：

![|575](imgs/Pasted%20image%2020250505175704.png)

在上面图中，中间红线左边是低位的 148，右边是高位的 148，问题在于如何将这两部分连接到一起，实现功能。

注意看真值表，当高位片工作的时候，地位片是不工作的，所以，将高位片的 $Y_{S}$ 连接到地位片的 $\overline{ST}$ 上。

此外，无论是高位片还是低位片，都是只有 $\overline{Y_{2}}$ 、 $\overline{Y_{1}}$ 、 $\overline{Y_{0}}$ 的，没有 $\overline{Y_{3}}$ 的，我们需要找一个地方来当做 $\overline{Y_{3}}$ 

然后，当低位片工作的时候，高位片也是不能工作的。

所以，可以发现，最终输出的 $\overline{Y_{3}}$ 与高位片的 $\overline{Y_{ES}}$ 之间有些许关联。

而最终输出的 $\overline{Y_{0}}$ 、 $\overline{Y_{1}}$ 、 $\overline{Y_{2}}$ ，与高位片和低位片之间的输出的关系是**与**

进而得到最后的电路图：

![|475](imgs/Pasted%20image%2020250505205123.png)

****

补充关于 CD 4532 级联的功能示意。

![](imgs/Pasted%20image%2020250821202612.png)

同样的，与 148 功能相同，区别在于高低位激活不一样。

唯一需要注意的是，最后输出四位中的最高位是**高位芯片的使能端**，原因在于当高位有输入的时候，最高位肯定是 $1$ ，而当高位芯片没有输入，但低位芯片有输入的时候，高位芯片的使能端肯定是 $0$ ，这也就保证了输出的正确性。

###### 十 - 四优先编码器 147

![|475](imgs/Pasted%20image%2020250505205311.png)

这个芯片比较特殊，尽管是十位转四位，但是对 $\overline{I_{0}}$ 的编码是隐藏的，当输入端全为 1 的时候，代表 $\overline{I_{0}}$ 为 0，对应的输出是 $1111$

下面是功能（真值）表

![|525](imgs/Pasted%20image%2020250505205611.png)

需要注意到是，这个的编码是反码，首先来看第二行，代表的是 9，而 9 的二进制是 1001，而取反之后得到的是 0110.

其他的也是以此类推。

至于说最上面的哪个全 1 输入，得到的结果是 1111，而取反之后得到的是 0000，代表的也是 0.

> [!important]
> 上面的这部分关于级联编码器以及十-四优先编码器，后续如果有需要再去看。 -- 2025 年 5 月 5 日

#### 译码器

译码器与编码器可以说是相反作用的两个器件。

**译码**：将具有特定意义的二进制代码转换成相应信号输出的过程。

译码器将二进制代码转换成相应信号输出的时候只能译出来一个有效电平。

![|475](imgs/Pasted%20image%2020250505220201.png)

##### 二进制译码器

将输入二进制代码的各种组合按照其原意转换成对应信号输出的逻辑电路

还是以一个例子的方法来说明：

![|475](imgs/Pasted%20image%2020250506160507.png)

设输入 3 位二进制代码为 $A_{2}$ 、 $A_{1}$ 、 $A_{0}$ ，共有 $2^{3} = 8$ 种不同组合。它有 8 个输出端，用 $Y_{0}$ 、 $Y_{1}$ 、 $\cdots$ 、 $Y_{7}$ 来表示，输出高电平 1 有效 

下面列出其功能表（真值表）

![|450](imgs/Pasted%20image%2020250506161001.png)

然后是写出逻辑函数表达式：

![|525](imgs/Pasted%20image%2020250506161250.png)

可以发现其中，每一个输出 $Y_{i}$ 都是一个最小项，（只包含自身和自身的反）

如果我们用这些最小项进行组合，就可以得到其他的逻辑函数，比如只把前四项**或**到一起

如果把这些最小项做一个组合，那么就可以构成三个变量的任意逻辑函数

所以，二进制译码器也称为**函数发生器**。

接下来画一下逻辑图：

![|550](imgs/Pasted%20image%2020250506161707.png)

##### 双 2 线-4 线译码器 139

这一部分使用的比较少。

![|525](imgs/Pasted%20image%2020250821210710.png)

这里是低电平有效，所以上面的使能端和输出都是以低电平的形式输出。

当使能端 $\overline{E} = 1$ 的时候，代表芯片不工作，所以无论输入如何，其输出都为 1

反之，当使能端为 0 的时候，意味着开始工作。

> [!note]
> 需要注意的是，这个是译码器，所以在输出的时候，每一位输出都只能有一位有效。（因为是**低电平有效**，所以以 $0$ 代表有效 ）

在图中使用了逻辑表达式的方法来表示 $\overline{Y_{0}}$ ，当然可以使用卡诺图的方法将其写出来。
##### 3 线 - 8 线译码器 138

这个译码器是一个非常通用的一个译码器

![|475](imgs/Pasted%20image%2020250506161952.png)

下面对引脚进行说明：

![|475](imgs/Pasted%20image%2020250506162053.png)

只有当 $ST_{A} = 1$ 、 $\overline{ST_{B}}=\overline{ST_{C}} = 0$ 的时候**才进行译码**，否则不进行译码，不进行译码输出的结果就是全 0

下面是其功能表（真值表）

![|575](imgs/Pasted%20image%2020250506162612.png)

需要注意的是，由于最后的输出都加上了一个**非**，所以在进行最后的函数上的逻辑运算的时候，要用与非门来实现逻辑组合，原因在于 $\overline{\overline{m_{0}}\cdot\overline{m_{1}}\cdot\overline{m_{2}}} = m_{0}+m_{1}+m_{2}$

下面对上面的功能表做一个补充：

![|575](imgs/Pasted%20image%2020250821215115.png)

只有当 $E_{3}$ 、 $\overline{E_{2}}$ 、 $\overline{E_{1}}$ 的顺序依次为 $100$ 的时候，译码器才会工作，其他情况下都不会工作。不会工作的状态**有七种**。

同时，在输出端，依然是只有一种输出。

##### 3 线 - 8 线译码器的应用

###### 已知输入波形画出输出

这个时候，一般是 $E_{3}$ 接入 $5 v$ ， $\overline{E_{1}}$ 接地，也就是 $0v$

控制器由 $E_{2}$ 来控制。

![|350](imgs/Pasted%20image%2020250821215748.png)

具体的例子如下图：

![|550](imgs/Pasted%20image%2020250821220430.png)

###### 138 译码器的扩展

有的时候，一片 138 译码器不够用，需要两个 138 译码器组成 4-16 译码器

![|550](imgs/Pasted%20image%2020250506163403.png)

注意看上图中，利用芯片 $ST_{A}$ 的特性，将其设置为最高位，当 $A_{3} = 0$ 的时候，低位片工作，当 $A_{3}=1$ 的时候，高位片工作。

下面详细解释一下工作原理

![|600](imgs/Pasted%20image%2020250508165005.png)

注意看上面图中右下角的表，这个表就是其实现的效果。

下面进行补充：

将译码器扩展到 $5$ 线 $32$ 线译码器。

这个是四片 138 联合起来

![](imgs/Pasted%20image%2020250822205720.png)

首先来分析功能表，一共有五位输入，32 位输出。

可以发现后三位是以 8 位一组为循环。所以，我们按顺序将后三位连接到**每一个**芯片的三位**数据输入端**上。

之所以是每一片，原因在于前两位的输入。

前两位的连接方法如上面图中所示，按照从**高位到低位**的特点进行连接。

这个方法主要是利用控制**使能端**的方法对从高位到低位各个芯片的控制，让其能够输出正确的顺序。

举个例子既可以理解：

假设输入的是 $B_{4}B_{3}B_{2}B_{1}B_{0} = 10011$

首先看后三位，是 $011$ ，当被输入的时候，每一个芯片上的三位输入，输入的都是 $011$

如果使能端都是正常工作的，那么每一个芯片的输出都是 $\overline{L_{3}}$ （第三位）

但是前面两位就需要通过控制每个使能端的方法来保证其输出是正确的。

由于输入是 $10$ ，利用图中的连接方法，第一个连接的方式得到的结果是 $110$ ，很明显，此芯片是不工作的，其输出就变成了**全是 0**

其他的以此类推。只有当芯片的使能端满足 $100$ 的方法才能保持工作。

****

当然，还可以使用将前面两位（高位）的输入利用 139 译码器（2 线 - 4 线译码器），将其输出连接到**每个芯片使能端的低电位（两个）**

![](imgs/Pasted%20image%2020250822214205.png)

###### 译码器实现逻辑函数

用例子来实现：

$$
F = \overline{A} B + A \overline{C}
$$
首先是将逻辑函数换成**最小项**。

可以使用公式来计算，也可以使用卡诺图的方法得到最小项。

$$
F(A,B,B) = \sum m(2,3,4,6)
$$
然后是使用 138 来进行表达。

很明显，将 $ABC$ 按照**顺序**将其连接到 138 的输入上。当输入为 $011$ 的时候，经过译码器，译码器的 $\overline{L_{3}}$ 相应，输出为 $0$

同样的，每一个最小项的输入都会有一个对应的输出。但是，最后的结果与相应的是相反的。

所以要将所有最小项输出相应通过一个**与非门**连接起来，就能得到最后的结果

![](imgs/Pasted%20image%2020250822220205.png)

****

扩展情况：

由于一个 138 译码器的正常输入是三位的，但如果想要输入一个 4 位的逻辑函数，如何使用译码器实现逻辑函数

可以使用两片 138 译码器连接到一起来实现这个功能。

![](imgs/Pasted%20image%2020250822220728.png)

这里的主要思想是将最高位的作用设置为控制使能端，然后将剩下的三位按顺序连接到每个 138 的输入端上。

最高位在控制使能端的时候，低位的芯片与高位的芯片在连接上有所不同，一般来说，是将 A 连接到**低位的低控制端上**，并且连接到**高位的高控制端上**。这样，当 $A = 1$ 的时候，就能让低位不工作。只让高位工作。当 $A = 0$ 的时候，让低位工作，让高位不工作。

这样的思想其实是将高位、低位两篇芯片的每一个输出都有对应。将所以的可能性分成两部分，也就是 $F_{all} = \overline{A}(BCD)+ A(BCD)$

当然最后的输出还是使用**与非门**将其连接起来。

****

在实现上面的功能的时候还有一种更简便的方法（更巧妙的方法）

![](imgs/Pasted%20image%2020250822222642.png)

观察这个函数，这个函数可以化成 $F = C(ABD)+ \overline{C}\cdot 0$ 的形式，那么就不需要两个 138 译码器了。

但是需要注意的是，译码器的输入端三个变量的连接顺序需要有所变化。

$$
F = C\cdot (\overline{A}BD + \overline{A}\cdot \overline{B}\cdot \overline{D} + ABD + \overline{A}B\overline{D}) =C \cdot (m_{3} + m_{0} + m_{7} + m_{2})
$$

当然，因为在给定的逻辑表达式中， $C$ 一直都是 $1$ 的，所以直接将 $C$ 连接到使能端的高电平端即可使译码器工作。

###### 138 组成数据分配器

首先理解什么是数据分配器：将一个信号输入进来，然后找到对应的输出，将这个信号再输出出去即可。

其连接方法如下面图所示。

![](imgs/Pasted%20image%2020250822223632.png)

本质上是**将输入的信号连接到使能控制端的低电平有效**上，将选择的**输出地址**当作译码器正常的输入来看待。

这样就能实现将信号以设定好的位置输出出去。

相应的，如果**将输入的信号连接到使能控制端的高电平有效**上，其实现的结果就是将信号**以取反的方法**输出出去。

##### 二 - 十进制译码器

这个的作用是将输入的 10 组 4 位二-十进制代码翻译成 $0\sim 9$ 十个对应信号输出的逻辑电路

![|500](imgs/Pasted%20image%2020250508173204.png)

这个芯片是没有**控制端**的

有十个译码输出端，低电平 0 有效。还有四个 8421 BCD 码输入端，从高位到低位依次是 $A_{3}$ 、 $A_{2}$ 、 $A_{1}$ 和 $A_{0}$

![|475](imgs/Pasted%20image%2020250508173420.png)

下面是它的功能表：

需要注意的是：虽然有四位输入，总共有 $2^{4} =16$ 种输入，但是有效的只有十种，这也就导致了有六种伪码。这六种伪码就全是无效电平。也就是 $1$

![|375](imgs/Pasted%20image%2020250508173705.png)

##### 显示译码器

在之前学到的 138 也就是 3 线-8 线译码器，就是传统上的结果中只有输出是有效电平，剩下的都是无效电平（高电平 1）

但是在一些场合，不只是需要一个有效的信号输出，还需要多个有效的信号进行输出。

下面的显示译码器就是能多个有效信号的输出。

**显示译码器**：将输入的 BCD 码译成相应的输出信号，以驱动显示器显示出相应数字的电路

同样的，这个也是四个输出，十个输出，这也就意味着，在输入的时候，是有**六个伪码**的。这种编码称为**不完全编码**

![|475](imgs/Pasted%20image%2020250514151310.png)

注意，在设计中，设计为 **0 为亮，1 为不亮**，本质上还是取反

在数字设备中用得比较多的是**七段数码显示器**，又称为是数码管。常用的有**半导体数码显示器**（LED）和液晶显示器（LCD）等，它们由七段可以发光的字段组合而成。

![|475](imgs/Pasted%20image%2020250514191622.png)

COM 端称为公共端，是将多个数码管串联到一起用的连接点。

> [!note]
> 测试数码管是共阴极还是共阳极：可以用万用表来测试，如果黑表笔放到 COM 端，红表笔放到其中一个显示端（七个其中一个），亮了就是**共阴极**。红表笔放到 COM 端如果亮了就是**共阳极**

所以它有两种接法：

一个是共阳极接法，一个是共阴极接法

![|550](imgs/Pasted%20image%2020250514191918.png)

> [!note]
> 共阳极接法的数码管需要配用输出低电平有效的译码器。

****

![|550](imgs/Pasted%20image%2020250514192159.png)

> [!note]
> 共阴极接法的数码管需要配用输出**高电平**有效的译码器

****

补充：

![](imgs/Pasted%20image%2020250823205749.png)

在显示译码器中，相比较于传统的译码器，虽然也有三个**使能端**，但是实现的功能还是不一样的。

这里的使能端更像是一种**能够实现更多功能的控制器**

具体控制方法如上面图中所示。

只有当 $\overline{LT} = 1$ ， $\overline{BL} = 1$ ， $LE = 0$ 的时候才正常**译码**

下面是正常译码的时候逻辑表

![](imgs/Pasted%20image%2020250823210336.png)

需要注意的是，当出现**无效码**的时候，**显示译码器**是**灭灯**的

###### 48 集成译码器（显示）

![|550](imgs/Pasted%20image%2020250514192423.png)

48 的输出端高电平有效，需要与共阴极数码管配合才行

![|525](imgs/Pasted%20image%2020250514192757.png)

这里需要注意的是最后一个控制端：（ $\overline{BI / RBO}$ ），这个是既可以当作输入，也可以当作输出。

本质上在后面的功能表上有说明，当其他的输入都无效的时候，这个时候的 $\overline{BI/RBO}$ 是当作输入来用的，输入为 $0$

![|675](imgs/Pasted%20image%2020250514193410.png)

此外，当 $\overline{RBI}$ 和 $A_{3}$ 、 $A_{2}$ 、 $A_{1}$ 、 $A_{0}$ 输入都为 0 的时候，才控制为**消隐**（**灭零**）

下面这种接法是一种常规接法：

![|525](imgs/Pasted%20image%2020250514193658.png)

下面是多位的显示译码器连接到一起实现**多位数码管的动态灭零连接电路**

![|625](imgs/Pasted%20image%2020250514194736.png)

其中，整数部分：高位的 $\overline{BI/RBO}$ 和低位的 $\overline{RBI}$ 相连

小数部分：地位的 $\overline{BI/RBO}$ 与高位的 $\overline{RBI}$ 相连

###### COMS 4511 集成译码器

其输出端高电平有效，需要与**共阴极数码管**配合

![|500](imgs/Pasted%20image%2020250514202512.png)

下面是逻辑图：

![|525](imgs/Pasted%20image%2020250514202644.png)

相对于原来的 48 译码器，其在无效码的时候也是消隐的。

并且在控制端都为高电平的时候，能够将上一次的输入进行**锁存**

![|525](imgs/Pasted%20image%2020250514202957.png)

在锁存之后，无论再输入什么都是被锁住的哪个数

### 数据选择器

数据选择器：根据地址信号的要求，从多路输入数据中选择其中一路输出的逻辑电路。又称为多路选择器（Multiplexer，简称为 MUX）或者多路开关


![|550](imgs/Pasted%20image%2020250514203501.png)

数据选择器的输入信号个数 $N$ 与地址码个数 $n$ 的关系为 $N=2 n$

常用 2 选 1、4 选 1、8 选 1 和 16 选 1 等数据选择器。

![|525](imgs/Pasted%20image%2020250831142805.png)

其中二选一以及四选一的类似电路图如上面图中所示。

最常见的方法就是使用**与或式**

 #### 4 选 1 数据选择器（153）

下面以做题的形式来实现数据选择器

![|475](imgs/Pasted%20image%2020250516170534.png)

题意可知，数据选择器有 $4$ 个数据输入端， $1$ 个输出端。数据输入端分别用 $(D_0)$ 、 $(D_1)$ 、 $(D_2)$ 、 $(D_3)$ 表示，有数据输入时，用 $1$ 表示，任意值用 $(\times)$ 表示。地址输入端用 $(A_0)$ 和 $(A_1)$ 表示。使能控制端用 $(\overline{ST})$ 表示。

![|500](imgs/Pasted%20image%2020250516171157.png)

逻辑表达式为：

$$
\begin{align*}
Y = (D_0 \overline{A_1}\cdot \overline{ A_0} + D_1 \overline{A_1} A_0 + D_2 A_1 \overline{A_0} + D_3 A_1 A_0) \overline{\overline{ST}}
\end{align*}
$$
然后是画出电路逻辑图

 ![|500](imgs/Pasted%20image%2020250516171924.png)

下面的集成电路为：

**74 LS 153**，当然这个数据选择器是一个双路的，也就是上面有**两个 4 选 1 数据选择器**，而他们的地址段是**通用**的

![|575](imgs/Pasted%20image%2020250516172126.png)

功能表如下：

![|550](imgs/Pasted%20image%2020250516172338.png)

![|500](imgs/Pasted%20image%2020250516172801.png)

在这个地方可以看出来数据选择器又称为是**最小项输出器**

> [!note]
> 令数据 $D_{0}\sim D_{3}$ 有些为 $0$ ，有些为 $1$ ，或者为其他变量，可以构造不同的逻辑函数

#### 8 选 1 数据选择器（151）

![|525](imgs/Pasted%20image%2020250516173124.png)

下面是功能表：

![|475](imgs/Pasted%20image%2020250516173533.png)

然后是真值表：

![|525](imgs/Pasted%20image%2020250516173558.png)

下面是输出表达式：

$$
\begin{aligned}
{Y} &= D_0 \overline{A_2} \overline{A_1} \overline{A_0} + D_1 \overline{A_2} \overline{A_1} A_0 \\
&+ D_2 \overline{A_2} A_1 \overline{A_0} + D_{3}\overline{A_{2}} A_{1}A_{0} + D_{4}A_{2}\overline{A_{1}}\overline{A_{0}} + D_{5}A_{2}\overline{A_{1}}A_{0}
 \\
 &+ D_{6} A_{2}A_{1}\overline{A_{0}} + D_{7}A_{2}A_{1}A_{0}\\
 & = D_{0}m_{0} + D_{1}m_{1}+D_{2}m_{2}+D_{3}m_{3} + D_{4}m_{4}+D_{5}m_{5}+D_{6}m_{6}+D_{7}m_{7}

\end{aligned}
$$

令数据 $D_0 \sim D_1$ 有些为 $0$ ，有些为 $1$ ，或为其它变量，可构造不同的**逻辑函数**。

#### 数据选择器的扩展 - 双 4 选 1 连接成 8 选 1

将双 4 选 1 数据选择器 74 LS 153 连接成 8 选 1 数据选择器

![|525](imgs/Pasted%20image%2020250516180129.png)

#### 数据选择器的扩展 - 两个 8 选 1 连接成 16 选 1

![|550](imgs/Pasted%20image%2020250516181534.png)

对上面的这个同样按照之前的方法来进行连接，其结果如上图

#### 数据选择器的应用

##### 实现逻辑函数

比如，要实现 $L = \overline{A}B + A\overline{C}$ ，这个是个三变量的

解决方案是将其首先写成**最小项**的形式

其方法就是**缺哪一项，就补哪一项**

$$
L = \overline{A}B + A\overline{C} = \overline{A}B C + \overline{A} B \overline{C} + A B \overline{C} + A \overline{B} \cdot  \overline{C}
$$
得到：

$$
m_{2} + m_{3}+m_{4} +  m_{6}
$$
然后，相应的数据输入端上设置为 $1$ ，没有出现的，设置为 $0$

![|425](imgs/Pasted%20image%2020250831151939.png)

关键是下面这个当有四个变量的时候。再如何逻辑函数的表达。

$$
L = AB\overline{C} + BC\overline{D} + \overline{A}BD + A\overline{B}\cdot \overline{C}
$$

如果还是使用上面的三变量的数据选择器，那么就需要将一个变量利用使能端进行区分。

那么首先就是将其中的一个变量提取出来，实现对使能端的控制。

$$
\begin{aligned}
L &=  AB\overline{C} + BC\overline{D} + \overline{A}BD + A\overline{B}\cdot \overline{C}\\
& = AB\overline{C} + (A  + \overline{A})BC\overline{D} + \overline{A}B(C + \overline{C})\overline{D} + A\overline{B}\cdot \overline{C}\\
& = AB\overline{C}  + \overline{A}BC\overline{D} + \overline{A}BC\overline{D} + \overline{A}BC\overline{D} + \overline{A}B\overline{C}\cdot \overline{D} + A\overline{B}\cdot \overline{C}\\
& = \overline{A}\cdot \overline{B}\cdot \overline{C}\cdot() + \overline{A}\cdot \overline{B}C \cdot() + \overline{A}B\overline{C}\cdot() + \cdots + ABC\cdot()
\end{aligned}
$$
由于是将 $ABC$ 这三个变量当作**最小项**

接下来将上面得到的式子中的括号填好即可。括号内的情况只有四种： $0$ 、 $1$ 、 $D$ 、 $\overline{D}$

举个例子：比如说 $\overline{A}BC\overline{D}$ ，由于原式中有这一项，那么在进行填空的时候，就需要填 $\overline{D}$ ，那么在实际接线的时候，接的就是 $\overline{D}$ 。

> [!note]
> 原理是用最小项的性质：
> 
> 当一个逻辑函数可以写成最小项的形式，那么当输入与其中一个最小项相同的时候，那么输出只能是这个最小项。

相对来说，比较常见的是使用**四选一数据选择器**：

当然，分析方法是不变的，主要还是先将其换成以 $AC$ 为最小项的形式：

![|575](imgs/Pasted%20image%2020250831193029.png)

$$
\begin{aligned}
L &= \overline{A}BC + A\overline{C}\cdot \overline{D} + B\overline{C}D\\
& = \overline{A }BC  + A\overline{C}\cdot \overline{D} + B\overline{C}D\cdot( A + \overline{A})\\
& = \overline{A }BC  + A\overline{C}\cdot \overline{D} + A B\overline{C}D + \overline{A}B\overline{C}D\\
& = \overline{A}\cdot \overline{C}(BD) + \overline{A}C(B) + A\overline{C}(B+\overline{D}) + AC(0)
 \end{aligned}
$$
分析方法其实没有什么本质上的区别。

主要是将其中一部分出现的比较多的部分换成最小项的形式

上面是使用的是 $AC$ ，当然也是可以使用 $BC$ 、 $AD$

还可以使用**卡诺图**的方法来实现。

![|400](imgs/Pasted%20image%2020250831195148.png)

首先将原逻辑表达式画成卡诺图的形式。

然后如果使用 $AB$ 作为最小项。则**每一行**就对应着每一个**数据输入端**

如果使用 $CD$ ，那么**每一列**就对应着一个**数据输入端**

![|475](imgs/Pasted%20image%2020250831200444.png)

当然，还是要按照卡诺图化简的方法将每一行或者每一列**圈出来的**，当然，读取的时候也是按照正常的卡努图来读的。

下面是对应另外一个例子：

以 $AB$ 为数据选择端

![|500](imgs/Pasted%20image%2020250922214214.png)

以 $CD$ 为数据选择端

![|500](imgs/Pasted%20image%2020250901165900.png)

显然以 $CD$ 为数据选择端刚简单一点。

****

当然，也可以使用 $AC$ 作为**数据选择端**（**最小项**）

不利于理解。

![|475](imgs/Pasted%20image%2020250831200826.png)

****

当然，包括 $\overline{AB}$ 、 $\overline{A+B}$ 在内的各种逻辑表达式，都可以使用 4 选 1 数据选择器来实现。

![|325](imgs/Pasted%20image%2020250831201027.png)

##### 将 4 选 1 扩展到 16 选 1

很明显，16 选 1 至少要使用 4 个 4 选 1 来实现。

实际上，普通的要用 5 个 4 选 1 来实现。

![|500](imgs/Pasted%20image%2020250831201423.png)

这里的数据选择端上，低位的四个 4 选 1 的数据选择端用**低位**来连接，高位的哪一个 4 选 1 数据选择端用**高位**来连接，如上面图中所示。

当然，除了上面这种使用 5 个 4 选 1 数据选择器。也可以使用**控制使能端**的方法来实现对输出结果的控制。

还是假设输入的是 $1101$ ，那么 $AB$ 的值是 $11$ ，而 $AB$ 的取值一共有 4 种情况。分别是 $00、01、10、11$ ，那么就可以使用使用一个 2 - 4 的译码器，分别来控制四个 4 选 1 的数据选择器的使能端。同样可以得到相同的结果。

##### 并行输入串行输出

其主要实现的东西是：将一组二进制数，按照想要的顺序（CBA 不同波形组合）输出出去。

> [!important]
> 注意高位、低位的顺序。在这里 $A$ 是高位。 $C$ 是低位

![|425](imgs/Pasted%20image%2020250901163822.png)

这里就是实现了**数据的串行、并行转换**


### 数据分配器

> [!note]
> 根据地址信号的要求，将一路输入数据分配到多路输出中的其中一路作为输出的逻辑电路，称为数据分配器（Demultiplexer），简称为 DMUX

这个刚好跟数据选择器是一个**镜像**（这个是一个输入，四个输出）

![|500](imgs/Pasted%20image%2020250518161304.png)

在上面真值表中，使用的是 $D$ ，而不是 $1$ 或者 $0$ ，原因在于其取值是根据 $D$ 的取值来的。

下面是其集成芯片，但是需要注意的是，数据分配器是**没有相应的芯片**的，而是用功能差不多的**译码器**实现的，将译码器的一些端进行处理一下就得到了**数据选择器

3 线-8 线译码器 74 LS 138 可以构成 1 路- 8 路数据分配器。 $A_2$ 、 $A_1$ ， $A_0$ 为地址信号输入端， $\overline{Y_0 }\sim \overline{Y_7}$ 为数据输出端，三个使能 $\overline{ST_A}$ 、 $\overline{ST_B}$ 、 $\overline{ST_C}$ 中的任一个都可作数据 $D$ 输入端。

而可以得到有两种接法：

下面这个是**第一个**：

![](imgs/Pasted%20image%2020250518162213.png)

然后是**第二个**：

![|425](imgs/Pasted%20image%2020250518162421.png)

### 用中规模集成电路实现组合逻辑函数

主要是用**二进制译码器**实现组合逻辑电路，以及用**数据选择器**实现组合逻辑电路

首先要理解什么是电路实现：

用一个例子来说明：

引例：使用合适的逻辑电路实现函数 $F = AB + BC + AC$ 。

![|475](imgs/Pasted%20image%2020250518162825.png)

首先是**不对逻辑函数进行变换**，其需要用三个与门和一个三输出的或门

那么，如果要对**逻辑函数进行变换**

将原函数进行两次取反，可以得到：

$$
\begin{align*}
Y &= AB + BC + AC\\
& = \overline{\overline{AB + BC + AC}} \\
& = \overline{AB \cdot BC \cdot AC}
\end{align*}
$$
这样得到的输入只需要用到 3 个两输入端与非门，以及 1 个三输入与非门

下面是它的电路实现：

![|500](imgs/Pasted%20image%2020250518172521.png)

当然，除了上面的普通与非门，也可以用**二进制译码器**来实现

所以，问题就在于如何使用这些译码器、数据选择器来实现上面说到的功能

> [!note]
> 如果要选用“**二进制译码器**”或者“**数据选择器**”，其实就是要确定“二进制译码器”或“数据选择器”**输入端**与**待求函数输入信号** $A、B、C$ ，输出端与输出信号 $Y$ 之间的**连接关系**，也就是求之间的**逻辑**


#### 二进制译码器实现组合逻辑函数

> [!note]
> 其本质上是：
> 
> 
> 由于 $n$ 位二进制译码器可提供 $2^{n}$ 个最小项的输出，而任一个逻辑函数都可变换为最小项之和的**标准与或式**，因此利用译码器和门电路可实现单输出及多输出组合逻辑电路。

> [!important]
> 当译码器输出**低电平有效**的时候，选用**与非门**
> 
> 当译码器输出**高电平有效**的时候，选用**或门**

下面是**基本步骤**：

1. 选择集成二进制译码器（不一定是 138）
   
2. 写出待求函数的**标准与非-与非式**（两次取反）

3. 确定待求函数变量和译码器**输入端**之间的关系

4. 选择合适的门电路，画出连线图

下面通过例题来说明如何实现：

![|425](imgs/Pasted%20image%2020250521150317.png)

注意看，上面的这个表达式不是最简单的，其可以换成 $Y = AB + C$

但是我们不需要换，因为在于我们还要**二次取反**，所以并不需要化简。

下面是正式的步骤：

首先，要根据逻辑函数选择**译码器**

很明显，有三个输入，所以要选择 **3 线-8 线译码器**（138）

然后，就是将函数式换成**标准的与或式**

$$
\begin{align}
F &= \overline{A}\overline{B}C + AB\overline{C} + C(\overline{A} + A)(\overline{B} + B) \\
&= \overline{A}\overline{B}C + AB\overline{C} + \overline{A}BC + A\overline{B}C + ABC \\
& = m_1 + m_3 + m_5 + m_6 + m_7
\end{align}
$$

除了上面这种直接写出标准与或式的方法，还可以利用卡诺图来实现：

![|525](imgs/Pasted%20image%2020250521175524.png)

然后进行两次取反，得到**标准的与非表达式**：

$$
\begin{align*}
F &= m_1 + m_3 + m_5 + m_6 + m_7\\
& = \overline{\overline{m_{1}}\cdot \overline{m_{3}}\cdot \overline{m_{5}}\cdot \overline{m_{6}}\cdot \overline{m_{7}}}
\end{align*}
$$
（上面是以 $A、B、C$ 作为**变量** ）

然后是**待求函数变量和译码器输入端之间**的关系：

138 是输出**低电平有效**， $\overline{Y_{i}} = \overline{m_{i}}$ ，（以 $A_{2}、A_{1}、A_{0}$ 作为**变量** ）

回顾一下功能表：

![|550](imgs/Pasted%20image%2020250521175757.png)

我们在上面已经知道了 $F$ 

$$
\begin{align*}
F &= m_1 + m_3 + m_5 + m_6 + m_7\\
& = \overline{\overline{m_{1}}\cdot \overline{m_{3}}\cdot \overline{m_{5}}\cdot \overline{m_{6}}\cdot \overline{m_{7}}}
\end{align*}
$$
**然后令 $A_{2} = A$ ， $A_{1} = B$ ， $A_{0} = C$ ，那么就可以得到**：

$$
F = \overline{ \overline{ Y_{1}}\cdot \overline{Y_{3}}\cdot \overline{Y_{5}}\cdot \overline{Y_{6}}\cdot \overline{Y_{7}}}
$$
这样就找到了 $F$ 跟 $Y$ 之间的关系

而得到的结果中的 $\overline{Y_{1}}、\overline{Y_{3}}、\cdots、\overline{Y_{7}}$ 就是 138 的输出，而最后的结果就是将其**与非**到一起即可。

![|575](imgs/Pasted%20image%2020250521181029.png)

上面的图，就是**最后的连线结果**

再来一个例题：

![|525](imgs/Pasted%20image%2020250521193027.png)

用**卡诺图**写出输出逻辑函数的**最小项表达式**

$$
\begin{cases}
F_1 = \overline{A}\overline{B}C + A\overline{B}C + ABC = m_1 + m_5 + m_7 \\
F_2 = \overline{A}\overline{B}C + \overline{A}BC + A\overline{B}\overline{C} + ABC = m_1 + m_3 + m_4 + m_7 \\
F_3 = \overline{A}\overline{B}\overline{C} + A\overline{B}\overline{C} + AB\overline{C} = m_0 + m_4 + m_6
\end{cases}
$$

然后换成**与非表达式**：

$$
\begin{align*}
\begin{cases}
F_1 = \overline{\overline{m_1} \cdot \overline{m_5} \cdot \overline{m_7}} \\
F_2 = \overline{\overline{m_1} \cdot \overline{m_3} \cdot \overline{m_4}\cdot \overline{m_{7}} }\\
F_3 = \overline{\overline{m_0} \cdot \overline{m_4} \cdot \overline{m_6}}
\end{cases}
\end{align*}
$$
然后则是令 $A_{2} = A$ ， $A_{1}= B$ ， $A_{0} = C$ ，将函数式变换为：

> [!important]
> 这里需要注意，在变换变量的时候，要注意其之间的对应关系，通常是要**反过来取值**的
> 
> 在这里， $A_{2}$ 是高位
> 
> **此处需要额外注意**

$$
\begin{align*}
\begin{cases}
F_1 = \overline{\overline{m_1} \cdot \overline{m_5} \cdot \overline{m_7}}  = \overline{\overline{Y_{1}}\cdot \overline{Y_{2}}\cdot \overline{Y_{7}}}\\
F_2 = \overline{\overline{m_1} \cdot \overline{m_3} \cdot \overline{m_4}\cdot \overline{m_{7}} } = \overline{\overline{Y_{1}}\cdot \overline{Y_{3}}\cdot \overline{Y_{4}}\cdot\overline{Y_{7}}}\\
F_3 = \overline{\overline{m_0} \cdot \overline{m_4} \cdot \overline{m_6}} = \overline{\overline{Y_{0}}\cdot \overline{Y_{4}}\cdot \overline{Y_{6}}}
\end{cases}
\end{align*}
$$
然后就是画出**逻辑图**：

![|475](imgs/Pasted%20image%2020250521194230.png)

再来一个例三：

![|450](imgs/Pasted%20image%2020250521194259.png)

这个跟之前的题目是刚好反过来的。

**解决方法是：**

直接根据设计步骤，使用卡诺图求解：

直接看有几个输出的 $\overline{Y_{i}}$ ，将其对应的 $1$ 写到卡诺图上

观察上面的图中是 $(0,1,2,4,6)$ ，所以在卡诺图上对应的位置上写上 $1$

然后是根据卡诺图来进行化简结果

> [!important]
> 注意，在画卡诺图的时候，不能写反，在 138 上，是 $A_{2}$ 是高位， $A_{0}$ 是低位，相应的在卡诺图上**左边的是高位**，**右边依次是低位**，一定要注意**顺序**

![|525](imgs/Pasted%20image%2020250521203659.png)

#### 数据选择器实现组合逻辑电路

首先来回顾一下，数据选择器的输出是**标准与或式**，其中包含地址变量的**全部最小项**

![|550](imgs/Pasted%20image%2020250522155830.png)

基本步骤：

1. 根据 $n = k-1$ 或 $n = k$ 来确定数据选择器的型号；当然，在这里的 $n$ 是**选择器地址输入端的个数**， $k$ 是**函数的变量个数**。（为什么会有 $n=k-1$ ，是因为这个是一种比较复杂的解决方法，用的是**降维的方法** ）

2. 然后是写出函数的**标准与或式**和选择器的**输出信号表达式**

3. 对这两个表达式进行比较（卡诺图），确定选择器**各个输入变量的表达式**
   （选择器输入端跟待求函数的输入变量之间是如何连接的，以及数据选择器的输出端与待求函数的输出之间的连接关系）

4. 完成之后，根据采用的数据选择器和求出的表达式画出**连线图** 

##### 不降维的解法

下面使用一个比较简单的例题来说明：

![|500](imgs/Pasted%20image%2020250522160726.png)

首先是**代数法来求解**：

![|525](imgs/Pasted%20image%2020250522165131.png)

写出最小项表达式为：

$$
Y = AB + BC + AC = \overline{A}BC + A \overline{B} C + AB\overline{C} + ABC = m_{3}+m_{5}+m_{6}+m_{7}
$$

然后再写出**数据选择器（8 选 1）的输出表达式**，在上图中。

然后将待求函数的表达式与数据选择器的表达式进行比较：

当然，在此之前，需要先令 $A_{2} = A$ ， $A_{1} = B$ ， $A_{0} =C$

可以得到：

$$
\begin{aligned}
Y &= D_{0}\overline{A}\cdot \overline{B}\cdot \overline{C} + D_{1} \overline{A}\cdot \overline{B}\cdot C + D_{2} \overline{A}B\overline{C} + D_{3}\overline{A}BC\\
& + D_{4}A\overline{B}\cdot\overline{C} + D_{5}A\overline{B}C + D_{6}AB\overline{C} + D_{7}ABC
\end{aligned}
$$
通过**对比**可以得到：

![|500](imgs/Pasted%20image%2020250522165836.png)

得到：

$$
\begin{align*}
\begin{cases}
D_0 = D_1 = D_2 = D_4 = 0 \\
D_3 = D_5 = D_6 = D_7 = 1
\end{cases}
\end{align*}
$$
这样就得到了数据选择部分的取值，最后是画图

![|450](imgs/Pasted%20image%2020250522170153.png)

接下来是**用卡诺图来求解**

![|500](imgs/Pasted%20image%2020250522170414.png)

用卡诺图的方法要更简单一些

关键点在于要画对 $F$ 的卡诺图，然后则是 $Y$ 卡诺图的顺序要正确，记住 $A$ 和 $A_{2}$ 都是**高位**即可

然后一一对应就可以得到结果。

****

##### 降维的解法

> [!important]
> 降维是要降掉**最低位**

下面是需要**降维**的使用数据选择器

![|550](imgs/Pasted%20image%2020250522171153.png)

> [!note]
> 其实上就是用 4 选 1（153）来实现三变量的函数表达式。
> 
> 因为 4 选 1 **只有两位地址输入端**
> 
> 也就是 $n = k-1$ 的时候

当然，求解方法其实没有什么很大的不同，关键点在于降维的那部分

依然是写出函数的**标准与或式**：

$$
F = \overline{A}BC + A \overline{B}C + AB\overline{C} + ABC
$$

当然，还有 4 选 1 **数据选择器的表达式**：

$$
Y = D_{0} \overline{A_{1}}\cdot \overline{A_{0}} + D_{1} \overline{A_{1}}A_{0} + D_{2}A_{1}\overline{A_{0}} + D_{3}A_{1}A_{0}
$$
很明显，现在不够用，所以下面的部分就是重点：

要确定**输入变量和地址码之间的关系**：

方法 1 就是**公式拼凑法**

首先要做的是找到对应关系：

令 $A_{1} = A$ ， $A_{0} = B$ ，得到 $Y$ 

$$
Y = D_{0} \overline{A}\cdot \overline{B} + D_{1}\overline{A}B + D_{2}A\overline{B} + D_{3}AB
$$

然后换一下**位置**得到：

$$
Y = \overline{A}\cdot \overline{B}D_{0}+\overline{A}BD_{1}+A\overline{B}D_{2}+ABD_{3}
$$
我们的目的是对应 $Y=F$

可以得到， $D_{0} = 0$ ， $D_{1} =C$ ， $D_{2}=C$ ， $D_{3} = \overline{C} + C =1$


![|550](imgs/Pasted%20image%2020250522180937.png)

然后接下来就是画图：

![|425](imgs/Pasted%20image%2020250522181201.png)

这个方法有一定的局限性，当变量比较多的时候，可能会拼凑错，下面的方法是**图形法**（卡诺图）

方法：

> [!important]
> 先画出待求函数的**降维卡诺图**，再画出相应**数据选择器输出信号的卡诺图**，利用**两者相等**的关系，求出数据选择器**输入变量的表达式**

> [!note]
> 一般将卡诺图的**变量数**称为该图的**维数**，如果把某些变量也作为卡诺图中小方格的值，则会减少卡诺图的维数，这种卡诺图称为“**降维卡诺图**”

下面就是降维的具体操作：

![|525](imgs/Pasted%20image%2020250522182726.png)

当然，上面包含 $C$ 的是包含的原变量，如果当 $C = 0$ ， $F = 1$ ， $C = 1$ ， $F=0$ 的时候，结果就是 $F = \overline{C}$

下面就是来**对比 $F$ 的降维卡诺图和数据选择器输出 $Y$ 的卡诺图**

当然，需要注意的还是 $A = A_{1}$ ， $B = A_{0}$ ，高低位对应

![|550](imgs/Pasted%20image%2020250522183157.png)

除了上面的这种方法，还有更快的方法：

就是“**降维真值表**”的方法

首先就是先将待求函数**转换成最小项之和的形式**

$$
 F = AB + BC + AC = \sum m(3,5,6,7)
$$
![|500](imgs/Pasted%20image%2020250522183746.png)

下面开始列表，根据上面图中所示的表一样。

> [!note]
> 如果**降维变量**在其他变量取值情况**唯一**的时候 （比如 $A = 1、B=0$ 在表中只出现了一次 ），降维变量的取值为 $1$ ，则降维卡诺图中的填降维变量，降维变量的取值为 $0$ ，则填降维变量的**反变量**
> 
> 如果降维变量在其他变量取值情况**不唯一**（不唯一一般为**两次**）的时候（比如 $A = 0、B = 1$ 在表中出现了两次 ），**降维变量**直接为 $1$

> [!note]
> 写出降维真值表之后，紧接着就是画出**降维卡诺图**，如果降维真值表没有出现卡诺图中相应的取值，则直接写 $0$ ，比如在上面的将为真值表中没有出现 $A = 0$ ， $B = 0$ 的情况，则在画降维卡诺图的时候对应位置直接写 $0$

> [!note]
> 得到降维卡诺图之后，则是需要将其与数据选择器的卡诺图进行比较，从而得到最后的连线方式

****

下面用一个变量数比较多的情况来展示：

![|525](imgs/Pasted%20image%2020250522184521.png)

![|525](imgs/Pasted%20image%2020250522185132.png)

然后是对比 151 的卡诺图

![|525](imgs/Pasted%20image%2020250522185357.png)

最后就是画出连线图：

![|525](imgs/Pasted%20image%2020250522185431.png)
