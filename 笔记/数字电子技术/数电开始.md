---
tags:
comment: true
---
# 一些注意事项

译码器（类似于 138）可以实现多种**逻辑函数**功能。而数据选择器基本上只能实现一种**逻辑函数**


# 第一章与第二章 - 概论与逻辑代数

## 数电模电的区别

首先是电子电路分类：

1. 模拟电路
2. 数字电路

模拟信号是在时间上和幅度上都**连续变换**的信号

数字信号是在时间上和幅度上都**断续变化**的信号

模拟电路研究的是输出与输入信号之间的大小、相位、失真等方面的关系；

数字电路研究的是输出与输入间的逻辑关系（因果关系）

数字电路中的**三极管工作**在饱和或者截止状态，**起开关作用**

![|425](imgs/Pasted%20image%2020250411174925.png)

## 描述方法

**二值数字逻辑和逻辑电平**

![|425](imgs/Pasted%20image%2020250411175100.png)

**逻辑代数**

用于描述客观事物逻辑关系的工具。

**逻辑体制**

正逻辑体制：规定高电平为逻辑 1，低电平为逻辑 0

负逻辑体制：规定高电平为逻辑 0，低电平为逻辑 1

通常，如没有加说明，一般以正逻辑来处理

## 数制

### 十进制（Decimal）

不过多描述，就是基本十进制，不过要注意的是下标除了用 $10$ 来表示，还可能用 $D$ 来表示。

数码所处的**位置不同**，所代表的数值不同。

![|375](imgs/Pasted%20image%2020250411175727.png)

$10^{i}$ 称为十进制的权， $10$ 称为基数， $0\sim 9$ 十个数码称为系数。

**数码与权的乘积，称为加权系数**

十进制数可以表示为各位加权系数之和，称为**按权展开式**

$$
(385.64)_{10} = 3\times 10^{2} + 8 \times 10^{1} + 5\times 10^{0} + 6\times 10^{-1} + 4\times 10^{-2}
$$
### 二进制（Binary）

跟十进制类似，表示方式是右下角标识 $2$ 或者 $B$ ，如： $(1011.11)_{2}$ 、 $(1011.11)_{B}$

二进制的数码： $0$ 、 $1$ ，**权**： $2^{i}$ ，基数： $2$

进位规律：逢二进一

将按位权展开式按照**十进制规律**相加，即得到**对应的十进制数**，例如：

$$
\begin{aligned}
(1011.11)_{2} &= 1\times 2^{3}  + 0\times 2^{2} + 1\times 2^{1} + 1\times 2^{0 } + 1\times 2^{-1} + 1\times 2^{-2}\\
& = 8 + 0 + 2 + 1 + 0.5 + 0.25\\
& = 11.75
\end{aligned}
$$

### 八进制（Octal）

表示方法为 $(XXX)_{8}$ 或者 $(XXX)_{O}$

数码是从 $o\sim 7$ ，**权**是 $8^{i}$ ，基数是 $8$

进位规律是**逢 8 进 1**

将按位权展开相加，即可以得到对应的**十进制数**

$$
(573.46)_{8}  = 5 \times 8^{2} + 7\times 8^{1} + 3\times 8^{0} + 4\times 8^{-1} + 6\times 8^{-2}
$$
### 十六进制（Hexadecimal）

$H$ 作为其下标，或者 $16$ 作为其下标。

数码从 $0\sim 9$ ，以及 $A(10),B(11),C(12),D(13),E(14),F(15)$

**权**是 $16^{i}$ ，基数是 $16$ ，进位规律是**逢 16 进 1**

**这里的加减法不太好算**

同样的，这个也可以按位权展开相加，即得到对应的十进制数。

$$
(5EC.D4)_{16} = 5\times 16^{2} + 14 \times 16^{1} + 12 \times 16^{0} + 13\times 16^{-1} + 4\times 16^{-2}
$$
### 不同进制之间的相互转换

#### 转换为十进制

主要**方法**就是**按位权展开再求和**，上面例子中有说明

#### 十进制到其他进制

> [!note]
> 这部分的方法是：
> 
> 整数部分采用：**除基取余法**
> 
> 
> 小数部分采用：**乘基取整法**

如何理解，其实不难。

如果是转换成二进制，就将十进制**整数部分**除以二（**短除法**），八进制就是整数部分除以八，十六进制就是整数部分除以十六。当然，除完之后，还要取余数。

而小数部分就是成以基数，再取整。

例如：将 $(36.375)_{10}$ 转换为二进制。

![|275](imgs/Pasted%20image%2020250412162010.png)

按照上面的除法一直向下除下去，每一次都能得到一个余数，直到商为 0 为止。

而读取的时候，要**从下面往上面读**。

![|525](imgs/Pasted%20image%2020250412162226.png)

然后是计算小数部分。

小数部分则是将十进制小数部分的数字拿过来，乘以 $2$ ，然后将得到的整数部分拿过来。**注意，无论得到的整数部分是 $0$ 还是 $1$ ，都要拿出来。**

![|250](imgs/Pasted%20image%2020250412162424.png)

但是，这里有一点需要注意，也是经常会错的地方。

注意看第二次乘以 $2$ ， $0.75\times 2 = 1.5$ ，这里要把整数部分**拿出来**。而拿出来之后，**剩下的部分**再进行乘 $2$ 。 $1.5$ 把 $1$ 拿出来之后就只剩下 $0.5$ 了，所以后面再乘以 2 的部分是 $0.5$

直到最后得到的是 $0$ 乘以 $2$ 。当然，也有可能永远也得不到 $0$ ，那么只需要保留上几位小数即可。（注意看上图中的最后一次乘 $2$ ， $0.5\times 2 = 1$ ，而这里还是要把 $1$ 拿出来，最后剩下一个 $0$ 才算结束 ）

而读取的顺序则是和**整数部分**正好**相反**。

**整数部分是从下往上读，而小数部分则是从上往下读**。

下面是这个例题：

![|650](imgs/Pasted%20image%2020250412163304.png)

其他进制也是一样的方法，就是**基**变了而已。

#### 二进制与八\十六进制快速转换

首先是二进制、八进制和十六进制之间的相互对照表。

![|275](imgs/Pasted%20image%2020250412163818.png)

根据相互对照表，可以得到：**一位八进制数需要 3 位二进制数来表示**

下面是全部的对照：

![|450](imgs/Pasted%20image%2020250412164513.png)

可以得到：**1 位十六进制数需要用 4 位二进制数来表示**

##### 二进制与八进制

二进制到八进制：

> [!note]
> 
> 从小数点开始，整数部分向左、小数部分向右**三位一组**，不足三位的加 $0$ 补足（两边）三位，再按照顺序写出各组对应的**八进制数**

例如：

$$
(11100101.11101011)_{2} = ()_{8}
$$
整数部分和小数部分分别按照上面的方法，三位一组划分开来，得到：

![|550](imgs/Pasted%20image%2020250412165113.png)

由于是转换到八进制上，所以是**三个一组**，而根据对应表（421）的方法就可以得到八进制数是多少。

八进制到二进制：

> [!note]
> **将每位八进制数用三位二进制数代替，再按照原来的顺序排序。**

例如：

$$
(745.361)_{8} = (111100101.011110001)_{2}
$$
##### 二进制与十六进制

注意，一位十六进制数对应 4 位二进制数，因此二进制数 4 位为一组。

二进制到十六进制：

> [!note]
> 从小数点开始，整数部分向左、小数部分向右**四位一组**，不足四位的加 $0$ 补齐四位，再按照顺序写出各组对应的十六进制数。

例如：

![](imgs/Pasted%20image%2020250412165703.png)

十六进制到二进制：

> [!note]
> 每位十六进制数用四位二进制数代替，再按照原顺序排列

例如：

![|525](imgs/Pasted%20image%2020250412172016.png)

#### 八进制与十六进制

这两个之间没有快速转换，只能是利用中间桥梁来实现转换。（比如二进制）

例如：

$$
(653.12)_{8} = (110101011。001010)_{2} = (1AB.28)_{16}
$$
## 码制

### 二进制代码

用数码的特定组合表示特定信息的过程称为**编码**

![|500](imgs/Pasted%20image%2020250412172612.png)

![|475](imgs/Pasted%20image%2020250412172654.png)

### BCD 码（二进制表示十进制）

四位二进制码有十六种组合，表示 $0\sim 9$ 十个数有多种方案，所以 $BCD$ 码有多种

![](imgs/Pasted%20image%2020250412173451.png)

#### 8421 BCD 码

这个是恒权码，取 4 位自然二进制数的前 10 种组合。

这个就是比较常见的哪个 BCD 码

#### 2421 BCD 码和 5421 BCD 码

有权码，从高位到低位的权值分别为 $2、4、2、1$ 和 $5、4、2、1$

#### 余 3 BCD码

这个是**无权码**

无权码表示不能用之前 8421 之类的一样的去乘，没有这样的规律。

**比 8421 BCD 码多余 3 (0011)**

8421 BCD 是从 0000 开始的，而余 3 BCD 码是从 0011 开始的

#### 例题

用 BCD 码来表示十进制数码

$$
(36)_{10} = (00110110)_{8421BCD}
$$
> [!important]
> 注意，转换成 8421 BCD数，每一位都要变换。比如有两位数，那么就是分别对这两位进行变换。

例如下面这个：

$$
(10)_{10} = (00010000)_{8421BCD}
$$
$$
(9)_{10} =(1001)_{8421BCD}
$$
$$
(4.79)_{10} = (0100.01111001)_{8421BCD}
$$
当然，反过来也是很简单的，比如：

$$
(01010000)_{8421BCD} = (50)_{10}
$$

![|500](imgs/Pasted%20image%2020250413153107.png)

### 可靠性代码

#### 格雷码

格雷码（Gray 码，又称为循环码）

最次位（最右边一位）以 $0110$ 为循环节一直循环四次

此低位（右边数第二个）以 $00111100$ 为循环节一直循环两次

第三位 （右边数第三个）以 $0000111111110000$ 为循环节

最高位（右边数第四个）以 $0000000011111111$ 为循环节

![|525](imgs/Pasted%20image%2020250413153940.png)

后面在卡诺图那里会用到，其**特点**是**相邻项之间**只有 **1** 位不同

##### 二进制与格雷码互转

首先是二进制转格雷码

从二进制的左边开始，右边一位与左边的一位进行**异或**，如果不同变成 1，如果相同变成 0；**最高位不变**

直接上例题：

$$
(101110)_{B} \rightarrow (111001)_{G}
$$

然后是格雷码转二进制代码。

这个稍微比较复杂

方法是：高位不变，后面的低位，由前一高位与二进制数中对应位**异或**得来。

比如说，要求二进制中的第二高位，则是由二进制中的第一高位与格雷码中的第二高位**异或**，得到的值就是二进制的第二高位。

直接上例题：

$$
(11010)_{G} = (10011)
$$
图解：

![|350](imgs/Pasted%20image%2020250908141838.png)

#### 奇偶校验码

奇偶校验码由两部分组成：

1. 信息码：需要传送的信息本身
2. 1 位校验码：取值为 $0$ 或者为 $1$ ，以使整个代码中 $1$ 的个数为奇数或者偶数

使 " $1$ "的个数为奇数的称为**奇校验**，使 " $1$ "的个数为偶数的称为**偶校验**

> [!note]
> 举个例子：如果信息码是 $0110$ ，并且使用 8421奇校验码，那么还要再加上一个校验码 $1$ ，原因是信息码 $0110$ 中有两个 $1$ ，是偶数，但是使用的是奇校验，所以要再加上一个 $1$ 。反之，如果还是使用奇校验，且信息码是 $1110$ ，那么校验码就是 $0$ ，因为信息码中 $1$ 的个数已经是奇数了，不需要加上一个校验码凑出奇数来了。

![|500](imgs/Pasted%20image%2020250413154815.png)

## 基本逻辑运算与复合逻辑运算

### 与运算

> [!note]
> 当决定某一件事的所有条件都满足的时候，该事件才会发生。

例子：

![|475](imgs/Pasted%20image%2020250413155157.png)

**记忆：有 0 出 0，全 1 为 1**

其逻辑表达式为：

$$
Y = A \cdot B = AB
$$
当然，还有相对应的电路符号。在下图中。其实就是 c 语言中的 `&`

![|500](imgs/Pasted%20image%2020250413155706.png)

### 或运算

> [!note]
> 当决定某一件事情的诸多条件中，只要有一个或者一个以上的条件具备时，该事件就发生。

![|500](imgs/Pasted%20image%2020250413155849.png)

记忆：有 1 出 1，全 0 出 0

逻辑表达式为：

$$
Y = A + B
$$
电路符号表达在下图中：

![|500](imgs/Pasted%20image%2020250413161358.png)

### 非运算

当决定某件事的条件满足时，事件不发生；反之事件发生。

![|475](imgs/Pasted%20image%2020250413161515.png)

记忆：入 0 出 1，入 1 出 0

逻辑表达式：

$$
A = \overline{A}
$$
电路符号表达在下图中：

![|500](imgs/Pasted%20image%2020250413161644.png)

### 与非运算（NAND）

记忆：有 0 出 1，全 1 出 0

其本质上就是 **先与后非**

逻辑表达式为：

$$
Y = \overline{AB}
$$
电路符号表达在下图中

![|525](imgs/Pasted%20image%2020250413161858.png)

### 或非运算（NOR）

记忆：有 1 出 0 ，全 0 出 1

其本质上是 **先或后非**

逻辑表达式为：

$$
Y = \overline{A+B}
$$
电路符号表达在下图中

![|525](imgs/Pasted%20image%2020250413162013.png)

### 异或运算（Exclusive-OR）

记忆：**相同为 0，不同为 1**

逻辑表达式为：

$$
Y= A \oplus B = \overline{A}B+A\overline{B}
$$
电路符号表达在下图中：

![|525](imgs/Pasted%20image%2020250413162420.png)

> [!note]
> 这里需要注意的是，在电子元器件中，异或运算的输入只有两个，所有如果要设计三变量之间的异或运算，需要组合逻辑电路，在后面会学到。

异或器还能组成**反相器**

$$
1 \oplus A = \overline{A}
$$
$$
0 \oplus A = A
$$

### 同或运算（Exclusive-NOR）

记忆：**相同为 1，不同为 0**

本质上就是异或运算取非运算得到的。

逻辑表达式：

$$
\begin{aligned}
Y &= A \odot B \\
& = \overline{A\oplus B}\\
& = \overline{A}\overline{B} + A B
\end{aligned}
$$

电路符号表达在下图中：

![|525](imgs/Pasted%20image%2020250413163044.png)

### 与或非运算（AND-OR-INVERT）

其本质上是**先与后或再非**

逻辑符号为：

$$
Y = \overline{AB+CD}
$$

![|450](imgs/Pasted%20image%2020250413163247.png)

### 逻辑符号对照

![|475](imgs/Pasted%20image%2020250413163408.png)

## 逻辑代数的基本定律与规则

### 常量之间的运算

与运算、或运算、非运算：

![|450](imgs/Pasted%20image%2020250415153511.png)

### 逻辑变量与常量之间的运算

#### 0-1 律

如果之间是**与运算**，**如果与 1 则是本身，与 0 则是 0**

如果之间是**或运算**，**如果或 1 则是 1，或 0 则是本身**

![|250](imgs/Pasted%20image%2020250415153842.png)

换种记忆方法：

可以将上面的与运算和或运算就当成**乘法和加法**。（除了 $1+A=A$）

> [!note]
> 0 加任何数都是任何数，0 乘任何数都是 0，1 乘任何数都是任何数，当然，1 加 A 是等于 A 的

#### 同一律

这个很好理解：

$$
A +  A = A
$$
$$
A \cdot A = A
$$
将其展开就是 $0\cdot 0 = 0$ ， $1\cdot 1 = 1$ ， $0+0=0$ ， $1+1=1$

#### 互补律

$$
A + \overline{A}  = 1
$$
$$
A\cdot \overline{A} = 0
$$
理解起来也不难，首先是第一个，无论如何，里面肯定有 1，而或运算只要有 1 那就是 1。

第二个，无论如何，里面肯定有 0，而与运算只要有 0 那就是 0。

#### 还原律

$$
\overline{\overline{A}} = A
$$


### 与普通代数类似的定律

#### 交换律

$A+B = B+A$

$A\cdot B =B \cdot A$

#### 结合律

$(A+B)+C = AB+AC$

$(A\cdot B)\cdot C = A\cdot (B \cdot C)$

#### 分配律

$A(B+C) = AB+AC$

$A + BC = (A+B)(A+C)$
$AB +C = (A+C)(B+C)$

特别需要注意的是**第二个**，要把后面**与**的部分拆开。

> [!important]
> 注意，这里一定要**拆开计算**，合起来计算是计算错误的。不能直接先计算 $AB$ 再进行**或运算**

### 摩根定律（反演律）

$$
\overline{(A\cdot B)} = \overline{A} + \overline{B}
$$
$$
\overline{A+B} = \overline{A} \cdot \overline{B}
$$

> [!note]
> 这里的定律一定要记住，这个在后面化简公式的时候经常用

推广公式：

$$
\overline{A\cdot B \cdot C \cdots} = \overline{A}+\overline{B} +\overline{C} + \cdots
$$

$$
\overline{A+B+C\cdots}=\overline{A}\cdot\overline{B}\cdot\overline{C}\cdots
$$
如何正面两个公式相等呢？

第一种方法就是列真值表来对比：

![|450](imgs/Pasted%20image%2020250416191746.png)

第二种就是公式法：

$$
\begin{aligned}
(A+B)(A+C) &= AA + AC +BA + BC\\
& = A + AC + AB + BC\\
& = A(1+C+B) +BC\\
& = A +BC
\end{aligned}
$$

### 逻辑代数的常用公式

#### 吸收律

一、

$$
AB + A\overline{B} = A
$$
解释： $AB + A\overline{B} = A(B+\overline{B}) = A$

二、

$$
A +AB = A
$$
解释： $A+AB= A(1+B) = A$

三、

$$
A + \overline{A}B = A +B
$$
解释：（用的分配律） $A + \overline{A}B = (A+\overline{A})(A+B) = A+B$

记忆的时候，**如果出现一个变量与它的反变量，则直接划去这个反变量就是最后的结果。**

**推广公式：** $\overline{A}+ AB = \overline{A} + B$

#### 冗余律

$$
AB + \overline{A}C + BC = AB + \overline{A}C
$$
这个需要记住的是如何**找到冗余项**，首先找到主变量，就是 $A$ ，其特点是式子中存在其相反变量 $\overline{A}$ ，那么主变量和主变量取反**与**的这两项合起来就是**冗余项**

下面是证明：

$$
\begin{aligned}
AB+\overline{A}C+BC & =AB+AC+BC(A+\overline{A}) \\
 & =AB+\overline{A}C+ABC+\overline{A}BC \\
 & =AB(1+C)+\overline{A}C(1+B) \\
 & =AB+\overline{A}C
\end{aligned}
$$
推广公式：

$$
AB+\overline{A}C+BCD\cdots=AB+\overline{A}C
$$
证明：

$$
\begin{aligned}
AB+\overline{A}C+BCD\cdots & =AB + \overline{A}C + BC + BCD\cdots\\
& = AB + \overline{A}C + BC(1+D\cdots)\\
& = AB + \overline{A}C + BC\\
& = AB + \overline{A}C
\end{aligned}
$$
上面这个其实是原公式中的右边展开了。

#### $\overline{A\overline{B}+\overline{A}B} = \overline{A}\overline{B} + AB$

证明其实也不难：

$$
\begin{aligned}
\overline{A\overline{B}+\overline{A}B}=\overline{A\overline{B}}\cdot\overline{\overline{A}B} & =(\overline{A}+B)(A+\overline{B}) \\
 & =\overline{A}A+\overline{A}\overline{B}+AB+B\overline{B} \\
 & =\overline{A}\cdot\overline{B}+AB
\end{aligned}
$$

其本质是

$$
\overline{A\overline{B}+\overline{A}B} = \overline{A\oplus B}=A\odot B=\overline{A}\overline{B}+AB
$$
下面来一个**推广公式**：

$$
\overline{AB + \overline{A}C} = A\overline{B} + \overline{A}\overline{C}
$$

**上面这个推广公式比较重要，可以记下来**

> [!note]
> 思考：
> 
> 若已知 $A+B = A+C$ ，则 $B\neq C$
> 
> 若已知 $AB= AC$ ，则 $B\neq C$
> 
> ![|425](imgs/Pasted%20image%2020250416204029.png)

#### 关于异或运算的一些公式

**交换律：**

$$
A\oplus B=B\oplus A
$$
**结合律：**

$$
(A\oplus B)\oplus C=A\oplus(B\oplus C)
$$
**分配律：**

$$
A\cdot(B\oplus C)=AB\oplus AC
$$
**常量和变量的异或运算：**

$$
A\oplus\mathbf{1}=\overline{A}\quad A\oplus\mathbf{0}=A\quad A\oplus A=\mathbf{0}\quad A\oplus\overline{A}=\mathbf{1}
$$
异或：相同为 0，不同为 1

同或：相同为 1，不同为 0

**因果互换律：**

如果$A\oplus B=C$ 则有$\left\{\begin{aligned}A\oplus C&=\boldsymbol{B}\\\boldsymbol{B}\oplus\boldsymbol{C}&=\boldsymbol{A}\end{aligned}\right.$

### 逻辑代数的基本规则

#### 代入规则

将逻辑等式两边的某一变量均用同一个逻辑函数替代，等式仍然成立。

例如：

$$
A+\overline{A}B=A+B
$$

将 $A$ 均用 $\overline{A}$ 来代替，则得到： $\overline{A}+AB=\overline{A}+B$

亦或者，将 $B$ 均用 $C$ 来代替，则得到： $A+\overline{A}C=A+C$

再来一个例子：

$$
\overline{A+B}=\overline{A}\cdot\overline{B}
$$
将上面公式中的 $B$ 交均用 $B+C$ 来代替，则得到： $\overline{A+B+C}=\overline{A}\cdot\overline{B+C}$

> [!note]
> 利用代入规则，可以扩展基本定理的应用

#### 反演律

对任一个逻辑函数式 $Y$ ，将式中所有的 “.”换成“+”，“+”换成“.”，“0”换成“1”，“1”换成“0”,，原变量换成反变量，反变量换成原变量，则得到原逻辑函数的反函数 $\overline Y$ 。

> [!important]
> 注意：
> 
> 变换的时候不能改变其**运算顺序**
> 
> 原变量变成反变量，反变量换成原变量只对**单个变量**有效，而对**长非号保持不变**。

例题：

$$
Y_1=A\cdot\overline{B+C}+CD
$$

![|550](imgs/Pasted%20image%2020250416210823.png)

另外一个例题：

$$
Y_2=\overline{\overline{A\overline{B}+C}+D}+E
$$

![|400](imgs/Pasted%20image%2020250416211435.png)

> [!note]
> 求逻辑函数的反函数有两种方法：利用反演规则或者摩根定律来求解。

#### 对偶规则

对任一个逻辑函数式 $Y$ , 将式中所有的“.”换成“+”，“+”换成“.”，“0”换成“1”，“1”换成“0”，则得到原逻辑函数的对偶式 $Y^\prime$ 。

> [!important]
> 变换时需要注意的是：
> 
> 不能改变原来的**运算顺序**
> 
> 变量上的非号**均不改变**

**主要作用是定律扩展**

![|525](imgs/Pasted%20image%2020250416212104.png)

例题：

![|300](imgs/Pasted%20image%2020250416212135.png)

> [!note]
> 利用对偶规则可以将基本公式和定律扩展一倍

## 逻辑函数的表达方法及其转换

### 逻辑函数的建立

下面利用这个例题来：

![|500](imgs/Pasted%20image%2020250416213010.png)


一、分析逻辑问题，建立逻辑函数的真值表

首先要找出**输入变量**和**输出函数**，对它们的取值做出**逻辑规定**，然后根据**逻辑关系**列出真值表。

在上面这个题中：

![|350](imgs/Pasted%20image%2020250416213242.png)

那么真值表就是：

![|175](imgs/Pasted%20image%2020250416213323.png)

很明显上面这个是一个**同或**

二、根据真值表写出逻辑式

$$
Y=AB+\overline{A}\overline{B}=A\odot B=\overline{A\oplus B}
$$

三、分析逻辑式以及画出逻辑图

分析**逻辑式**

![|525](imgs/Pasted%20image%2020250416213624.png)

画**逻辑图**

![|675](imgs/Pasted%20image%2020250416213809.png)

> [!note]
> 设计逻辑电路的基本原则是**使电路最简**


### 逻辑函数的表示

> [!note]
> 
> 逻辑函数是用以描述数字逻辑系统输出与输入变量之间逻辑关系的表达式
> 
> 换成表达式为： $Y = F(A,B,C,\cdots)$

逻辑函数由**与、或、非** 3 种基本逻辑运算构成

![|500](imgs/Pasted%20image%2020250417153757.png)

#### 逻辑表达式

表示输出函数和输入变量逻辑关系的表达式，称为逻辑表达式，简称为逻辑式。

逻辑表达式一般根据真值表、卡诺图或者逻辑图写出。

##### 常见表达形式

![|475](imgs/Pasted%20image%2020250417154223.png)

转换方法 ：

与 - 或表达式到与非 - 与非表达式

> [!note]
> 主要方法是使用**还原律（两次取反）**

例如：

$$
\begin{aligned}
Y &= A\overline{B} + BC\\
& = \overline{\overline{A\overline{B}+BC}}\\
& = \overline{\overline{A\overline{B}}\cdot \overline{BC}}
\end{aligned}
$$
上面第二行用的是**还原律（两次取反）**，第三行用**摩根定律**

#### 逻辑函数的标准表达式（最小项）

这里最主要的问题是**最小项**的问题。

> [!important]
> 最小项的定义：在逻辑函数中，如果一个**与**项（乘积项）包含该逻辑函数的全部变量，且每个变量以原变量或反变量形式只出现一次，则称该**与**项为最小项。对于 $n$ 个变量的逻辑函数共有 $2^{n}$ 个最小项。

![|525](imgs/Pasted%20image%2020250417155504.png)

##### 最小项的基本性质

1. 对于变量的任一组取值，只有一个最小项的值为 1
2. 不同的最小项，使其值为 1 的那组变量取值也不同
3. 对于变量的同一组取值，任意两个最小项**与**的结果为 0
4. 对于变量的同一组取值，任意两个最小项**或**的结果为 1

##### 最小项编号

最小项用 $m_i$ 表示，通常用十进制数作最小项的下标编号 $i$ 。编号方法是：将最小项中的原变量当作 1，反变量当作 0，则得一组**二进制数**，其对应的**十进制数**便为最小项的编号 $i$ 。

![|400](imgs/Pasted%20image%2020250417160005.png)

![|525](imgs/Pasted%20image%2020250417160047.png)

##### 最小项表达式

这个就是**标准与或表达式**

任何逻辑函数都是由其变量的若干个最小项构成的，都可以表示成**最小项之和**的形式

而且这种形式是**唯一的**

> [!note]
> 在与或表达式中，有时与项并不是最小项，可以利用 $\overline{A}+A = 1$ 的形式来补充缺少的变量，将逻辑函数变成最小项之和的形式

例如下面这个：

$$
Y=F(A,B,C)=AB+AC
$$
结果：

$$
\begin{aligned}
\mathrm{Y} & =AB(\overline{C}+C)+\overline{A}C(\overline{B}+B) \\
 & =AB\overline{C}+ABC+\overline{A}\overline{B}C+\overline{A}BC \\
 & =m_1+m_3+m_6+m_7 \\
 & =\sum m(1,3,6,7)
\end{aligned}
$$
#### 真值表

列出输入变量的各种取值组合及其对应输出逻辑函数值的表格称为真值表。

真值表能够直观的反应输出、输入变量的逻辑关系，在分析与设计电路时都要写出真值表。

列出真值表的方法有两种：

1. 按照 $n$ 位二进制数递增的方法列出输入变量的各种取值组合。

2. 分别求出各种组合对应的输出逻辑值填入表格

**知道逻辑函数，求真值表以及结果**

直接上例题：

![|525](imgs/Pasted%20image%2020250417183902.png)

核心在于计算上面的公式中的逻辑运算。

**知道真值表，求逻辑表达式。**

方法如下：

1. 找出函数值为 1 的项。

2. 将输入变量取值为 1 的用原变量代替，取值为 0 的用反变量代替，则得到一系列**与**项。

3. 将这些**与**项相加（相或）就得到逻辑式

例题：

![|525](imgs/Pasted%20image%2020250417184503.png)

#### 逻辑图*

逻辑图是由逻辑符号以及相应连线构成的电路图。

逻辑图一般根据逻辑式画出，将各级逻辑运算用相应的门电路实现

直接上例题：

![|525](imgs/Pasted%20image%2020250417185006.png)

> [!note]
> 画图的时候，要注意美观问题
> 
> 当然，最重要的是，这部分考试会经常考，要多注意

#### 波形图

波形图代表输入变量和对应的输出变量随时间变化的波形。

画波形图的时候需要注意，其横坐标是**时间轴**，纵坐标是**变量取值**，由于变量取值只有 0 和 1，一般在图中不用标出坐标轴，但输入、输出变量要**对应画出**。如下图所示。

![|300](imgs/Pasted%20image%2020250417185329.png)

当然，主要问题是**从波形图到逻辑表达式的转换**是如何的。

![|525](imgs/Pasted%20image%2020250417185541.png)

其次，反过来从逻辑表达式转换到波形图，也是需要解决的问题。

例题：

![|500](imgs/Pasted%20image%2020250417185909.png)

### 逻辑函数的化简

#### 逻辑函数化简的意义与标准

其主要意义在于让逻辑式最简，以便设计出最简的逻辑电路，从而节省元器件、优化生产工艺、降低成本和提高系统可靠性。

直接上例题：

![|475](imgs/Pasted%20image%2020250417191925.png)

很明显，上面的电路比较复杂，所以尽可能的对其进行化简。

直接将公式化简：

$$
Y = AB + A\overline{B} = A(B+\overline{B}) = A
$$

而得到的结果不需要任何门电路。

![|425](imgs/Pasted%20image%2020250417192100.png)

> [!note]
> 不同形式的逻辑式有不同的最简式，一般要先求取**最简与或式**，然后通过变换得到所需要的最简式。

最简与或式：

1. 乘积项（即**与项**）的**个数**最少，使**与门**个数最少。

2. 每个乘积项中的**变量数**最少，使**与门**的输入端最少。

最简与非 - 与非式

1. **非号**个数最少，使得**与非门**个数最少

2. 每个非号中的变量数最少，使与非门的输入端数最少。

> [!note]
> 主要方法是使用**还原律（两次取反）**
> 
> 在 [ 常见表达形式](#常见表达形式) 中提到

#### 逻辑函数的公式化简法

这个主要是运用**逻辑代数的基本定理**和**公式**来对逻辑表达式进行化简

##### 并项法

运用 $AB+A\overline{B} = A(B+\overline{B}) = A$ ，将两项合并为一项，并消去一个变量。

例题：

$$
Y_1=A\overline{B}C+A\overline{B}\overline{C} = A\overline{B}(C+\overline{C}) = A\overline{B}
$$

$$
\begin{aligned}
Y_2&=A(BC+\overline{B}\overline{C})+A(\underline{B\overline{C}+\overline{B}C})\\
&=A\overline{B\oplus C}+A(B\oplus C)\\
&=A

\end{aligned}
$$

##### 吸收法

运用 $A+AB=A(1+B)=A$ 和 $AB+\overline AC+BC=AB+\overline{A}C$ ，消去多余的**与项**。

上面这句话中的第一个公式还好理解，主要是**第二个**

其实就是之前学到的[冗余律](#冗余律)

例如：

$$
Y_{1} = AB + AB(E+F) = AB(1+E+F) = AB
$$
$$
\begin{aligned}
Y_{2} &= \overline{AB}  + \overline{A} D + \overline{B} E \\
&= \overline{A} + \overline{B} +\overline{A}D + \overline{B}E \\
&= (\overline{A} + \overline{A}D) + (\overline{B} + \overline{B}E) \\
&= \overline{A} + \overline{B} \\
& = \overline{AB}

\end{aligned}
$$
上面的 $Y_{2}$ 主要是用了摩根定律。

$$
Y_{3} = \overline{A}B + AC +\overline{B}\cdot \overline{C} +A\overline{B} + \overline{A}\cdot \overline{C} + BC = \overline{A} B + AC + \overline{B}\cdot \overline{C}
$$
这道题目用的就是[冗余律]，当然用同一种方法，但是过程不一样，得到最后的结果也**可能不一样**

![|375](imgs/Pasted%20image%2020250418211404.png)

最后可以使用真值表来判断是否相等。

> [!important]
> 逻辑函数化简结果不唯一，但是结果真值表肯定一样。

##### 消去法

运用 $A+\overline{A}B = A +B$ 或者 $\overline{A}+AB = \overline{A}+B$ ，消去多余因子

例如：

$$
Y_{1} = \overline{A} + AB + \overline{B}C = \overline{A}+B+\overline{B}C  = \overline{A} + B+C
$$

$$
\begin{aligned}
Y_{2} &=\overline{AB} + AC + BD = \overline{A }+ \overline{ B} +AC +BD\\
& = (\overline{A} + AC) + (\overline{B} + BD)\\
& = \overline{A}  + \overline{B}  + C +D \\
& = \overline{ AB\overline{C} \overline{D}}

\end{aligned}
$$

$$
\begin{aligned}
Y_{3} &= AB + \overline{A}C + \overline{B}C \\
&= AB + (\overline{A} + \overline{B})C\\
& = AB + \overline{AB}C\\
& = AB +C
\end{aligned}
$$

上面第二行用到了摩根定律

##### 配项法

在函数某一项乘以 $A+\overline{A}=1$ ，将一项展开两项，或利用 $A\boldsymbol{B}+ \overline {A}C= A\boldsymbol{B}+ \overline {A}C+ \boldsymbol{B}C$ ，增加冗余项 ${BC}$ 。

例题：

$$
\begin{aligned}
Y_{1} &= AB + \overline{B}\overline{C} + A\overline{C}D\\
& = AB + \overline{B}\overline{C} +  A\overline{C}D(B+\overline{B})\\
& = AB + \overline{B}\overline{C} + AB\overline{C}D + A\overline{B}\overline{C}D\\
& = (AB + AB\overline{C}D) + (\overline{B}\overline{C} + A\overline{B}\overline{C}D)\\
& = AB + \overline{B}\overline{C}
\end{aligned}
$$

其实上面这道题不需要这么麻烦的。直接使用冗余律就可以

$$
\begin{aligned}
Y_{1} &= AB + \overline{B}\overline{C} + A\overline{C}D\\
& = BA  + \overline{B}\cdot \overline{C} + A\overline{C}D\\
& = BA  + \overline{B}\cdot \overline{C}
\end{aligned}
$$

第二个：

$$
\begin{aligned}
Y_{2} = A\overline{B} + \overline{A}B + B\overline{C} + \overline{B}C
\end{aligned}
$$
这道题目是否是最简单形式不太确定，其直观性不强。

![|525](imgs/Pasted%20image%2020250419204543.png)

主要是使用冗余律的逆用，得到的结果就是这样的。

当然还可以针对第一个和第三个来逆用冗余律

![|525](imgs/Pasted%20image%2020250419204709.png)

化简结果是不唯一的。

##### 综合运用

$$
\begin{aligned}
Y_1&=AD+A\overline{D}+AB+\overline{A}C+BD+ACEF+\overline{B}E+DEF\\
&=A(D+\overline{D}+B+CEF)+\overline{A}C+BD+\overline{B}E+DEF\\
& =A+\overline{A}C+BD+\overline{B}E+DEF\\
&=A+C+BD+\overline{B}E+DEF\\
& = A+C+BD+\overline{B}E

\end{aligned}
$$
上面的第三行是消去法，第四行到第五行是使用了吸收法

再来一个例题：

$$
\begin{aligned}
Y_{2} & = AC+\overline{A}D+\overline{B}D+B\overline{C}\\
& = AC+B\overline{C}+(\overline{A}+\overline{B})D\\
& =AC+B\overline{C}+\overline{AB}D\\
& =AC+B\overline{C}+ AB + \overline{AB}D\\
& = AC+B\overline{C}+ AB + D \\
& = AC+B\overline{C}+ D
\end{aligned}
$$
上面的第三行到第四行是逆向使用冗余律，然后与后面哪一项使用消去律。最后再把冗余项吸收进去。

> [!note]
> 拿到题目之后，先看有没有能**合并**的，然后再看一下有什么可以**拆开**的，然后看下有没有可以**消去**的，最后看看能不能添加一个**冗余项**

**使用公式法化简很难判定结果是否为最简，不够直观。**

#### 卡诺图化简*

##### 最小项卡诺图的组成

**相邻最小项**

两个最小项中只有一个变量互为反变量，奇遇变量均相同，称为相邻最小项，简称为**相邻项**

相邻最小项的**重要特点**是：

两个相邻最小项相加（相或）可合并为一项，消去**互反变量**

$$
ABC + AB\overline{C} = AB(C + \overline{C}) = AB
$$

**卡诺图的组成**

1. $n$ 个变量，有 $2^n$ 个最小项，每个最小项都要用 $1$ 个小方格表示。
2. 按循环码的编码顺序（格雷码）排列这个是关键，使相邻最小项在几何位置上也相邻且**循环相邻**

##### 二变量卡诺图

![|500](imgs/Pasted%20image%2020250421171940.png)

画卡托图的时候，左上角是按照**顺时针**的方式去写的，比如 $AB$ ，左边就是 $A$ ，右边就是 $B$ ，当然，读的时候也是按照**顺时针**的方法去读的。

需要注意的是，循环码的方法，是每次只有一个变量与上一个不同，从 $0$ 开始。

**可以看到循环码是按照镜像的方法得到的，上面补 0，下面补 1；得到的正好是卡诺图顺时针读到的数。**

而上面图中的第三个图则是用 $m_{i}$ 的形式来表示的。
 
##### 三变量卡诺图

![|500](imgs/Pasted%20image%2020250421172847.png)

如果这八个格子是有 4 列，则把后两个变量放到一起，如果这个八个格子有四行，则把前两个变量放到一起。

而这个反射码则是将二变量得到的反射码**镜像一下**，然后在上面补 0，下面补 1。这样就得到了最后的结果。这个结果就是卡诺图中**顺时针**写出来的。

同时，需要特别注意下面这个图，后续用的次数非常多，比较难区分的就是**顺序**

![|236](imgs/Pasted%20image%2020250421173214.png)

##### 四变量卡诺图

![|500](imgs/Pasted%20image%2020250421173613.png)

四变量卡诺图的循环码，同样的，是由三变量镜像之后，上面补 0，下面补 1 得到的。

而书写顺序则是两个顺时针圆圈。（如上面图中是黄线所示）

然后再用最小项的方法写出来就是下面这个图（**非常重要，需要记住**）

![|300](imgs/Pasted%20image%2020250421173825.png)

对于上面这个图，最需要注意的地方是**注意 8 所在的哪一行**（在最后一行，而不是倒数第二行）


##### 卡诺图中的相邻项（几何相邻）

![|475](imgs/Pasted%20image%2020250421174143.png)

来个题目：
已知最小项如何找对应小方格？如何写出卡诺图方格对应的最小项。

如 $A\overline{B}\overline{C}D$

![|425](imgs/Pasted%20image%2020250421174429.png)

##### 用卡诺图表示逻辑函数*

> [!note]
> 基本步骤：
> 
> 首先求逻辑函数的**真值表**、**标准**或**一般与或式**；
> 
> 根据变量个数画出**变量卡诺图**
> 
> 根据真值表、标准或一般与或式来**填写卡诺图**。

**直接上例题：**

![|475](imgs/Pasted%20image%2020250421181618.png)

> [!important]
> 卡诺图其实就是一个变相的真值表。

**解题步骤：**

首先是根据题目中的真值表，画出卡诺图。

![|300](imgs/Pasted%20image%2020250421181839.png)

然后找出真值表中 $Y=1$ 对应的最小项，在卡诺图相应方格中填 $1$ ，其他部分不写任何东西。

![|350](imgs/Pasted%20image%2020250421181920.png)

上面得到的这个卡诺图就是最后的结果。

**然后再来看一个例题：**

![|425](imgs/Pasted%20image%2020250421182029.png)

注意到，上面的 $\sum m(0,1,12,13,15)$ 是最小项之和。这个逻辑函数是标准与或式。

当然，首先要做的是先把基础卡诺图画出来。

![|250](imgs/Pasted%20image%2020250421182354.png)

然后要做的是，将逻辑式中的最小项 $m_{0}、m_{1}、m_{12}、m_{13}、m_{15}$ 对应的方格填上 1，其他的方格不写任何东西。

![|500](imgs/Pasted%20image%2020250421182509.png)

**再来一个难题：**

![|525](imgs/Pasted%20image%2020250421182532.png)

上面这个很明显不是一个标准与或式，需要先将其换成标准与或式，或者直接不转换，直接在图上进行**找交集**

首先是画出标准的四变量卡诺图。然后找**交集**。

首先看第一个变量 $AB$ ，这个代表着 $CD$ 可以任意取值。

再看第二个变量 $\overline{A}D$ ，这个代表着可以同时满足 $A=0$ ， $D= 1$ 的小方格。

最后看最后一个变量 $B\overline{C}D$ ，这个代表着可以满足 $B=1$ ， $C = 0$ ， $D = 1$ 的小方格。

最后的结果如下：

![|475](imgs/Pasted%20image%2020250421183342.png)

##### 卡诺图化简逻辑函数*

###### 化简依据

其原理在于利用卡诺图的相邻性，对相邻最小项进行合并，消去互反变量，以达到化简的目的。

###### 化简规律

1. 当 2 个小方块相邻（包括处于同一行或同一列的两端），有 1 个变量相异，相加可以消去这**一个变量**，从而合并为一项
   
   ![|400](imgs/Pasted%20image%2020250421185741.png)
   
   当然，上面这种还需要提取出来计算的方法还是比较慢的，下面的这个方法相对来说是比较快的。
   
   就是这个口诀是：**消异存同**
   
   ![|400](imgs/Pasted%20image%2020250421190635.png)

2. 4 个小方块组成一个大方块，或组成**同一行/列**，或组成**两行/列的两端**，或处于**四个角上**，都是可以合并的，**消去两个变量**
   
   当然，用到的方法还是**消异存同**
   
   ![|475](imgs/Pasted%20image%2020250421191455.png)
   
3. 8 个小方块组成两行/列，或组成两边的两行/列，可以合并，消去 3 个变量
   
   用到的方法也是**消异存同**
   
   ![|500](imgs/Pasted%20image%2020250421191826.png)

###### 化简步骤

> [!note]
> 首先是**画出函数的卡诺图**
> 
> 然后，画卡诺圈，将相邻的 $1$ 方格按照 $2^{n}$ 圈为一组，直到**所有的 $1$ 被圈完**
> 
> 然后，将各个卡诺圈分别化简。
> 
> 最后，将各卡诺圈的化简结果**逻辑加**

> [!important]
> 卡诺圈的**数量要越少越好，圈越大越好** 
> 
> 一个圈中的小方格**至少有一个小方格不为其它圈所圈**。

直接上例题：

![|525](imgs/Pasted%20image%2020250421192551.png)

再来一个例题：

![|525](imgs/Pasted%20image%2020250421193030.png)

上面这题，主要说明的形式是第二个，一个卡诺圈内的 1（变量）至少有一个没有被其他圈给圈起来，这也就导致了中间的哪个大圈其实是多余的。

###### 画卡诺圈规则

1. 每个圈中所包含“1”的小方块数只能为 $2^n$ 个，如 $2、4、8$ ;

2. 画圈的时候，应该**将圈画的尽量大**，**圈数最少**

3. 一些为 1 的小方块，可以被圈一次以上

4. 一个圈内至少要有一个之前没有被圈过的 1 的小方块

5. 所有的 1 都要被圈起来，孤立的 1 也不能**漏掉**

再来几个例题：

![|475](imgs/Pasted%20image%2020250421194125.png)

###### 特殊情况

有可能出现，多种花圈的方式，进而导致后面的结果也是不一样的。

![|500](imgs/Pasted%20image%2020250421194404.png)

> [!note]
> 逻辑函数化简的结果不唯一

再来一个例题：

![|500](imgs/Pasted%20image%2020250421194711.png)

上面这个题目说明，可以使用两种圈卡诺圈的方式来化简。

但是，上面第二种方法中，0 必须是相邻项才行，当 1 比较多的时候，可以考虑

###### 有约束的逻辑函数的卡诺图化简

> [!note]
> 约束条件当作备胎来用，需要的时候就用，不需要的时候就不用。

有些题目中，会提供某些选项不能同时出现，比如说之前 8421 BCD 码，后面 6 种都是约束项，不能同时出现。

而约束条件，用 $d$ 来表示

![|500](imgs/Pasted%20image%2020250421201357.png)

由于其约束项的值恒为 0，将这些为 0 的最小项加入到逻辑函数与或式中，或者不加进去，都不会影响函数的值，所以在化简的时候将其看成 1 或者 0 都是可以的，使圈最少且最大即可，从而将结果最简。

直接上例题比较好理解：

![|325](imgs/Pasted%20image%2020250421201708.png)

![|475](imgs/Pasted%20image%2020250421202017.png)

在来一个例题：

![|450](imgs/Pasted%20image%2020250421202140.png)

再来例题：

![|500](imgs/Pasted%20image%2020250421202411.png)

最后一个比较难的题目：

![|500](imgs/Pasted%20image%2020250421202756.png)

# 第三章 - 门电路

## 半导体器件的开关特性

### 门电路

门电路指的是以实现基本逻辑关系和常用复合逻辑关系的电子电路

常用的逻辑门电路：

与门、或门、非门、异或门、与非门、或非门、与或非门

![|500](imgs/Pasted%20image%2020250422154400.png)

### 高低电平

高低电平是某一个规定范围内的电位值，而不是一个**固定值**

![|500](imgs/Pasted%20image%2020250422154703.png)

### 二极管的开关特性

![|475](imgs/Pasted%20image%2020250422155159.png)

这里只需要直到有两种半导体，一种是 P 半导体，一种是 N 半导体。

![|500](imgs/Pasted%20image%2020250422164702.png)

![|500](imgs/Pasted%20image%2020250422164906.png)

## 三极管

三极管有两种类型，一种是 NPN，一种是 PNP

![|500](imgs/Pasted%20image%2020250528223050.png)

区分 NPN 形三极管和 PNP 形三极管的关键是看**符号**上的箭头指向。（箭头一定是**指向 N 极**）

三极管根据两个 PN 结所施加的电压的不同，有**四种工作状态**：

1. **放大状态**：发射结**正**偏，集电结**反**偏

2. **截止状态**：发射结**反**偏，集电结**反**偏

3. **饱和状态**：发射结**正**偏，集电结**正**偏

4. **倒置状态**：发射结**反**偏，集电结**正**偏

> [!note]
> NPN 中，N 的电压比 P 高就是反偏，你负极比我正极大，反了他了

下面进行详细解释：

> [!important]
> 由于三极管有两种形式，所以的状态也都是有两种不同的形式

### 放大状态

发射结**正**偏，集电结**反**偏

![|550](imgs/Pasted%20image%2020250528225433.png)

上面图中所说的 $U_{B}$ 是指的是（在 NPN 结构中）中间的 P 的电压

$U_{C}$ 就是上面的 $C$ 端的电压， $U_{E}$ 则是下面 $E$ 端的电压

> [!important]
> 
> 在使用中主要是以 $NPN$ 类型的三极管为主

![|550](imgs/Pasted%20image%2020250529192424.png)

$$
I_C = I_{CE} + I_{CBO} \approx I_{CE}
$$
$$
I_{B} = I_{BE} - I_{CBO} \approx I_{BE}
$$
$$ I_{\mathbf{E}}=I_{\mathbf{B}}+I_{\mathbf{C}} $$

所以，共发射极电流放大倍数是：

$$
 \beta = \frac{I_{\mathrm{CE}}}{I_{\mathrm{BE}}} = \frac{I_{\mathrm{C}} - I_{\mathrm{CBO}}}{I_{\mathrm{B}} + I_{\mathrm{CBO}}} \approx \frac{I_{\mathrm{C}}}{I_{\mathrm{B}}} 
 
 $$
所以有：

$$ I_{\mathrm{E}} = I_{\mathrm{B}} + I_{\mathrm{C}} = I_{B} + \beta I_{B} = (1 + \beta) I_{B}$$

> [!note]
> 三极管实现了**小电流控制大电流**，而大电流是 $I_{CE}$ ， $I_{BE}$ 是小电流，这个比值叫做**放大倍数**
> 
> 三极管是一种电流控制器器件

![|475](imgs/Pasted%20image%2020250529193222.png)

上面的部分暂时略过，这部分是三极管的物理实现等一系列问题。

### 三极管在数电中的应用

首先是三极管的分析：

下面图中，假设二极管导通的电压为 $0.7v$ ，那么右侧电压应该为 $1v$ 才能满足左侧分别为 $0.3v$ 的情况。

假设 $1v$ 还处于 $0$ 的范围，那么输出的就是 $0$

![|425](imgs/Pasted%20image%2020250806192828.png)

然后是一个 $3.6v$ ，一个 $0.3v$ ：

![|300](imgs/Pasted%20image%2020250806193222.png)

在这种情况下， $D_{1}$ 和 $D_{2}$ ，**优先导通**的是 $D_{1}$ 。导通之后，右侧为 $1v$ ，左侧为 $0.3v$ ，而 $D_{2}$ 的右侧为 $1v$ ，此时 $D_{2}$ 是**截止**的，那输出结果还是 $1v$ ，也就是化为逻辑 $0$

$A$ 、 $B$ 的电压反过来也是成立的。

还有一种情况是 $A$ 、 $B$ 两个都是 $3.6v$ ：

那么 $D_{1}$ 的右侧就是 $4.3v$ ，原因是 $D_{1}$ 的导通电压是 $0.7v$ ， $0.7v + 3.6v = 4.3v$

$D_{2}$ 也是同样的情况。而 $4.3v$ 属于逻辑 $1$ ，所以输出为逻辑 $1$ 

![|300](imgs/Pasted%20image%2020250806193649.png)

这里就是说明**逻辑与**是如何使用二极管实现的。

在 TTL 与非门中表示的下面这张图中的内容。

![|179](imgs/Pasted%20image%2020250806193922.png)

#TODO 

这部分还是暂定，到时候哪里不会点那里吧

## 三态门

三态门，主要是指 $0$ 、 $1$ 、高阻态

![|400](imgs/Pasted%20image%2020250806191123.png)、

其中的 $EN$ 为**使能线**。

(PS：这里的问题在于不能分析出来为什么会这样，有可能用不到)

这也就导致了一个结果：

$$
EN = 1 , F = \overline{AB} \begin{cases}0\\1\end{cases}
$$
$$
EN = 0，F \text{高阻值状态}
$$


![|500](imgs/Pasted%20image%2020250817183228.png)


> [!note]
> 三态门：
> 
> 当 $C$ （使能端）为 $0$ 的时候，也就是让**芯片能正常工作**，（注意此时是低电平有效），三态门的输出正常，为 $D = \overline{A}$ 。
> 
> 当 $C$ （使能端）为 $1$ 的时候，也就是芯片**不能正常工作**，三态门为**高阻值状态**，而在 TTL 中，（上拉状态）高阻值状态需要针对后面输出**并联**（上拉）的**电阻**，如果电阻比较小（没有上 **千**）就当作 $0$ ，如果比较大 (有个几千欧)，当作 $1$ 来处理 。（**CMOS 中没有上拉状态**）
> 
> CMOS 中，如果三态门的**使能端**是 $0$ （低电平有效） ，也就是**激发态**，其正常工作 。
> 
> CMOS 中，如果三态门的使能端是 $1$ （低电平有效），也就是非激发态，其输出与 TTL 相反，输出为逻辑 $0$

# 第四章 - 组合逻辑电路

数字电路根据逻辑功能特点分为：**组合逻辑电路**、**时序逻辑电路**

> [!note]
> 组合逻辑电路：任一时刻的输出只取决于该时刻的输入信号，而与电路原有的状态无关的电路
> 
> 时序逻辑电路：任一时刻的输出不仅取决于该时刻的输入信号，而且与电路原有的状态有关的电路
> 
> 区分组合和时序电路的重要一点是：**电路中是否具有触发器**

这一章学的是组合逻辑电路。

![|500](imgs/Pasted%20image%2020250426154953.png)

## 组合逻辑电路的竞争冒险

### 产生的原因

看下面这个电路：

![|300](imgs/Pasted%20image%2020250813164150.png)

当在**静态**的时候，很明显，结果为 $A\cdot \overline{A} = 0$ ，当然，这个前提就是静态。

但是，当是动态的时候，每个信号进来的时间都是需要时间的。

还是上面这个图，因为上面那条线还经过了一个**非门**，相比较下面那条线多经过了一个元器件，这样就会出现**延迟问题**。

分析下来，以 $A$ 信号为例，因为有延迟，就会导致结果偏差：

![|275](imgs/Pasted%20image%2020250813164625.png)

这里就是竞争与冒险，我们把**有错误发生的竞争称为冒险**

![|275](imgs/Pasted%20image%2020250813164804.png)

### 消除方法

#### 改变表达式形式

第一种方法就是**改变表达式形式**。

避免出现 $A\cdot \overline{A}$ 和 $A + \overline{A}$ 的形式。

例如：

$$
F = ( A + \overline{ B}) \cdot ( \overline{ A} + C)
$$
当 $B = 1$ ， $C = 0$ 的时候，就会出现 $A \cdot \overline{ A}$

为了避免竞争冒险，不要使用**或与式子**

将这个式子展开，就可以得到：

$$
F = AC  + \overline{A}\cdot \overline{B} + \overline{B}C
$$
但其实上面这个也会出现，就是当 $C = 1$ ， $B =0$ 的时候，会出现 $A+\overline{A}$ 。但这个时候 $\overline{B}C \equiv 1$ ，那 $A+\overline{A} + 1 \equiv 1$ ，这也就算是同样避免了这个问题。

#### 人为消除一项（卡诺图）

这个主要是在卡诺图上使用。

假设函数化简出现下面这种情况。

![|197](imgs/Pasted%20image%2020250813170801.png)

其最简形式就是图上两个圈。但是这样就会出现竞争冒险问题，想要避免此类问题。就是避免**圈与圈之间相切**

再上图中，就出现了圈与圈相切。解决方法就是用另外一个圈将这两个相切的圈连接起来。如下图所示：

![|211](imgs/Pasted%20image%2020250813171130.png)

当然，还有下面这种情况：

![|199](imgs/Pasted%20image%2020250813171217.png)

左边的和右边的本质上也是相切的，想要避免竞争冒险，同样的方法就是用另外一个圈将这两个相切的连接起来。

> [!note]
> 主要，如果是**函数化简**的，那么必须是利用卡托图将其化简到最简形式。
> 
> 如果是要**避免竞争冒险**的，那么就需要有几个多余的“圈”。

#### 在输出端接电容

![|292](imgs/Pasted%20image%2020250813171646.png)

当然，添加电容是最后的办法，原因在于添加电容不只是会对冒险问题进行优化，同样的对于正常的信号也会导致“优化”。

所以电容的选择也是需要考虑的。

## 组合电路的分析与设计

### 组合逻辑电路的分析

根据给定的逻辑电路，找出输出与输入之间的逻辑关系，从而确定电路的逻辑功能，比如加法器、减法器等等

**基本步骤**

![|500](imgs/Pasted%20image%2020250426155232.png)

#### 例一

通过例题来实现理解：

![|475](imgs/Pasted%20image%2020250426155254.png)

直接计算不方便，所以采用分段计算的方法来求最后的 $Y$ ，将每个门电路后面的输出分别计算出来，最后再进行组合，就是最后的 $Y$

![|500](imgs/Pasted%20image%2020250426155537.png)

可以得到逻辑函数式：

$$
\begin{aligned}
\mathrm{Y} & =\overline{Y_2+Y_3+Y_4}=\overline{A\cdot\overline{ABC}+B\cdot\overline{ABC}+C\cdot\overline{ABC}} \\
 & =\overline{\overline{ABC}\cdot(A+B+C)}\\
 &  =ABC+\overline{A+B+C}\\
 & = ABC + \overline{A}\overline{B}\overline{C}
\end{aligned}
$$
下面开始**列真值表**

![|475](imgs/Pasted%20image%2020250426155932.png)

然后是**分析逻辑功能**

很明显，根据真值表，当 $A$ 、 $B$ 、 $C$ 三个输入变量取值**一致**的时候（全为 0 或者全为 1），输出 $Y=1$ ，否则为 $0$ 。此电路为**一致判断电路**

#### 例二

再来一个例题：

![|475](imgs/Pasted%20image%2020250426160223.png)

当然了，虽然上面这个图看上去非常复杂，但是不要担心，计算方法还是一样的，首先就是逐级写出逻辑函数式：

先看左边这部分电路：

![|475](imgs/Pasted%20image%2020250426160750.png)

可以得到：

$$
\begin{aligned}
\boldsymbol{W} & =\overline{\overline{A\cdot\overline{AB}}\cdot\overline{B\cdot\overline{AB}}}=A\cdot\overline{AB}+B\cdot\overline{AB} \\
 & =A\cdot(\overline{A}+\overline{B})+B\cdot(\overline{A}+\overline{B})=A\overline{B}+\overline{A}B=A\oplus B
\end{aligned}
$$
通过观察电路结构发现这三部分的电路结构都是一样的。

其实现的功能也是一样的：将两个输入信号进行**异或**

所以可以直接得到：

![|500](imgs/Pasted%20image%2020250426161056.png)

综上所述，我们就得到了最后的结果：

$$
Y=A\oplus B\oplus C\oplus D
$$

然后，下面来写出真值表。

> [!note]
> 异或的运算规则是：**相同为 $0$，不同为 $1$**
> 
> 同时，在这里补充一个：
> 
> 奇数个 1 进行异或，结果为 1
> 
> 偶数个 1 进行异或，结果为 0

慢慢计算之后得到的结果是：

![|575](imgs/Pasted%20image%2020250426161632.png)

然是进行功能说明：

通过观察真值表，可以得到：当 4 个输入变量中，1 的个数为奇数的时，输出为 1，当 1 的个数为偶数时，输出为 0，所以判断电路为**检奇电路**

### 组合逻辑电路的设计

基本设计步骤：

设计思路：分析给定的逻辑要求，设计出能够实现该功能的组合逻辑电路。

基本步骤：

![|525](imgs/Pasted%20image%2020250426170827.png)

其中的逻辑抽象是需要额外注意的地方。

> [!important]
> 首先是分析给定问题，确定输入变量和输出变量，并进行状态赋值（什么时候取值 0，什么时候取值 1），然后分析输出变量和输入变量之间的逻辑关系，列出真值表。
> 
> 得到真值表之后，使用代数法或者卡诺图法来求**最简与或式**
> 
> 然后根据题目中要求的门电路，将最简与或式变换成要求门类型对应的最简式。

#### 例一 - 三人表决器

直接根据例题：

![|525](imgs/Pasted%20image%2020250426171333.png)

首先是将逻辑抽象。

设定变量：有三个人，所以要有三个变量输入，同时输出为 $Y$

然后进行状态赋值。

因为要设计一个表决器，那就有两种状态，一种是赞同，一种是不赞同。结果也有两种，一种是通过，一种是不通过。

![|500](imgs/Pasted%20image%2020250426171609.png)

当然，在这个题目中，其实说明的不是很具体，应该是有三分之二的人表示同意，则表决通过，反之，不通过。满足少数服从多数。

下面来列出真值表。

![|250](imgs/Pasted%20image%2020250426171810.png)

下面进行化简真值表，其中最好的方法其实就是卡诺图。（注意用**循环码**的方法来画卡诺图）

![|275](imgs/Pasted%20image%2020250426172029.png)

得到最简与或式之后，还要分析题目中的要求，题目中要求用与非门来实现这个电路

所以要对卡诺图化简得到的结果进行变换。

> [!note]
> 求与非门的一个技巧是对**原与或式**进行**两次取反**。

$$
\begin{aligned}
Y&=BC+AC+AB\\
&=\overline{\overline{AB+BC+AC}}\\
&=\overline{\overline{AB}\cdot\overline{BC}\cdot\overline{AC}}
\end{aligned}
$$


最后就是来画**电路逻辑图**了。

![|450](imgs/Pasted%20image%2020250426172438.png)

#### 例二 - 四位二进制转格雷码

再来一个例题：

![|525](imgs/Pasted%20image%2020250426172653.png)

还是按照步骤，首先是进行逻辑抽象，先设定变量：

四位二进制代码用 $A_{3}$ 、 $A_{2}$ 、 $A_{1}$ 、 $A_{0}$ 来表示。输出格雷码用 $Y_{3}$ 、 $Y_{2}$ 、 $Y_{1}$ 、 $Y_{0}$ 来表示。

> [!note]
> [格雷码](#格雷码)：两个相邻码之间只有一位不同
> 
> 那如何实现将二进制码转换为格雷码呢？
> 
> 有两种方法：
> 
> 1. 第一个是使用公式法： $G_i=B_{i+1}\oplus B_i$
>    
>    ![|225](imgs/Pasted%20image%2020250426173240.png)
>    
> 2. 用卡诺图
>     
>    ![|225](imgs/Pasted%20image%2020250426173846.png)
>     
>    这个方法最主要的是需要知道其循环的顺序，这个顺序就是最后的真值表的结果。

下面开始列真值表：

![|550](imgs/Pasted%20image%2020250426174129.png)

按照右边卡诺图上的顺序在左边的输出上依次写出来就是最后的答案。

**下面根据上面的真值表来使用卡诺图进行化简**

当然，尽管上面的真值表中是四个输出，只需要将这四个输出拆开即可。

![|225](imgs/Pasted%20image%2020250426174541.png) ![|225](imgs/Pasted%20image%2020250426174624.png)

根据上面的化简，得到的结果是：

$Y_{3}= A_{3}$ ， $Y_2=A_3\oplus A_2$ ， $Y_1=A_2\oplus A_1$ ， $Y_0=A_1\oplus A_0$

**然后来画电路逻辑图**

![|425](imgs/Pasted%20image%2020250426174832.png)

### 算数运算电路 - 加法器和数值比较器

数字系统中除了进行逻辑运算之外，还经常需要进行数值的算术运算，而在系统中的加、减、乘、除都是利用加法器来进行的，所以加法器便成为了数字系统中最基本的运算单元。

#### 半加器

两个 $1$ 位的二进制数相加，不考虑**低位进位**的加法。（注意，这里还是有高位进位的，当作一个输出，只是不考虑低位进位。）

实现半加功能的电路称为**半加器**。

> [!note]
> 半加的规则：两个 1 位二进制数想加，结果有 2 个输出：**半加和** $S$ （本位和）、**半加进位** $C$

![|400](imgs/Pasted%20image%2020250426175556.png)

所以，根据上面描述，得到真值表：

![|525](imgs/Pasted%20image%2020250426175640.png)

很明显，根据真值表，可以得到：

$$
\Bigg[\begin{aligned}
S&=A\overline{B}+\overline{A}B=A\oplus B \\
C&=AB
\end{aligned}
$$

然后来画电路逻辑图：

![|400](imgs/Pasted%20image%2020250426180823.png)

当然，在一些电路中，可以将上面这个半加器化简成一个符号来表示：

![|200](imgs/Pasted%20image%2020250426181435.png)

#### 全加器

将本位的 2 个二进制数和相邻地位来的进位数进行相加的加法。

实现全加功能的电路称为全加器。

![|525](imgs/Pasted%20image%2020250426181759.png)

> [!note]
> 这里需要注意，虽然看上去是两个二进制数在进行相加，但是还隐藏了一个地位进位的输入，所以在真值表上其实是有三个输入。

![|350](imgs/Pasted%20image%2020250907125745.png)

> [!important]
> $A_i,B_i$ 表示 $A$ 、 $B\textbf{两 个 数 中 的 第 }i$ 位， $C_i- 1\textbf{表 }$ 示来自低位 (第 $i-1$ 位) 的进位， $S_{i}$ 表示全加和， $C_i$ 表示送给高位 (第 $i+1$ 位)的进位。

![|475](imgs/Pasted%20image%2020250426182409.png)

注意看，上面真值表中的第三个输入代表是否有进位，如果有进位，则需要将进位也计算在内。

后面的输出部分，本质上是把一次运算的结果拆成两部分，一部分（ $S_{i}$ ）是本位得到的，一部分 $C_{i}$ 是向上一位送去的。

然后，再仔细观察真值表，发现当三个输入中有奇数个 1 的时候， $S_{i}$ 为 1，当输入中有偶数个 $1$ 的时候， $S_{i}$ 为 0

所以根据经验就可以得到：

$$
\begin{aligned}
S_i  &= \overline{A_{i}}\cdot \overline{B_{i}} C_{i-1} + \overline{A_{i}} B_{i}\overline{C_{i-1}} + A_{i} \overline{B_{i}}\cdot \overline{C_{i}} + A_{i}B_{i} \cdot \overline{C_{i-1}}\\ 
& = \overline{A_{i}}(B_{i}\oplus C_{i-1}) + A\cdot \overline{(B_{i} + C_{i-1})}\\
& =A_i\oplus B_i\oplus C_{i-1}\\
\end{aligned}
$$
当然也可以用卡诺图的方法计算出来，其结果是一样的。

![|425](imgs/Pasted%20image%2020250907135911.png)

$C_{i}$ 同样可以使用卡诺图的方法得到：

$$
\begin{aligned}
C_i  &= A_{i}B_{i}\overline{C_{i}} + A_{i}\overline{B_{i}}C_{i-1} + \overline{A_{i}}B_{i}C_{i-1} + A_{i}B_{i}C_{i}\\
&=(A_i\oplus B_i)C_{i-1}+A_iB_i
\end{aligned}
$$
然后其符号如下：

![|250](imgs/Pasted%20image%2020250426184251.png)

实现全加器的逻辑电路如下：

![|475](imgs/Pasted%20image%2020250907135258.png)

##### 使用半加器实现全加器

 主要使用的是半加器的性质，两个输出一个是**进位输出**（与），一个是**本位和**（异或）

![|400](imgs/Pasted%20image%2020250426180823.png)

这样，按照功能其实就能得到**连接方法**：

![|500](imgs/Pasted%20image%2020250907140726.png)

用两个半加器和一个或门就能得到一个全加器。

##### 全加器实现二进制乘法

![|500](imgs/Pasted%20image%2020250426184803.png)

注意，除了最后一位，其他位上相加都会有进位的存在。

因为在计算中存在进位的问题，所以不能简单的用与或来表示，要用到之前提到的全加器。

注意，全加器有两个输出，分别代表本位输出和进位输出。

综上所述，乘法的电子逻辑图为：

![|400](imgs/Pasted%20image%2020250426185402.png)

#### 多位加法器

实现多位二进制加法运算的电路，进位方式有逐位进位（串行进位）和超前进位（并行进位）两种

> [!note]
> 串行进位加法器：低位进位输出端**依次**连至相邻高位的进位**输入端**，最低位进位输入端接地。因此，高位数的相加必须等到低位运算完成后才能进行，运算速度较慢。
> 
> 超前进位加法器：进位数直接由加法、被加数和最低位进位数形成。各位运算并行进行，运算速度快。

##### 串行进位加法器

![|525](imgs/Pasted%20image%2020250426190546.png)

特点是 1. 电路简单，连接方便 2. 速度低

![|425](imgs/Pasted%20image%2020250426190650.png)

##### 超前进位加法器 - 74LS283

![|500](imgs/Pasted%20image%2020250426190801.png)

![](imgs/Pasted%20image%2020250907142443.png)

这里可以认为是利用递归的思想来实现的。

是直接将高位中需要等待低位输入的部分直接换成最低位的输入，这样就不存在等待了，因为最低位的输入部分是已知的。

不过一般是直接使用集成块来实现功能。

##### 集成块 283 加法器的应用 

**应用 1 -- 8 位二进制数相加**

首先是 8 位二进制数相加，原 283 加法器是 4 位二进制数相加。

![|475](imgs/Pasted%20image%2020250907143147.png)

连接的方法比较简单，但是需要注意的是，两块 283 加法器之间是串联的，所以这也就导致高位需要等低位完成之后才能进行。

但 283 加法器内部是高速并行的。

**应用 2 -- 8421 BCD 码转余 3 码**

![|500](imgs/Pasted%20image%2020250907143502.png)

8421 BCD 码与余 3 码之间，只需要对 8421 BCD 码加 3 即可得到余 3 码

#### 减法器

减法运算要用到补码。以及负数的表示。

直接用例子来说明：

设 $A = 0,110$ ， $B = 0,010$ ， $A$ 是 $+6$ ， $B$ 是 $+2$

注意，无论是 $A$ 还是 $B$ ，前面的哪个 $0$ 代表的是这是个**正数**，这一位是**符号位**

然后是运算 $A - B$ ， $A-B = A + (-B)$

接下来看如何求 $-{B}$

在进行减法运算的时候，无论是谁减谁，都需要换成**补码**来运算

对于正数 $A$ ，它的补码就是它本身： $A = 0110$

然后是对于要求的 $-B$ ，由于 $B$ 本身是正数，取它的负数要对补码进行处理。首先是将标志位原来的 $0$ 换成 $1$ ，然后在进行**取反加一**

$$
0010 \rightarrow 1010 \rightarrow 1101 \rightarrow 1101 + 1 = 1110
$$
然后就是进行加法运算：

$$
0110 + 1110 = 1,0100
$$
重点来了，在上面的加法运算中，出现了**进位**，那么就可以直接得到结果为 $0,100$ ；注意，这里最前面的 $0$ 依然是代表着**符号位**。，意思是正数.

反之，如果是 $B - A = 0010 - 0110 = -2$

首先还是 $B$ ， $B$ 是个正数，所以它的补码就是它本身，得到 $0010$ 。

然后是 $A$ ，在这里需要对 $A$ 进行处理：

$$
0110 \rightarrow 1110 \rightarrow 1001 \rightarrow 1001 + 1 = 1010
$$
其中，第一步是将标志位换成 1，代表负数，然后就是再进行**取反加一**。

然后是计算 $0010 + 1010 = 01100$ ，最前面的代表是否有进位，如果有进位就是 $1$ ，如果没有进位就是 $0$ 。

很明显，这里是没有进位的。并且我们通过加法计算得到的其实是结果的**补码**： $1100$ 。

我们已知这个是负数，负数的补码再进行取反加一得到的就是原码。

注意，这里 $1100$ 前面的 $1$ 是代表负数，在进行取反加一的时候，不参与运算。

得到最后的结果是： $100 \rightarrow 011 \rightarrow 011 + 1= 100$

下面是使用加法器实现减法器。

![|475](imgs/Pasted%20image%2020250907152253.png)

逻辑上是一样的，如果得到的结果有进位，那么就不需要再取反加一了，如果得到的结果没有进位，那么需要在进行一边取反加一。

取反使用的性质是异或门的**取反性质**。

#### 数值比较器

数值比较器用于对两个数字的大小或者是否相等进行比较的逻辑电路

##### 一位二进制数值比较器

当然，还是按照之前的分析方法来设计电路。

首先是分析设计要求，列出功能表。

设输入的两个 1 位二进制数为 $A、B$ ，输出比较的结果有三种情况： $Y_{(A>B)}$ 、 $Y_{(A=B)}$ 、 $Y_{(A<B)}$ ，有输出时为 1，否则为 0

下面直接列出真值表

![|525](imgs/Pasted%20image%2020250427172603.png)

然后是根据真值表来写出逻辑函数表达式

$$
\begin{aligned}
 & Y_{(A>B)}=A\overline{B} \\
 & Y_{(A<B)}=\overline{A}B \\
 & Y_{(A=B)}=\overline{A}\cdot\overline{B}+AB=\overline{A\oplus B}
\end{aligned}
$$

甚至于，我们可以得到这三个输出之间的关系：

$$
F_{A=B} = \overline{F_{A>B} + F_{A<B}}
$$

最后是画出电路逻辑图：

![|450](imgs/Pasted%20image%2020250427172858.png)

下面推广到多位数值比较器。

##### 二位二进制数值比较器

当然，首先比较高位，然后是低位。

![](imgs/Pasted%20image%2020250901171000.png)

$$
F_{A>B}  = (A_{1}>B_{1}) + (A_{1}=B_{1}) \cdot (A_{0}>B_{0}) = A_{1}\overline{B_{1}} +(\overline{A_{1}}\cdot \overline{B_{1}} + A_{1}B_{1})\cdot(A_{0}\overline{B_{0}})
$$
$$
F_{A=B} = (\overline{A_{1}}\cdot \overline{B_{1}} + A_{1}B_{1}) \cdot(\overline{A_{0}}\cdot \overline{A_{0}}+A_{0}B_{0})
$$
$$
F_{A<B} = (\overline{A_{1}}B_{1})+(\overline{A_{1}}\cdot \overline{B_{1}} + A_{1}B_{1})\cdot(\overline{A_{0}}B_{0})
$$

如何使用两个一位二进制数值比较器来实现二位二进制数值的比较呢？

具体接线如下图所示。

![|400](imgs/Pasted%20image%2020250901180244.png)

##### 多位数值比较器

> [!note]
> 比较原理：从**最高位**开始逐位向低位进行比较
> 
> 举个例子：
> 
> 比较 $A = A_{3}A_{2}A_{1}A_{0}$ 和 $B = B_{3}B_{2}B_{1}B_{0}$ 的大小：
> 
> 若 $A_{3}>B_{3}$ ，则 $A>B$ ；若 $A_{3}<B_{3}$ ，则 $A<B$ ；若 $A_{3}=B_{3}$ ，则需要比较**次高位**
> 
> 若次高位 $A_2>B_2$ ，则 $A> B$ ；若 $A_2< B_2$ ，则 $A<B$ ；若 $A_2= B_2$ ，则再去比较更低位。
> 
> 以此类推，直到最低位比较结束

这里就需要使用集成块来实现了

![|500](imgs/Pasted%20image%2020250427173456.png)

在上面这个比较器中，有三个级联输入端，意味着如果这个两个四位二进制数，都相等，那么最后的结果则是根据这个级联输入端来判断的。具体看下面这个功能表。

![|600](imgs/Pasted%20image%2020250427173830.png)

下面是 74LS85 的使用说明：

1. 当只比较两个 4 位二进制数时，或**不使用扩展端**（意味着此比较器作为低位使用）时，将扩展端的 $I_{(A=B)}$ 接 1， $I_{(A<B)}$ 和 $I_{(A>B)}$ 接 $0$ 。其实 $I_{(A<B)}$ 和 $I_{(A>B)}$ 在这时取什么都是可以的，但是为了方便来说，取 $0$ ；这样的话，对于低位来说，相当于**再低位**的比较结果是**相等的**，那么就再去比较高位即可。

2. 当比较两个 4 位以上 8 位以下的二进制数时，应先比较两个高 4 位的二进制数，在高位相等时，才能比较低 4 位数。只有在两个4位二进制数相等时，输出才由扩展端 $I_{(A>B)}、 I_{(A<B)}、 I_{(A=B)}$ （相当于再去**由低位决定**）决定。

下面是用两个 74LS85 来级联成 8 位数值比较器

![|625](imgs/Pasted%20image%2020250427174456.png)

![](imgs/Pasted%20image%2020250901215032.png)

如果是十六位的，那么可以将四个 4 位二进制数值比较器串联起来，也是可以实现十六位的二进制数值比较。

下面是使用并联的形式，来实现十六位的二进制数值的比较

并联，就需要使用 5 个二进制数值比较器。

连接方法如下：

![|425](imgs/Pasted%20image%2020250901220245.png)

> [!note]
> 关键在于第二级连接，由于第一级输出的是逻辑结果，那么只需要比较是否存在大于小于的情况，至于等于的情况，不需要考虑在内，原因在于如果在第一级上出现等于，那么相应的，大于小于的输出一定是 $0$ ，再输入到二级中的时候，输入就已经相当于是**相等**的了

### 编码器和译码器

#### 编码器

> [!note]
> 编码：用文字、符号或数字来表示特定对象的过程。
> 
> 在数字电路中，采用**二进制**进行编码

![|525](imgs/Pasted%20image%2020250427174747.png)

下面来看一下**输入信号**与**输出位数**之间的关系

![|500](imgs/Pasted%20image%2020250505164854.png)

这个说明的是如果有 8 个待编码的信号，那么至少需要 3 位二进制代码数。

如果只有 6 个待编码的信号，那么也需要 3 位二进制代码数。

##### 二进制编码器

二进制编码器是将 $N = 2^{n}$ 个输入信号转换成 $n$ 位二进制代码的逻辑电路。

比如说下面这个例题：

![|450](imgs/Pasted%20image%2020250505165311.png)

当然，这个例题依然是按照之前求解实际问题的方法（组合逻辑电路的设计）来解决。

首先是分析设计要求，列出功能表。

由题意可知，该编码器有 8 个输入信号，分别是 $I_0$ 、 $I_1...$ $I_7$ ，有编码请求时，输入信号用 1 表示，没有时为0。根据 $2^n\geq N=8$ 可求得输出 $n=3$ ,为 3 位二进制代码，分别用 $Y_0$ 、 $Y_1$ 、 $Y_2$ 表示。

> [!note]
> 普通的二进制编码器是一种多输入、多输出的组合电路，在某一时刻只能对**一个输入信号**进行编码，不允许有两个或两个以上的信号**同时**有效，具有**相互排斥性**。

如下面的真值表。

![|525](imgs/Pasted%20image%2020250505165804.png)

然后是根据真值表写出输出逻辑函数表达式；

$$
\begin{aligned}
Y_2&=I_4+I_5+I_6+I_7\\
Y_1&=I_2+I_3+I_6+I_7\\
Y_0&=I_1+I_3+I_5+I_7

\end{aligned}
$$
这里直接就看其输出为 1 的对应的输入上的信号即可。本质上是**吸收律**

然后换到与非式：

$$
\begin{aligned}
Y_{2}&=\overline{\overline{I_{4}}\cdot\overline{I_{5}}\cdot\overline{I_{6}}\cdot\overline{I_{7}}}\\
Y_{1}&=\overline{\overline{I_{2}}\cdot\overline{I_{3}}\cdot\overline{I_{6}}\cdot\overline{I_{7}}}\\
Y_{0}&=\overline{\overline{I_{1}}\cdot\overline{I_{3}}\cdot\overline{I_{5}}\cdot\overline{I_{7}}}
\end{aligned}
$$
下面画出逻辑图

![|525](imgs/Pasted%20image%2020250505170629.png)

下面这个是以 4 个信号为例子，用卡诺图化简的方法实现为什么 $Y_{1} = I_{2} + I_{3}$

![|500](imgs/Pasted%20image%2020250505212019.png)

进而得到的结果是下面这个，后续可以直接使用这种方法从而快速的求解输出对应输入之间的关系。

![|500](imgs/Pasted%20image%2020250505212313.png)



##### 二-十进制编码器

用二进制数对十进制数进行编码

依然是通过例题来解答：

![|525](imgs/Pasted%20image%2020250505170755.png)

下面来分析设计要求，列出功能表。

由题意可知，该编码器有 $I_0$ 、 $I_1...I_9$ 10 个输入信号，有编码请求时，输入信号为1，没有时为0。根据 $2^n\geq N=10$ 可求得输出 $n=4$ ，故有 4 个输出端，分别用 $Y_0$ 、 $Y_1$ 、 $Y_2$ 、 $Y_3$ 表示。

这种编码是**不完全编码**

> [!important]
> 注意，在这种编码中，不一定是用什么方法来进行编码，这个题目是编码成 8421BCD 码，当然可以能是其他的顺序。

![|350](imgs/Pasted%20image%2020250505171236.png)

然后是根据真值表来写出逻辑函数表达式

$$
\begin{aligned}
  Y_{3} & =I_8+I_9 \\
  Y_2 & =I_4+I_5+I_6+I_7 \\
  Y_{1} & =I_2+I_3+I_6+I_7 \\
  Y_0&=I_1+I_3+I_5+I_7+I_9
\end{aligned}
$$
然后换成与非表达式得到：

$$
\begin{aligned}
 & Y_{3}=\overline{\overline{I_8}\cdot\overline{I_9}} \\
 & Y_2=\overline{\overline{I_4}\cdot\overline{I_5}\cdot\overline{I_6}\cdot\overline{I_7}} \\
 & Y_1=\overline{\overline{I_2}\cdot\overline{I_3}\cdot\overline{I_6}\cdot\overline{I_7}} \\
 & Y_{0}=\overline{\overline{I_1}\cdot\overline{I_3}\cdot\overline{I_5}\cdot\overline{I_7}\cdot\overline{I_9}}
\end{aligned}
$$
下面是画出电路逻辑图

![|550](imgs/Pasted%20image%2020250505171635.png)

按照题目的要求是要用与非门来实现，但是上面图中用的不全是与非门，当然也可以用直接用与非门来表示非门，具体方法在上面图中的右上角。

##### 十进制编码器补充

针对十进制编码器，其主要实现的逻辑电路如下图所示。

![](imgs/Pasted%20image%2020250820185912.png)

这里的问题在于对于输入 $0$ 的编码，设置成了 $0000$ ，但是在电路中，如果什么也不按，其输出的编码结果与 $0000$ 的编码结果是一样的。这样会无法区分是什么也没按，还是只按了 $0$

所以添加一个**标志位**，当标志位为 $0$ 的时候，表示什么也没按。

其逻辑设计也在上面图中表示。

其功能表图下图所示：

![](imgs/Pasted%20image%2020250820190245.png)



##### 优先编码器

###### 基本优先编码器

之前讲的编码器都是只能单个信号有效，但是在很多场合不只是单个信号，而多个信号就涉及到**优先级**的问题

优先编码器允许同时输入多个编码信号，并且只对其中优先级别高的信号进行编码输出的信号。

> [!note]
> 下面假设 $I_{7}$ 的优先级最高， $I_{6}$ 次之，依次到 $I_{0}$ 最低。优先级高的信号排优先级低的，具有单方面排斥的特性。
> 
> 而在优先级之后的部分无论是有效还是无效都无所谓了。用 $X$ 来表示。

真值表如下图所示。

![|525](imgs/Pasted%20image%2020250505172606.png)

**需要注意的是**，在输出表达的时候，是根据优先级来计算出来的，依然是看对应的部分是如何取值的。而推导则是上面图中的**红色部分**，用到的是**吸收率**

$$
\begin{gathered}
Y_2=I_7+I_6+I_5+I_4 \\
Y_1=I_7+I_6+\overline{I_5}\overline{I_4}I_3+\overline{I_5}\overline{I_4}I_2 \\
Y_{0}=I_{7}+\overline{I_{6}}I_{5}+\overline{I_{6}}\overline{I_{4}}I_{3}+\overline{I_{6}}\overline{I_{4}}\overline{I_{2}}I_{1}
\end{gathered}
$$
> [!note]
> 注意，上面这里不是全部的**非**都被消去了。有一部分没办法被消去。

下面用四个输入信号作为例子以卡诺图化简的方法来进行说明，

首先需要注意的是，在输出部分，由于 $I_{3}$ 输入为 1，后面的输入无论是什么都不影响输出，将这个时候的输出都设置为 1，所以 $Y_{1}=Y_{0}=1$ 。

然后是当 $I_{3}=0$ 、 $I_{2} = 1$ 的时候，后面的输入无论是什么都不影响输出，设置这个时候的输出为 $Y_{1}=0$ ， $Y_0 = 0$

以此类推，当 $I_{3} = 0$ ， $I_{2} = 0$ ， $I_{1} = 1$ 的时候，后面的输入无论是什么都不影响输出，设置这个时候的输出为 $Y_{1} = 0$ ， $Y_{0}=1$

当 $I_{3} = 0$ ， $I_{2} = 0$ ， $I_{1} = 0$ 、 $I_{0} = 1$ 的时候，后面的输入无论是什么都不影响输出，设置这个时候的输出为 $Y_{1} = 0$ ， $Y_{0}=0$

而当输入都为 0 的时候，输出的结果就是无关项了。

![|475](imgs/Pasted%20image%2020250505213600.png)

然后将上面的真值表化简一下，得到右侧的真值表。

最后在这个真值表上找规律：

![|475](imgs/Pasted%20image%2020250505214620.png)

> [!note]
> 在进行计算的时候，只看交叉 (X) 前面的部分，例如 $Y_{1} = I_{3} +\overline{I_{3}}\cdot I_{2}=I_{3} + I_{2}$ ， $Y_{2} = I_{3} +\overline{I_{3}}\cdot \overline{I_{2}}\cdot I_{1} = I_{3}+\overline{I_{2}}\cdot I_{1}$

通过上面这个方法，再将其推广到八个变量。

![](imgs/Pasted%20image%2020250505215113.png)

###### 74LS148 优先编码器

这里就不再是传统的门电路了，而是下面这种集成电路：

![|450](imgs/Pasted%20image%2020250505174136.png)

右边的是示意图。

下面对引脚进行说明：

![|550](imgs/Pasted%20image%2020250505174241.png)

下面是功能表：

![|500](imgs/Pasted%20image%2020250505174723.png)

当 $\overline{ST}$ 为 1 的时候，代表不工作，所以无论输入是什么，输出都是 1

只有当 $\overline{ST}$ 为 0 的时候，代表工作，才能进行编码。

而第二行都是 1，代表没有一个信号有效（没有信号输入），因为这里是低电平有效，所以，全 1 其实是全 0

当 $\overline{ST}$ 为 0 代表工作的时候， $Y_{s}$ 和 $\overline{Y_{ES}}$ 则**相反**的。

当输入无效的时候（输入全是 0，取反之后为全 1）， $Y_{s}$ 为 0， $\overline{Y_{ES}}$ 为 1。

从上面图中的第三行开始则是**正常进行编码**

****

下面是 CD 4532 的功能表

其功能于 148 一样，唯一不同不就是这个是高电平有效，148 是低电平有效

![](imgs/Pasted%20image%2020250821201223.png)

其中的 $GS$ 是判断是否有输入的，如果芯片没有输入或者输入使能端为 $0$ ，那么 $GS$ 的输出也是 $0$

$EI$ 代表的是输入使能端，当它为 $0$ 的时候，相当于芯片没有启动，无论输入如何，其功能相当于**无作用**。

$EO$ 代表输出使能端，当芯片有输出的时候， $EO$ 为 $0$ ，反之，当芯片**启动并且没有输入**的时候， $EO$ 为 $1$
###### 148 级联成 16-4 优先编码器

首先来看级联之后的真值表：

![|575](imgs/Pasted%20image%2020250505175704.png)

在上面图中，中间红线左边是低位的 148，右边是高位的 148，问题在于如何将这两部分连接到一起，实现功能。

注意看真值表，当高位片工作的时候，地位片是不工作的，所以，将高位片的 $Y_{S}$ 连接到地位片的 $\overline{ST}$ 上。

此外，无论是高位片还是低位片，都是只有 $\overline{Y_{2}}$ 、 $\overline{Y_{1}}$ 、 $\overline{Y_{0}}$ 的，没有 $\overline{Y_{3}}$ 的，我们需要找一个地方来当做 $\overline{Y_{3}}$ 

然后，当低位片工作的时候，高位片也是不能工作的。

所以，可以发现，最终输出的 $\overline{Y_{3}}$ 与高位片的 $\overline{Y_{ES}}$ 之间有些许关联。

而最终输出的 $\overline{Y_{0}}$ 、 $\overline{Y_{1}}$ 、 $\overline{Y_{2}}$ ，与高位片和低位片之间的输出的关系是**与**

进而得到最后的电路图：

![|475](imgs/Pasted%20image%2020250505205123.png)

****

补充关于 CD 4532 级联的功能示意。

![](imgs/Pasted%20image%2020250821202612.png)

同样的，与 148 功能相同，区别在于高低位激活不一样。

唯一需要注意的是，最后输出四位中的最高位是**高位芯片的使能端**，原因在于当高位有输入的时候，最高位肯定是 $1$ ，而当高位芯片没有输入，但低位芯片有输入的时候，高位芯片的使能端肯定是 $0$ ，这也就保证了输出的正确性。

###### 十 - 四优先编码器 147

![|475](imgs/Pasted%20image%2020250505205311.png)

这个芯片比较特殊，尽管是十位转四位，但是对 $\overline{I_{0}}$ 的编码是隐藏的，当输入端全为 1 的时候，代表 $\overline{I_{0}}$ 为 0，对应的输出是 $1111$

下面是功能（真值）表

![|525](imgs/Pasted%20image%2020250505205611.png)

需要注意到是，这个的编码是反码，首先来看第二行，代表的是 9，而 9 的二进制是 1001，而取反之后得到的是 0110.

其他的也是以此类推。

至于说最上面的哪个全 1 输入，得到的结果是 1111，而取反之后得到的是 0000，代表的也是 0.

> [!important]
> 上面的这部分关于级联编码器以及十-四优先编码器，后续如果有需要再去看。 -- 2025 年 5 月 5 日

#### 译码器

译码器与编码器可以说是相反作用的两个器件。

**译码**：将具有特定意义的二进制代码转换成相应信号输出的过程。

译码器将二进制代码转换成相应信号输出的时候只能译出来一个有效电平。

![|475](imgs/Pasted%20image%2020250505220201.png)

##### 二进制译码器

将输入二进制代码的各种组合按照其原意转换成对应信号输出的逻辑电路

还是以一个例子的方法来说明：

![|475](imgs/Pasted%20image%2020250506160507.png)

设输入 3 位二进制代码为 $A_{2}$ 、 $A_{1}$ 、 $A_{0}$ ，共有 $2^{3} = 8$ 种不同组合。它有 8 个输出端，用 $Y_{0}$ 、 $Y_{1}$ 、 $\cdots$ 、 $Y_{7}$ 来表示，输出高电平 1 有效 

下面列出其功能表（真值表）

![|450](imgs/Pasted%20image%2020250506161001.png)

然后是写出逻辑函数表达式：

![|525](imgs/Pasted%20image%2020250506161250.png)

可以发现其中，每一个输出 $Y_{i}$ 都是一个最小项，（只包含自身和自身的反）

如果我们用这些最小项进行组合，就可以得到其他的逻辑函数，比如只把前四项**或**到一起

如果把这些最小项做一个组合，那么就可以构成三个变量的任意逻辑函数

所以，二进制译码器也称为**函数发生器**。

接下来画一下逻辑图：

![|550](imgs/Pasted%20image%2020250506161707.png)

##### 双 2 线-4 线译码器 139

这一部分使用的比较少。

![|525](imgs/Pasted%20image%2020250821210710.png)

这里是低电平有效，所以上面的使能端和输出都是以低电平的形式输出。

当使能端 $\overline{E} = 1$ 的时候，代表芯片不工作，所以无论输入如何，其输出都为 1

反之，当使能端为 0 的时候，意味着开始工作。

> [!note]
> 需要注意的是，这个是译码器，所以在输出的时候，每一位输出都只能有一位有效。（因为是**低电平有效**，所以以 $0$ 代表有效 ）

在图中使用了逻辑表达式的方法来表示 $\overline{Y_{0}}$ ，当然可以使用卡诺图的方法将其写出来。
##### 3 线 - 8 线译码器 138

这个译码器是一个非常通用的一个译码器

![|475](imgs/Pasted%20image%2020250506161952.png)

下面对引脚进行说明：

![|475](imgs/Pasted%20image%2020250506162053.png)

只有当 $ST_{A} = 1$ 、 $\overline{ST_{B}}=\overline{ST_{C}} = 0$ 的时候**才进行译码**，否则不进行译码，不进行译码输出的结果就是全 0

下面是其功能表（真值表）

![|575](imgs/Pasted%20image%2020250506162612.png)

需要注意的是，由于最后的输出都加上了一个**非**，所以在进行最后的函数上的逻辑运算的时候，要用与非门来实现逻辑组合，原因在于 $\overline{\overline{m_{0}}\cdot\overline{m_{1}}\cdot\overline{m_{2}}} = m_{0}+m_{1}+m_{2}$

下面对上面的功能表做一个补充：

![|575](imgs/Pasted%20image%2020250821215115.png)

只有当 $E_{3}$ 、 $\overline{E_{2}}$ 、 $\overline{E_{1}}$ 的顺序依次为 $100$ 的时候，译码器才会工作，其他情况下都不会工作。不会工作的状态**有七种**。

同时，在输出端，依然是只有一种输出。

##### 3 线 - 8 线译码器的应用

###### 已知输入波形画出输出

这个时候，一般是 $E_{3}$ 接入 $5 v$， $\overline{E_{1}}$ 接地，也就是 $0v$

控制器由 $E_{2}$ 来控制。

![|350](imgs/Pasted%20image%2020250821215748.png)

具体的例子如下图：

![|550](imgs/Pasted%20image%2020250821220430.png)

###### 138 译码器的扩展

有的时候，一片 138 译码器不够用，需要两个 138 译码器组成 4-16 译码器

![|550](imgs/Pasted%20image%2020250506163403.png)

注意看上图中，利用芯片 $ST_{A}$ 的特性，将其设置为最高位，当 $A_{3} = 0$ 的时候，低位片工作，当 $A_{3}=1$ 的时候，高位片工作。

下面详细解释一下工作原理

![|600](imgs/Pasted%20image%2020250508165005.png)

注意看上面图中右下角的表，这个表就是其实现的效果。

下面进行补充：

将译码器扩展到 $5$ 线 $32$ 线译码器。

这个是四片 138 联合起来

![](imgs/Pasted%20image%2020250822205720.png)

首先来分析功能表，一共有五位输入，32 位输出。

可以发现后三位是以 8 位一组为循环。所以，我们按顺序将后三位连接到**每一个**芯片的三位**数据输入端**上。

之所以是每一片，原因在于前两位的输入。

前两位的连接方法如上面图中所示，按照从**高位到低位**的特点进行连接。

这个方法主要是利用控制**使能端**的方法对从高位到低位各个芯片的控制，让其能够输出正确的顺序。

举个例子既可以理解：

假设输入的是 $B_{4}B_{3}B_{2}B_{1}B_{0} = 10011$

首先看后三位，是 $011$ ，当被输入的时候，每一个芯片上的三位输入，输入的都是 $011$

如果使能端都是正常工作的，那么每一个芯片的输出都是 $\overline{L_{3}}$ （第三位）

但是前面两位就需要通过控制每个使能端的方法来保证其输出是正确的。

由于输入是 $10$ ，利用图中的连接方法，第一个连接的方式得到的结果是 $110$ ，很明显，此芯片是不工作的，其输出就变成了**全是 0**

其他的以此类推。只有当芯片的使能端满足 $100$ 的方法才能保持工作。

****

当然，还可以使用将前面两位（高位）的输入利用 139 译码器（2 线 - 4 线译码器），将其输出连接到**每个芯片使能端的低电位（两个）**

![](imgs/Pasted%20image%2020250822214205.png)

###### 译码器实现逻辑函数

用例子来实现：

$$
F = \overline{A} B + A \overline{C}
$$
首先是将逻辑函数换成**最小项**。

可以使用公式来计算，也可以使用卡诺图的方法得到最小项。

$$
F(A,B,B) = \sum m(2,3,4,6)
$$
然后是使用 138 来进行表达。

很明显，将 $ABC$ 按照**顺序**将其连接到 138 的输入上。当输入为 $011$ 的时候，经过译码器，译码器的 $\overline{L_{3}}$ 相应，输出为 $0$

同样的，每一个最小项的输入都会有一个对应的输出。但是，最后的结果与相应的是相反的。

所以要将所有最小项输出相应通过一个**与非门**连接起来，就能得到最后的结果

![](imgs/Pasted%20image%2020250822220205.png)

****

扩展情况：

由于一个 138 译码器的正常输入是三位的，但如果想要输入一个 4 位的逻辑函数，如何使用译码器实现逻辑函数

可以使用两片 138 译码器连接到一起来实现这个功能。

![](imgs/Pasted%20image%2020250822220728.png)

这里的主要思想是将最高位的作用设置为控制使能端，然后将剩下的三位按顺序连接到每个 138 的输入端上。

最高位在控制使能端的时候，低位的芯片与高位的芯片在连接上有所不同，一般来说，是将 A 连接到**低位的低控制端上**，并且连接到**高位的高控制端上**。这样，当 $A = 1$ 的时候，就能让低位不工作。只让高位工作。当 $A = 0$ 的时候，让低位工作，让高位不工作。

这样的思想其实是将高位、低位两篇芯片的每一个输出都有对应。将所以的可能性分成两部分，也就是 $F_{all} = \overline{A}(BCD)+ A(BCD)$

当然最后的输出还是使用**与非门**将其连接起来。

****

在实现上面的功能的时候还有一种更简便的方法（更巧妙的方法）
 
![](imgs/Pasted%20image%2020250822222642.png)

观察这个函数，这个函数可以化成 $F = C(ABD)+ \overline{C}\cdot 0$ 的形式，那么就不需要两个 138 译码器了。

但是需要注意的是，译码器的输入端三个变量的连接顺序需要有所变化。

$$
F = C\cdot (\overline{A}BD + \overline{A}\cdot \overline{B}\cdot \overline{D} + ABD + \overline{A}B\overline{D}) =C \cdot (m_{3} + m_{0} + m_{7} + m_{2})
$$

当然，因为在给定的逻辑表达式中， $C$ 一直都是 $1$ 的，所以直接将 $C$ 连接到使能端的高电平端即可使译码器工作。

###### 138 组成数据分配器

首先理解什么是数据分配器：将一个信号输入进来，然后找到对应的输出，将这个信号再输出出去即可。

其连接方法如下面图所示。

![](imgs/Pasted%20image%2020250822223632.png)

本质上是**将输入的信号连接到使能控制端的低电平有效**上，将选择的**输出地址**当作译码器正常的输入来看待。

这样就能实现将信号以设定好的位置输出出去。

相应的，如果**将输入的信号连接到使能控制端的高电平有效**上，其实现的结果就是将信号**以取反的方法**输出出去。

##### 二 - 十进制译码器

这个的作用是将输入的 10 组 4 位二-十进制代码翻译成 $0\sim 9$ 十个对应信号输出的逻辑电路

![|500](imgs/Pasted%20image%2020250508173204.png)

这个芯片是没有**控制端**的

有十个译码输出端，低电平 0 有效。还有四个 8421BCD 码输入端，从高位到低位依次是 $A_{3}$ 、 $A_{2}$ 、 $A_{1}$ 和 $A_{0}$

![|475](imgs/Pasted%20image%2020250508173420.png)

下面是它的功能表：

需要注意的是：虽然有四位输入，总共有 $2^{4} =16$ 种输入，但是有效的只有十种，这也就导致了有六种伪码。这六种伪码就全是无效电平。也就是 $1$

![|375](imgs/Pasted%20image%2020250508173705.png)

##### 显示译码器

在之前学到的 138 也就是 3 线-8 线译码器，就是传统上的结果中只有输出是有效电平，剩下的都是无效电平（高电平 1）

但是在一些场合，不只是需要一个有效的信号输出，还需要多个有效的信号进行输出。

下面的显示译码器就是能多个有效信号的输出。

**显示译码器**：将输入的 BCD 码译成相应的输出信号，以驱动显示器显示出相应数字的电路

同样的，这个也是四个输出，十个输出，这也就意味着，在输入的时候，是有**六个伪码**的。这种编码称为**不完全编码**

![|475](imgs/Pasted%20image%2020250514151310.png)

注意，在设计中，设计为 **0 为亮，1 为不亮**，本质上还是取反

在数字设备中用得比较多的是**七段数码显示器**，又称为是数码管。常用的有**半导体数码显示器**（LED）和液晶显示器（LCD）等，它们由七段可以发光的字段组合而成。

![|475](imgs/Pasted%20image%2020250514191622.png)

COM 端称为公共端，是将多个数码管串联到一起用的连接点。

> [!note]
> 测试数码管是共阴极还是共阳极：可以用万用表来测试，如果黑表笔放到 COM 端，红表笔放到其中一个显示端（七个其中一个），亮了就是**共阴极**。红表笔放到 COM 端如果亮了就是**共阳极**

所以它有两种接法：

一个是共阳极接法，一个是共阴极接法

![|550](imgs/Pasted%20image%2020250514191918.png)

> [!note]
> 共阳极接法的数码管需要配用输出低电平有效的译码器。

****

![|550](imgs/Pasted%20image%2020250514192159.png)

> [!note]
> 共阴极接法的数码管需要配用输出**高电平**有效的译码器

****

补充：

![](imgs/Pasted%20image%2020250823205749.png)

在显示译码器中，相比较于传统的译码器，虽然也有三个**使能端**，但是实现的功能还是不一样的。

这里的使能端更像是一种**能够实现更多功能的控制器**

具体控制方法如上面图中所示。

只有当 $\overline{LT} = 1$ ， $\overline{BL} = 1$ ， $LE = 0$ 的时候才正常**译码**

下面是正常译码的时候逻辑表

![](imgs/Pasted%20image%2020250823210336.png)

需要注意的是，当出现**无效码**的时候，**显示译码器**是**灭灯**的

###### 48集成译码器（显示）

![|550](imgs/Pasted%20image%2020250514192423.png)

48 的输出端高电平有效，需要与共阴极数码管配合才行

![|525](imgs/Pasted%20image%2020250514192757.png)

这里需要注意的是最后一个控制端：（ $\overline{BI / RBO}$ ），这个是既可以当作输入，也可以当作输出。

本质上在后面的功能表上有说明，当其他的输入都无效的时候，这个时候的 $\overline{BI/RBO}$ 是当作输入来用的，输入为 $0$

![|675](imgs/Pasted%20image%2020250514193410.png)

此外，当 $\overline{RBI}$ 和 $A_{3}$ 、 $A_{2}$ 、 $A_{1}$ 、 $A_{0}$ 输入都为 0 的时候，才控制为**消隐**（**灭零**）

下面这种接法是一种常规接法：

![|525](imgs/Pasted%20image%2020250514193658.png)

下面是多位的显示译码器连接到一起实现**多位数码管的动态灭零连接电路**

![|625](imgs/Pasted%20image%2020250514194736.png)

其中，整数部分：高位的 $\overline{BI/RBO}$ 和低位的 $\overline{RBI}$ 相连

小数部分：地位的 $\overline{BI/RBO}$ 与高位的 $\overline{RBI}$ 相连

###### COMS 4511 集成译码器

其输出端高电平有效，需要与**共阴极数码管**配合

![|500](imgs/Pasted%20image%2020250514202512.png)

下面是逻辑图：

![|525](imgs/Pasted%20image%2020250514202644.png)

相对于原来的 48 译码器，其在无效码的时候也是消隐的。

并且在控制端都为高电平的时候，能够将上一次的输入进行**锁存**

![|525](imgs/Pasted%20image%2020250514202957.png)

在锁存之后，无论再输入什么都是被锁住的哪个数

### 数据选择器

数据选择器：根据地址信号的要求，从多路输入数据中选择其中一路输出的逻辑电路。又称为多路选择器（Multiplexer，简称为 MUX）或者多路开关


![|550](imgs/Pasted%20image%2020250514203501.png)

数据选择器的输入信号个数 $N$ 与地址码个数 $n$ 的关系为 $N=2 n$

常用 2 选 1、4 选 1、8 选 1和 16 选 1 等数据选择器。

![|525](imgs/Pasted%20image%2020250831142805.png)

其中二选一以及四选一的类似电路图如上面图中所示。

最常见的方法就是使用**与或式**

 #### 4 选 1 数据选择器（153）

下面以做题的形式来实现数据选择器

![|475](imgs/Pasted%20image%2020250516170534.png)

题意可知，数据选择器有 $4$ 个数据输入端，$1$ 个输出端。数据输入端分别用 $(D_0)$、$(D_1)$、$(D_2)$、$(D_3)$ 表示，有数据输入时，用 $1$ 表示，任意值用 $(\times)$ 表示。地址输入端用 $(A_0)$ 和 $(A_1)$ 表示。使能控制端用 $(\overline{ST})$ 表示。

![|500](imgs/Pasted%20image%2020250516171157.png)

逻辑表达式为：

$$
\begin{align*}
Y = (D_0 \overline{A_1}\cdot \overline{ A_0} + D_1 \overline{A_1} A_0 + D_2 A_1 \overline{A_0} + D_3 A_1 A_0) \overline{\overline{ST}}
\end{align*}
$$
然后是画出电路逻辑图

 ![|500](imgs/Pasted%20image%2020250516171924.png)

下面的集成电路为：

**74 LS 153**，当然这个数据选择器是一个双路的，也就是上面有**两个 4 选 1 数据选择器**，而他们的地址段是**通用**的

![|575](imgs/Pasted%20image%2020250516172126.png)

功能表如下：

![|550](imgs/Pasted%20image%2020250516172338.png)

![|500](imgs/Pasted%20image%2020250516172801.png)

在这个地方可以看出来数据选择器又称为是**最小项输出器**

> [!note]
> 令数据 $D_{0}\sim D_{3}$ 有些为 $0$ ，有些为 $1$ ，或者为其他变量，可以构造不同的逻辑函数

#### 8 选 1 数据选择器（151）

![|525](imgs/Pasted%20image%2020250516173124.png)

下面是功能表：

![|475](imgs/Pasted%20image%2020250516173533.png)

然后是真值表：

![|525](imgs/Pasted%20image%2020250516173558.png)

下面是输出表达式：

$$
\begin{aligned}
{Y} &= D_0 \overline{A_2} \overline{A_1} \overline{A_0} + D_1 \overline{A_2} \overline{A_1} A_0 \\
&+ D_2 \overline{A_2} A_1 \overline{A_0} + D_{3}\overline{A_{2}} A_{1}A_{0} + D_{4}A_{2}\overline{A_{1}}\overline{A_{0}} + D_{5}A_{2}\overline{A_{1}}A_{0}
 \\
 &+ D_{6} A_{2}A_{1}\overline{A_{0}} + D_{7}A_{2}A_{1}A_{0}\\
 & = D_{0}m_{0} + D_{1}m_{1}+D_{2}m_{2}+D_{3}m_{3} + D_{4}m_{4}+D_{5}m_{5}+D_{6}m_{6}+D_{7}m_{7}

\end{aligned}
$$

令数据 $D_0 \sim D_1$ 有些为 $0$ ，有些为 $1$ ，或为其它变量，可构造不同的**逻辑函数**。

#### 数据选择器的扩展 - 双 4 选 1 连接成 8 选 1

将双 4 选 1 数据选择器 74 LS 153 连接成 8 选 1 数据选择器

![|525](imgs/Pasted%20image%2020250516180129.png)

#### 数据选择器的扩展 - 两个 8 选 1 连接成 16 选 1

![|550](imgs/Pasted%20image%2020250516181534.png)

对上面的这个同样按照之前的方法来进行连接，其结果如上图

#### 数据选择器的应用

##### 实现逻辑函数

比如，要实现 $L = \overline{A}B + A\overline{C}$ ，这个是个三变量的

解决方案是将其首先写成**最小项**的形式

其方法就是**缺哪一项，就补哪一项**

$$
L = \overline{A}B + A\overline{C} = \overline{A}B C + \overline{A} B \overline{C} + A B \overline{C} + A \overline{B} \cdot  \overline{C}
$$
得到：

$$
m_{2} + m_{3}+m_{4} +  m_{6}
$$
然后，相应的数据输入端上设置为 $1$ ，没有出现的，设置为 $0$

![|425](imgs/Pasted%20image%2020250831151939.png)

关键是下面这个当有四个变量的时候。再如何逻辑函数的表达。

$$
L = AB\overline{C} + BC\overline{D} + \overline{A}BD + A\overline{B}\cdot \overline{C}
$$

如果还是使用上面的三变量的数据选择器，那么就需要将一个变量利用使能端进行区分。

那么首先就是将其中的一个变量提取出来，实现对使能端的控制。

$$
\begin{aligned}
L &=  AB\overline{C} + BC\overline{D} + \overline{A}BD + A\overline{B}\cdot \overline{C}\\
& = AB\overline{C} + (A  + \overline{A})BC\overline{D} + \overline{A}B(C + \overline{C})\overline{D} + A\overline{B}\cdot \overline{C}\\
& = AB\overline{C}  + \overline{A}BC\overline{D} + \overline{A}BC\overline{D} + \overline{A}BC\overline{D} + \overline{A}B\overline{C}\cdot \overline{D} + A\overline{B}\cdot \overline{C}\\
& = \overline{A}\cdot \overline{B}\cdot \overline{C}\cdot() + \overline{A}\cdot \overline{B}C \cdot() + \overline{A}B\overline{C}\cdot() + \cdots + ABC\cdot()
\end{aligned}
$$
由于是将 $ABC$ 这三个变量当作**最小项**

接下来将上面得到的式子中的括号填好即可。括号内的情况只有四种： $0$ 、 $1$ 、 $D$ 、 $\overline{D}$

举个例子：比如说 $\overline{A}BC\overline{D}$ ，由于原式中有这一项，那么在进行填空的时候，就需要填 $\overline{D}$ ，那么在实际接线的时候，接的就是 $\overline{D}$ 。

> [!note]
> 原理是用最小项的性质：
> 
> 当一个逻辑函数可以写成最小项的形式，那么当输入与其中一个最小项相同的时候，那么输出只能是这个最小项。

相对来说，比较常见的是使用**四选一数据选择器**：

当然，分析方法是不变的，主要还是先将其换成以 $AC$ 为最小项的形式：

![|575](imgs/Pasted%20image%2020250831193029.png)

$$
\begin{aligned}
L &= \overline{A}BC + A\overline{C}\cdot \overline{D} + B\overline{C}D\\
& = \overline{A }BC  + A\overline{C}\cdot \overline{D} + B\overline{C}D\cdot( A + \overline{A})\\
& = \overline{A }BC  + A\overline{C}\cdot \overline{D} + A B\overline{C}D + \overline{A}B\overline{C}D\\
& = \overline{A}\cdot \overline{C}(BD) + \overline{A}C(B) + A\overline{C}(B+\overline{D}) + AC(0)
 \end{aligned}
$$
分析方法其实没有什么本质上的区别。

主要是将其中一部分出现的比较多的部分换成最小项的形式

上面是使用的是 $AC$ ，当然也是可以使用 $BC$ 、 $AD$

还可以使用**卡诺图**的方法来实现。

![|400](imgs/Pasted%20image%2020250831195148.png)

首先将原逻辑表达式画成卡诺图的形式。

然后如果使用 $AB$ 作为最小项。则**每一行**就对应着每一个**数据输入端**

如果使用 $CD$ ，那么**每一列**就对应着一个**数据输入端**

![|475](imgs/Pasted%20image%2020250831200444.png)

当然，还是要按照卡诺图化简的方法将每一行或者每一列**圈出来的**，当然，读取的时候也是按照正常的卡努图来读的。

下面是对应另外一个例子：

以 $AB$ 为数据选择端

![|500](imgs/Pasted%20image%2020250922214214.png)

以 $CD$ 为数据选择端

![|500](imgs/Pasted%20image%2020250901165900.png)

显然以 $CD$ 为数据选择端刚简单一点。

****

当然，也可以使用 $AC$ 作为**数据选择端**（**最小项**）

不利于理解。

![|475](imgs/Pasted%20image%2020250831200826.png)

****

当然，包括 $\overline{AB}$ 、 $\overline{A+B}$ 在内的各种逻辑表达式，都可以使用 4 选 1 数据选择器来实现。

![|325](imgs/Pasted%20image%2020250831201027.png)

##### 将 4 选 1 扩展到 16 选 1

很明显，16 选 1 至少要使用 4 个 4 选 1 来实现。

实际上，普通的要用 5 个 4 选 1 来实现。

![|500](imgs/Pasted%20image%2020250831201423.png)

这里的数据选择端上，低位的四个 4 选 1 的数据选择端用**低位**来连接，高位的哪一个 4 选 1 数据选择端用**高位**来连接，如上面图中所示。

当然，除了上面这种使用 5 个 4 选 1 数据选择器。也可以使用**控制使能端**的方法来实现对输出结果的控制。

还是假设输入的是 $1101$ ，那么 $AB$ 的值是 $11$ ，而 $AB$ 的取值一共有 4 种情况。分别是 $00、01、10、11$ ，那么就可以使用使用一个 2 - 4 的译码器，分别来控制四个 4 选 1 的数据选择器的使能端。同样可以得到相同的结果。

##### 并行输入串行输出

其主要实现的东西是：将一组二进制数，按照想要的顺序（CBA 不同波形组合）输出出去。

> [!important]
> 注意高位、低位的顺序。在这里 $A$ 是高位。 $C$ 是低位

![|425](imgs/Pasted%20image%2020250901163822.png)

这里就是实现了**数据的串行、并行转换**


### 数据分配器

> [!note]
> 根据地址信号的要求，将一路输入数据分配到多路输出中的其中一路作为输出的逻辑电路，称为数据分配器（Demultiplexer），简称为 DMUX

这个刚好跟数据选择器是一个**镜像**（这个是一个输入，四个输出）

![|500](imgs/Pasted%20image%2020250518161304.png)

在上面真值表中，使用的是 $D$ ，而不是 $1$ 或者 $0$ ，原因在于其取值是根据 $D$ 的取值来的。

下面是其集成芯片，但是需要注意的是，数据分配器是**没有相应的芯片**的，而是用功能差不多的**译码器**实现的，将译码器的一些端进行处理一下就得到了**数据选择器

3 线-8 线译码器 74 LS 138 可以构成 1 路- 8 路数据分配器。 $A_2$ 、 $A_1$ ， $A_0$ 为地址信号输入端， $\overline{Y_0 }\sim \overline{Y_7}$ 为数据输出端，三个使能 $\overline{ST_A}$ 、 $\overline{ST_B}$ 、 $\overline{ST_C}$ 中的任一个都可作数据 $D$ 输入端。

而可以得到有两种接法：

下面这个是**第一个**：

![](imgs/Pasted%20image%2020250518162213.png)

然后是**第二个**：

![|425](imgs/Pasted%20image%2020250518162421.png)

### 用中规模集成电路实现组合逻辑函数

主要是用**二进制译码器**实现组合逻辑电路，以及用**数据选择器**实现组合逻辑电路

首先要理解什么是电路实现：

用一个例子来说明：

引例：使用合适的逻辑电路实现函数 $F = AB + BC + AC$ 。

![|475](imgs/Pasted%20image%2020250518162825.png)

首先是**不对逻辑函数进行变换**，其需要用三个与门和一个三输出的或门

那么，如果要对**逻辑函数进行变换**

将原函数进行两次取反，可以得到：

$$
\begin{align*}
Y &= AB + BC + AC\\
& = \overline{\overline{AB + BC + AC}} \\
& = \overline{AB \cdot BC \cdot AC}
\end{align*}

$$
这样得到的输入只需要用到 3 个两输入端与非门，以及 1 个三输入与非门

下面是它的电路实现：

![|500](imgs/Pasted%20image%2020250518172521.png)

当然，除了上面的普通与非门，也可以用**二进制译码器**来实现

所以，问题就在于如何使用这些译码器、数据选择器来实现上面说到的功能

> [!note]
> 如果要选用“**二进制译码器**”或者“**数据选择器**”，其实就是要确定“二进制译码器”或“数据选择器”**输入端**与**待求函数输入信号** $A、B、C$ ，输出端与输出信号 $Y$ 之间的**连接关系**，也就是求之间的**逻辑**


#### 二进制译码器实现组合逻辑函数

> [!note]
> 其本质上是：
> 
> 
> 由于 $n$ 位二进制译码器可提供 $2^{n}$ 个最小项的输出，而任一个逻辑函数都可变换为最小项之和的**标准与或式**，因此利用译码器和门电路可实现单输出及多输出组合逻辑电路。

> [!important]
> 当译码器输出**低电平有效**的时候，选用**与非门**
> 
> 当译码器输出**高电平有效**的时候，选用**或门**

下面是**基本步骤**：

1. 选择集成二进制译码器（不一定是 138）
   
2. 写出待求函数的**标准与非-与非式**（两次取反）

3. 确定待求函数变量和译码器**输入端**之间的关系

4. 选择合适的门电路，画出连线图

下面通过例题来说明如何实现：

![|425](imgs/Pasted%20image%2020250521150317.png)

注意看，上面的这个表达式不是最简单的，其可以换成 $Y = AB + C$

但是我们不需要换，因为在于我们还要**二次取反**，所以并不需要化简。

下面是正式的步骤：

首先，要根据逻辑函数选择**译码器**

很明显，有三个输入，所以要选择 **3 线-8 线译码器**（138）

然后，就是将函数式换成**标准的与或式**

$$

\begin{align}
F &= \overline{A}\overline{B}C + AB\overline{C} + C(\overline{A} + A)(\overline{B} + B) \\
&= \overline{A}\overline{B}C + AB\overline{C} + \overline{A}BC + A\overline{B}C + ABC \\
& = m_1 + m_3 + m_5 + m_6 + m_7
\end{align}
$$

除了上面这种直接写出标准与或式的方法，还可以利用卡诺图来实现：

![|525](imgs/Pasted%20image%2020250521175524.png)

然后进行两次取反，得到**标准的与非表达式**：

$$
\begin{align*}
F &= m_1 + m_3 + m_5 + m_6 + m_7\\
& = \overline{\overline{m_{1}}\cdot \overline{m_{3}}\cdot \overline{m_{5}}\cdot \overline{m_{6}}\cdot \overline{m_{7}}}
\end{align*}
$$
（上面是以 $A、B、C$ 作为**变量** ）

然后是**待求函数变量和译码器输入端之间**的关系：

138 是输出**低电平有效**， $\overline{Y_{i}} = \overline{m_{i}}$ ，（以 $A_{2}、A_{1}、A_{0}$ 作为**变量** ）

回顾一下功能表：

![|550](imgs/Pasted%20image%2020250521175757.png)

我们在上面已经知道了 $F$ 

$$
\begin{align*}
F &= m_1 + m_3 + m_5 + m_6 + m_7\\
& = \overline{\overline{m_{1}}\cdot \overline{m_{3}}\cdot \overline{m_{5}}\cdot \overline{m_{6}}\cdot \overline{m_{7}}}
\end{align*}
$$
**然后令 $A_{2} = A$ ， $A_{1} = B$ ， $A_{0} = C$ ，那么就可以得到**：

$$
F = \overline{ \overline{ Y_{1}}\cdot \overline{Y_{3}}\cdot \overline{Y_{5}}\cdot \overline{Y_{6}}\cdot \overline{Y_{7}}}
$$
这样就找到了 $F$ 跟 $Y$ 之间的关系

而得到的结果中的 $\overline{Y_{1}}、\overline{Y_{3}}、\cdots、\overline{Y_{7}}$ 就是 138 的输出，而最后的结果就是将其**与非**到一起即可。

![|575](imgs/Pasted%20image%2020250521181029.png)

上面的图，就是**最后的连线结果**

再来一个例题：

![|525](imgs/Pasted%20image%2020250521193027.png)

用**卡诺图**写出输出逻辑函数的**最小项表达式**

$$
\begin{cases}
F_1 = \overline{A}\overline{B}C + A\overline{B}C + ABC = m_1 + m_5 + m_7 \\
F_2 = \overline{A}\overline{B}C + \overline{A}BC + A\overline{B}\overline{C} + ABC = m_1 + m_3 + m_4 + m_7 \\
F_3 = \overline{A}\overline{B}\overline{C} + A\overline{B}\overline{C} + AB\overline{C} = m_0 + m_4 + m_6
\end{cases}
$$

然后换成**与非表达式**：

$$

\begin{align*}
\begin{cases}
F_1 = \overline{\overline{m_1} \cdot \overline{m_5} \cdot \overline{m_7}} \\
F_2 = \overline{\overline{m_1} \cdot \overline{m_3} \cdot \overline{m_4}\cdot \overline{m_{7}} }\\
F_3 = \overline{\overline{m_0} \cdot \overline{m_4} \cdot \overline{m_6}}
\end{cases}
\end{align*}
$$
然后则是令 $A_{2} = A$ ， $A_{1}= B$ ， $A_{0} = C$ ，将函数式变换为：

> [!important]
> 这里需要注意，在变换变量的时候，要注意其之间的对应关系，通常是要**反过来取值**的
> 
> 在这里， $A_{2}$ 是高位
> 
> **此处需要额外注意**

$$

\begin{align*}
\begin{cases}
F_1 = \overline{\overline{m_1} \cdot \overline{m_5} \cdot \overline{m_7}}  = \overline{\overline{Y_{1}}\cdot \overline{Y_{2}}\cdot \overline{Y_{7}}}\\
F_2 = \overline{\overline{m_1} \cdot \overline{m_3} \cdot \overline{m_4}\cdot \overline{m_{7}} } = \overline{\overline{Y_{1}}\cdot \overline{Y_{3}}\cdot \overline{Y_{4}}\cdot\overline{Y_{7}}}\\
F_3 = \overline{\overline{m_0} \cdot \overline{m_4} \cdot \overline{m_6}} = \overline{\overline{Y_{0}}\cdot \overline{Y_{4}}\cdot \overline{Y_{6}}}
\end{cases}
\end{align*}
$$
然后就是画出**逻辑图**：

![|475](imgs/Pasted%20image%2020250521194230.png)

再来一个例三：

![|450](imgs/Pasted%20image%2020250521194259.png)

这个跟之前的题目是刚好反过来的。

**解决方法是：**

直接根据设计步骤，使用卡诺图求解：

直接看有几个输出的 $\overline{Y_{i}}$ ，将其对应的 $1$ 写到卡诺图上

观察上面的图中是 $(0,1,2,4,6)$ ，所以在卡诺图上对应的位置上写上 $1$

然后是根据卡诺图来进行化简结果

> [!important]
> 注意，在画卡诺图的时候，不能写反，在 138 上，是 $A_{2}$ 是高位， $A_{0}$ 是低位，相应的在卡诺图上**左边的是高位**，**右边依次是低位**，一定要注意**顺序**

![|525](imgs/Pasted%20image%2020250521203659.png)

#### 数据选择器实现组合逻辑电路

首先来回顾一下，数据选择器的输出是**标准与或式**，其中包含地址变量的**全部最小项**

![|550](imgs/Pasted%20image%2020250522155830.png)

基本步骤：

1. 根据 $n = k-1$ 或 $n = k$ 来确定数据选择器的型号；当然，在这里的 $n$ 是**选择器地址输入端的个数**， $k$ 是**函数的变量个数**。（为什么会有 $n=k-1$ ，是因为这个是一种比较复杂的解决方法，用的是**降维的方法** ）

2. 然后是写出函数的**标准与或式**和选择器的**输出信号表达式**

3. 对这两个表达式进行比较（卡诺图），确定选择器**各个输入变量的表达式**
   （选择器输入端跟待求函数的输入变量之间是如何连接的，以及数据选择器的输出端与待求函数的输出之间的连接关系）

4. 完成之后，根据采用的数据选择器和求出的表达式画出**连线图** 

##### 不降维的解法

下面使用一个比较简单的例题来说明：

![|500](imgs/Pasted%20image%2020250522160726.png)

首先是**代数法来求解**：

![|525](imgs/Pasted%20image%2020250522165131.png)

写出最小项表达式为：

$$
Y = AB + BC + AC = \overline{A}BC + A \overline{B} C + AB\overline{C} + ABC = m_{3}+m_{5}+m_{6}+m_{7}
$$

然后再写出**数据选择器（8 选 1）的输出表达式**，在上图中。

然后将待求函数的表达式与数据选择器的表达式进行比较：

当然，在此之前，需要先令 $A_{2} = A$ ， $A_{1} = B$ ， $A_{0} =C$

可以得到：

$$
\begin{aligned}
Y &= D_{0}\overline{A}\cdot \overline{B}\cdot \overline{C} + D_{1} \overline{A}\cdot \overline{B}\cdot C + D_{2} \overline{A}B\overline{C} + D_{3}\overline{A}BC\\
& + D_{4}A\overline{B}\cdot\overline{C} + D_{5}A\overline{B}C + D_{6}AB\overline{C} + D_{7}ABC
\end{aligned}
$$
通过**对比**可以得到：

![|500](imgs/Pasted%20image%2020250522165836.png)

得到：

$$
\begin{align*}
\begin{cases}
D_0 = D_1 = D_2 = D_4 = 0 \\
D_3 = D_5 = D_6 = D_7 = 1
\end{cases}
\end{align*}
$$
这样就得到了数据选择部分的取值，最后是画图

![|450](imgs/Pasted%20image%2020250522170153.png)

接下来是**用卡诺图来求解**

![|500](imgs/Pasted%20image%2020250522170414.png)

用卡诺图的方法要更简单一些

关键点在于要画对 $F$ 的卡诺图，然后则是 $Y$ 卡诺图的顺序要正确，记住 $A$ 和 $A_{2}$ 都是**高位**即可

然后一一对应就可以得到结果。

****

##### 降维的解法

> [!important]
> 降维是要降掉**最低位**

下面是需要**降维**的使用数据选择器

![|550](imgs/Pasted%20image%2020250522171153.png)

> [!note]
> 其实上就是用 4 选 1（153）来实现三变量的函数表达式。
> 
> 因为 4 选 1 **只有两位地址输入端**
> 
> 也就是 $n = k-1$ 的时候

当然，求解方法其实没有什么很大的不同，关键点在于降维的那部分

依然是写出函数的**标准与或式**：

$$
F = \overline{A}BC + A \overline{B}C + AB\overline{C} + ABC
$$

当然，还有 4 选 1 **数据选择器的表达式**：

$$
Y = D_{0} \overline{A_{1}}\cdot \overline{A_{0}} + D_{1} \overline{A_{1}}A_{0} + D_{2}A_{1}\overline{A_{0}} + D_{3}A_{1}A_{0}
$$
很明显，现在不够用，所以下面的部分就是重点：

要确定**输入变量和地址码之间的关系**：

方法 1 就是**公式拼凑法**

首先要做的是找到对应关系：

令 $A_{1} = A$ ， $A_{0} = B$ ，得到 $Y$ 

$$
Y = D_{0} \overline{A}\cdot \overline{B} + D_{1}\overline{A}B + D_{2}A\overline{B} + D_{3}AB
$$

然后换一下**位置**得到：

$$
Y = \overline{A}\cdot \overline{B}D_{0}+\overline{A}BD_{1}+A\overline{B}D_{2}+ABD_{3}
$$
我们的目的是对应 $Y=F$

可以得到， $D_{0} = 0$ ， $D_{1} =C$ ， $D_{2}=C$ ， $D_{3} = \overline{C} + C =1$


![|550](imgs/Pasted%20image%2020250522180937.png)

然后接下来就是画图：

![|425](imgs/Pasted%20image%2020250522181201.png)

这个方法有一定的局限性，当变量比较多的时候，可能会拼凑错，下面的方法是**图形法**（卡诺图）

方法：

> [!important]
> 先画出待求函数的**降维卡诺图**，再画出相应**数据选择器输出信号的卡诺图**，利用**两者相等**的关系，求出数据选择器**输入变量的表达式**

> [!note]
> 一般将卡诺图的**变量数**称为该图的**维数**，如果把某些变量也作为卡诺图中小方格的值，则会减少卡诺图的维数，这种卡诺图称为“**降维卡诺图**”

下面就是降维的具体操作：

![|525](imgs/Pasted%20image%2020250522182726.png)

当然，上面包含 $C$ 的是包含的原变量，如果当 $C = 0$ ， $F = 1$ ， $C = 1$ ， $F=0$ 的时候，结果就是 $F = \overline{C}$

下面就是来**对比 $F$ 的降维卡诺图和数据选择器输出 $Y$ 的卡诺图**

当然，需要注意的还是 $A = A_{1}$ ， $B = A_{0}$ ，高低位对应

![|550](imgs/Pasted%20image%2020250522183157.png)

除了上面的这种方法，还有更快的方法：

就是“**降维真值表**”的方法

首先就是先将待求函数**转换成最小项之和的形式**

$$
 F = AB + BC + AC = \sum m(3,5,6,7)
$$
![|500](imgs/Pasted%20image%2020250522183746.png)

下面开始列表，根据上面图中所示的表一样。

> [!note]
> 如果**降维变量**在其他变量取值情况**唯一**的时候 （比如 $A = 1、B=0$ 在表中只出现了一次 ），降维变量的取值为 $1$ ，则降维卡诺图中的填降维变量，降维变量的取值为 $0$ ，则填降维变量的**反变量**
> 
> 如果降维变量在其他变量取值情况**不唯一**（不唯一一般为**两次**）的时候（比如 $A = 0、B = 1$ 在表中出现了两次 ），**降维变量**直接为 $1$

> [!note]
> 写出降维真值表之后，紧接着就是画出**降维卡诺图**，如果降维真值表没有出现卡诺图中相应的取值，则直接写 $0$ ，比如在上面的将为真值表中没有出现 $A = 0$ ， $B = 0$ 的情况，则在画降维卡诺图的时候对应位置直接写 $0$

> [!note]
> 得到降维卡诺图之后，则是需要将其与数据选择器的卡诺图进行比较，从而得到最后的连线方式

****

下面用一个变量数比较多的情况来展示：

![|525](imgs/Pasted%20image%2020250522184521.png)

![|525](imgs/Pasted%20image%2020250522185132.png)

然后是对比 151 的卡诺图

![|525](imgs/Pasted%20image%2020250522185357.png)

最后就是画出连线图：

![|525](imgs/Pasted%20image%2020250522185431.png)

# 第五章 - 锁存器和触发器

触发器受**脉冲变化**的控制，这里脉冲的控制，指的就是**上升沿**、**下降沿**
## RS 触发器

### 基本 RS 触发器

![|325](imgs/Pasted%20image%2020250910134915.png)

RS 触发器在**正常**的工作状态下面，两个输出的状态是**互补**的。当 RS 触发器的状态是 $1$ 的时候，代表 $Q = 1$ ，当状态是 $0$ 的时候，代表 $Q = 0$

 > [!note]
 > 补充：对于与门、与非门来说， $0$ 起到决定作用，对于或门、或非门来说， $1$ 起到绝对作用。
 > 
 > 原因在于当与门或者与非门的一端输入为 $0$ 的时候，另外一端的输入不会影响结果。
 > 
 > 同理，对于或门或者或非门的一端输入为 $1$ 的时候，另外一端的输入不会影响结果。
 
 ![|525](imgs/Pasted%20image%2020250910140902.png)

主要需要理解的是当 $R$ 和 $S$ 都为 $1$ 的时候，整个触发器是具有存储功能的，也就是会将上一次的输出再一次输出。

然后最重要的是当 $R$ 和 $S$ 在从 $00$ 跳变到 $11$ 的时候，会出现不确定的状态。（图中斜线部分）

 然后再从它的主要功能分析，主要的就是**清零和置一**。

当 $R$ 端有效（**因为是与非门，所以是 $0$ 有效**）的时候，清零

当 $S$ 端有效（**因为是与非门，所以是 $0$ 有效**）的时候，置一

当两个端口都有效的时候，是**保持不变**

但是，我们要避免出现当两个端口都有效的时候（保持不变状态），将两个端口都跳变成**无效**。这样会导致**结果不定**（注意，只是在发生跳变的时候会出现这种不定的情况，但是如果只是两个输入都是无效的，是按照真值表正常输出的。）

上面的是**低电平**有效，实现的是**与非门**，如果是**高电平**有效，那么实现的是**或非门**。

> [!note]
> 有的时候，题目上给的图即是 $\overline{R}$ 和 $\overline{S}$ ，又在输入的前面加了一个圆圈代表**非**。
> 
> 主要，这里不是**抵消**的意思，无论是一个非，还是两个非，意思都是**低电平**有效。而不是抵消，硬要说的话，可以认为是这两个部分进行相**或**。
> 
> 一个非就是非，两个非也是非，只有都不是非才是真。

下面实现的就是或非门。逻辑和与非门是相反的：

![|525](imgs/Pasted%20image%2020250910152402.png)

### 同步 RS 触发器

同步 RS 触发器主要解决的问题是在基本 RS 触发器中，当 $RS$ 从 $01$ 变化成 $10$ 的时候，实际上不能做到完全同步的变化，在变化中间就会出现问题，会有一瞬间导致 $RS$ 出现 $00$ 的情况，这样就会出现问题。

![|575](imgs/Pasted%20image%2020250910153040.png)

为了避免基本 RS 触发器出现的问题，实现的方法主要是利用前面的时钟脉冲 $CP$ 。

当 $CP= 0$ 的时候，无论， $RS$ 的输入是什么，它都是保持状态不变。

只有当 $CP =1$ 的时候，才会按照真值表来分析。

![|550](imgs/Pasted%20image%2020250910153818.png)

实现的真值表在下面图中所示：

![|550](imgs/Pasted%20image%2020250910160919.png)

注意，上面的真值一定是当 $CP = 1$ 的时候，才能实现，如果 $CP=0$ ，那么功能是保持不变的，上面的这个真值表是无效的。

其中，我们通过分析真值表，可以得到：

$$
Q^{n+1} = S+\overline{R}Q^{n}
$$

当然，约束条件是：

$$
RS = 0
$$
也就是 $RS$ 不能同时为 $1$ （**同时有效**） （注意，在这里是**高电平有效**）

然后，如果我们将输出再接回输入：

![|550](imgs/Pasted%20image%2020250910154254.png)

**理论上**会出现来一次 $CP$ 脉冲出现一次反转的情况。但实际上是，因为当 $cp$ 为 $1$ 的时候，就会出现来回反复反转（多次反转）的情况。而不是保持不变。这种情况称之为**空翻现象**（草！走！忽略！ጿ ኈ ቼ ዽ ጿ）

### 主从 RS 触发器

主从 RS 触发器，顾名思义，肯定是由两个触发器组成。具体接法如下所示。

![|500](imgs/Pasted%20image%2020250910162056.png)

> [!important]
> 主从触发器一定是在**下降沿**的时候才进行激活功能。

这种结构就避免了空翻现象。

下面进行分析：

![|400](imgs/Pasted%20image%2020250910165230.png)

如果是将主从 RS 触发器的输出再接到输入上，那么它的输出 $Q$ 只有在 $CP$ 脉冲的**下降沿**的时候才会反转一次。

![|525](imgs/Pasted%20image%2020250910165519.png)

但是，无论是上面的那种 RS 触发器，总有一种情况是不被允许的。

低电平有效的，不允许 $RS = 00$，高电平有效的，不允许 $RS = 11$

## 主从 JK 触发器

本质上，对于 RS 触发器的输入是可以不只一个输入的，可以有多个输入。利用这个设计，以及为了解决上面 RS 触发器的问题，在主从 RS 触发器的基础上利用两个 $R$ 两个 $S$ 的输入，组成 $JK$ 触发器：

![|550](imgs/Pasted%20image%2020250910170834.png)

可以看到它是在主从 $RS$ 触发器的基础上再添加了两个额外的 $RS$ 输入，在这里叫做 $JK$ 。

> [!note]
> 这里的分析不是很难，但是比较麻烦。后续如果有需要再来分析。

关键在于记住这个主从 JK 触发器的真值表：

> [!important]
> 记忆口诀：
> 
> 
> $00$ 不变， $11$ 反转， $01$ 、 $10$ 与 $J$ 相同

下面根据真值表，分析出它的特征方程：

![|550](imgs/Pasted%20image%2020250910171429.png)

特征方程：

$$
Q^{ n + 1} = J \cdot \overline{Q^{n}} + \overline{K} Q^{n}
$$
核心就是记住口诀，下面是一个例子：

![|525](imgs/Pasted%20image%2020250910171901.png)

> [!important]
> 注意，是 $CP$ 脉冲的**上升沿决定，下降沿翻**。
> 
> 意思是，尽管要在下降沿的时候翻转，但是怎么翻，或者不翻，都要看上升沿发生的时候，$JK$ 的状态如何

此外，当 $JK$ 触发器的 $J$ 端和 $K$ 端都输入 $1$ 那么就形成**计数式触发器**。意味着，只要有一次脉冲就发生一次**翻转**

![|400](imgs/Pasted%20image%2020250911150340.png)

> [!important]
> 注意，上面的波形分析是基于在 $CP = 1$ 期间， $JK$ 没有发生跳变。如果发生跳变，结果会出现一点点不一样。

*后面会补充会发生什么*

> [!note]
> 当 $JK$ 在 $CP = 1$ 的过程中发生跳变的时候，中间的 $Q^{\prime}$ 至多会发生变化一次，并不会随着 $JK$ 的跳变进行变化

接下来就分析，当 $CP =1$ 的时候谁会影响。

当一开始 $Q = 0$ 的时候， $R = Q = 0$ ， $S  = \overline{Q}= 1$ 。而 $R$ 和 $K$ 是**与**在一次的，所以这个时候因为 $0$ 的优先级高，所以 $K$ 发生跳变是不会影响结果的。

那么当 $J$ 变成 $1$ 的时候（发生跳变），此时内部的 $Q^{\prime}$ 会发生变换，变成 $1$ ，但是这个时候第二个 $RS$ 的输出会有一个延迟。不会发生改变。

但是如果 $J$ 又变回去（从 $1$ 变回 $0$ ），那么这个时候 $Q^{\prime}$ 却不会发生变换。原因在于 $Q^{\prime}$ 想要从 $1$ 变成 $0$ ，需要 $R = 1$ ，但是这个时候由于 $Q$ 没有变换还是 $0$ ，进而 $R = 0$ 。

解释看真值表：

![|475](imgs/Pasted%20image%2020250911163542.png)

而 $Q = 1$ 的时候，同理解释。

下面是例题以及总结：

![|500](imgs/Pasted%20image%2020250911164643.png)

> [!note]
> 当 $Q = 0$ 的时候， $J$ 有上升沿（正脉冲），发生一次变化（翻转）
> 
> 当 $Q = 1$ 的时候， $K$ 有上升沿（正脉冲），发生一次变化（翻转）
> 
> **上升沿**必须优于（早于）**下降沿**才会导致结果翻转，如果下降沿先发生（在同一个 $CP =1$ 期间 ）那么是不会发生翻转的。

在上面图中的第三次 $CP= 1$ 的时候，其翻转的原因是正常的 $JK = 01$ ，置 $0$ 。而不是因为 $J$ **跳变**或者 $K$  **负脉冲**

再来一个例题：

![|625](imgs/Pasted%20image%2020250912132016.png)

## 边沿触发器

下图是分别是 $D$ 触发器和 $JK$ 触发器的**状态图**和**激励表**。

![|550](imgs/Pasted%20image%2020250911144136.png)

### 边沿 JK 触发器

由于 $JK$ 触发器在 $CP=1$ 的过程中，输入不能发生变化，所以使用边沿触发器来避免这个问题。 

> [!note]
> 在一些题目中，需要注意符号问题，当 $CP$ 端有圆圈的是**下降沿**（后沿），没有圆圈是**上升沿**（前沿）
> 
> 边沿 $JK$ 触发器与主从 $JK$ 触发器稍微有一点不一样，边沿 $JK$ 触发器中没有“上升沿触发，下降沿翻”，唯一要看的就是有没有圆圈，因为这才绝对着实在上升沿起作用，还是在下降沿起作用。

![|525](imgs/Pasted%20image%2020250911141431.png)

对于边沿 $JK$ 触发器。如果将 $\overline{Q}$ 的输出接入 $J$ ，那么也会实现**计数式触发器**的效果

![|550](imgs/Pasted%20image%2020250911151155.png)

之前对于初始条件，一般是将其做为 $0$ 来处理，但是在实际的使用中，一般需要将其设置为 $0$ ，那么就出现了下面这个**异步清 $0$ 端**。（可以认为是强制清 $0$ ）

![|550](imgs/Pasted%20image%2020250911144911.png)

注意看，在图中，依然是**低电平有效**，所以在使用中，除了要强制清 $0$ 或者强制置 $1$ 的时候，其他时间一般都要将其设置 $\overline{R_{d}}$ 和 $\overline{S_{d}}$ 为 $1$ （也就是不工作状态）

此外，因为是低电平有效，所以它还是在**下降沿触发**。此外还要注意的是，由于平时都是 $1$ ，所以下降沿触发是在**前面**

> [!note]
> 当然，有异步就有同步，同步是要和 $CP$ 端进行配合，进行同步处理。

举个例子来说明：

![|575](imgs/Pasted%20image%2020250911151813.png)

> [!note]
> 如果出现下降沿和 $J$ 或者 $k$ 变换正好在同一瞬间，如同上面图中所示。
> 
>  那么这个时候，我们一般认为它是按照前一瞬间（在这里是 $0^{-}$ ，有极限的感觉）来判断

一道例题：

![|550](imgs/Pasted%20image%2020250912132257.png)

### 边沿 D 触发器

![|575](imgs/Pasted%20image%2020250911141648.png)

D 触发器的功能还是比较简单的，首先是看是**上升沿触发**还是**下降沿触发**，主要是看**输入处**有没有**圆圈**。

其功能表现为与 $D$ 的输入**相同**，特征方程为：

$$
Q^{n+ 1} = D
$$

来一个列题：

![|575](imgs/Pasted%20image%2020250912132807.png)

> [!note]
> 这里需要注意的是：在 $D$ 触发器上，如果输入的 $D$ 在发生变化的时候刚好与 $CP$ 脉冲的边沿（起作用的脉冲边沿）重合，那么我们一般认为去 $0^{-}$ ，也就是**前一时刻**的 $D$ 作为**这一时刻**的输出
> 
> 如上面图中的第四个 $CP$ 脉冲的上升沿。

此外， $D$ 触发器也是可以形成**计数式触发器**：将 $D$ 端与 $\overline{Q}$ 相连就能形成**计数式触发器**：

![|500](imgs/Pasted%20image%2020250911150024.png)

那如果 $D$ 端再加上一个 $A$ ，那么结果可能有所不同：

![|475](imgs/Pasted%20image%2020250911150719.png)

这个时候的输入要看 $A$ 和 $\overline{Q}$ 结合的结果。

> [!note]
> 如果没有特别说明，那么这类一个端口上有两个甚至多个输入的情况，认为是**相与**

两个 $D$ 触发器相连的相关例子：

![|525](imgs/Pasted%20image%2020250911153157.png)

下面进行解释：

![|475](imgs/Pasted%20image%2020250911155627.png)

这里的核心问题是 $Q_{1}$ 在形成 $Q_{2}$ ，进而形成 $\overline{S_{d}}$ 之后，在对第一个 $D$ 触发器形成影响是要经过一个触发器的，这时候就会出现**延时问题**。

对于第一个触发器来说，由于脉冲来的时间是一样的，所以它是直接受到与之相连几个端口的影响的，而它的输出将会再经过一个触发器才会反过来作用到它本身上。这个时候就会出现**延时问题**

再来一个类似例子：

这个例子是**同步**

> [!tips]
> 
> 都是上升沿或者下降沿触发就叫做同步，异步则相反：一个上升沿触发，一个下降沿触发。

![|475](imgs/Pasted%20image%2020250912134250.png)

主要是 $D$ 触发器的非门输出与其输入相连接，就实现了 $T^{\prime}$ 触发器的功能：只要遇到 $CP$ 脉冲的上升沿（**有效的沿**）就会翻转一次。

## T 触发器和 T 撇触发器

$T$ 触发器的主要功能是将输入**翻转**。

![|550](imgs/Pasted%20image%2020250911142111.png)

其特征方程为：

$$
\begin{aligned}
Q^{n+ 1} &= \overline{T}Q^{n} + T \overline{Q^{n}}\\
& = T \oplus Q^{n}
\end{aligned}
$$
$T$ 触发器也叫做**可控的计数式触发器** 

而 $T^{\prime}$ 触发器的特征方程是：

$$
Q^{n+1} = \overline{Q^{n}}
$$
意思就是，只要是来一个**脉冲**，就发生一次**翻转**

$T^{\prime}$ 可以由 $D$ 触发器改装而来：

![|375](imgs/Pasted%20image%2020250912133924.png)

# 第六章 - 时序逻辑电路

## 引言与例题分析

在时序逻辑电路中，应当都具备有下面三个方程：

$$
输出方程：O = f_{1}(I,S)
$$
$$
激励方程：E = f_{2}(I,S)
$$
$$
状态方程：S^{n+1} = f_{3}(E,S^{n})
$$
从大的角度来说，时序逻辑电路分成：**同步**时序逻辑电路和**异步**时序逻辑电路

同步，意味着多个触发器的 $CP$ 都是由一个 $CP$ 总线控制的。

异步，相对比较复杂，除了考虑状态变换之外还需要考虑 $CP$ 脉冲的位置。

![|550](imgs/Pasted%20image%2020250913153413.png)

下面来分析一个时序逻辑电路：

![|600](imgs/Pasted%20image%2020250913154120.png)

上图中列出来的方程就是全部的方程。

下面根据方程，画出真值表：

![|275](imgs/Pasted%20image%2020250913154216.png)

而**状态表**或者是**状态图**也都是根据真值表得到的：

![|550](imgs/Pasted%20image%2020250913154743.png)

状态表要注意的是，里面的内容代表的是下一时刻的状态，下划线是对应的输出是什么。

换句话说，就是现在的状态由输入和前一时刻的状态决定。现在状态的输出同理。

**状态图**：

![|375](imgs/Pasted%20image%2020250913155721.png)

对于状态图，无论是对照真值表还是状态表，都是可以得到的。

> [!note]
> 圆圈内代表的是状态。箭头则是代表从当前的状态变化到下一个状态，在变化的过程中，斜线上面的代表的是**输入**，而斜线下面的代表的是**输出**。

**时序图**：

![|450](imgs/Pasted%20image%2020250913161540.png)

> [!important]
> 这里需要注意的是， $Z$ 也就是输出与前一时刻没有关系，也与 $CP$ 脉冲没有关系
> 
> 原因在于这里的输出是将输入与两个输出**与**到一起的，并不属于时序的范围内。

## 时序逻辑电路的分析

### 同步时序逻辑电路的分析

#### 一般步骤与例题

时序电路的分析是从图得到其功能如何。

> [!note]
> 一般步骤：
> 
> 1. 列方程组（3 个）
> 
> 2. 列状态表（功能表），画状态图
> 
> 3. 功能的说明（该电路的逻辑功能）

下面以一个例子来分析：

![|525](imgs/Pasted%20image%2020250913163405.png)

首先是将每一步的方程都写出来，包括每一个层级的输出。

写出方程之后，根据方程表达式画出真值表。

再根据真值表，将状态表画出：

![|525](imgs/Pasted%20image%2020250913162840.png)

最后根据状态表将状态图画出来。

> [!note]
> 对于一个**状态**来讲，有几个输入无所谓，但只能有**两个输出**

![|525](imgs/Pasted%20image%2020250913165432.png)

如果需要的话，还可以画一下**时序图**：

对于任意的输入 $A$ ：

根据状态表、状态图可以得到时序图：

![|525](imgs/Pasted%20image%2020250913165729.png)

最后，就是说明这个实现的功能是什么

只要讲得通，找到它的规律就可以。可以通过观察**状态图**：

当输入为 $0$ 的时候，维持状态不变。

当输出为 $1$ 的时候，由本位状态加一得到下一状态。并且以 4 为循环

**再来一个例子**：

![|550](imgs/Pasted%20image%2020250914151737.png)

思路是一样的，依然是先写出特征方程。

然后根据特征方程将真值表画出来。

再根据真值表将状态表画出来。

> [!note]
> 由于这个输出与状态转换（不严谨，理解意思即可）没有关系，所以在画状态表的时候，习惯上将输出 $Z$ 单独一列

最后是将状态图画出来。

![|525](imgs/Pasted%20image%2020250914152633.png)

在画状态图的时候，依然是因为输出只与连个触发器的状态有关，与转换没有直接关联。

所以可以直接在每个状态下面写上输出是什么。

最后如果有需要可以再写出时序图。

> [!note]
> 最后说明它的功能：受 $A$ 控制的**可加可减**电路。

#### 用触发器实现计数器

> [!important]
> *状态转换真值表*对于**同步**的电路分析来说比较好，如果是异步的，不是很合适

用一个例题来说明：

首先在思路上，是与之前的几乎一样。

![|550](imgs/Pasted%20image%2020250914153824.png)

先将方程写出来，包括输入和输出方程。

然后是写出真值表。（注意，这里**没有输入**，完全是由 $CP$ **脉冲控制** ）

就可以发现，它是从 $000$ 依次进一的。而到了 $100$ ，则又回到了 $000$ 。可以得到这是一个五进制计数器（**注意，不一定是依次进一的，只要是五个一循环就叫做五进制计数器**）。

而对于剩下的三个状态，因为输入的时候是有可能处于剩下的三个状态中，如果这三个状态可以恢复到**五进制**的循环当中，那么就称之为**无挂起**，反之，如果有某个状态的下一个状态还是它自己，那么就导致了**挂起**状态。

上面这个就叫做**无挂起同步五进制计数器**

下面再用一个例题来说明更简单的计算方法。

当然首先要做的还是写出输入方程等**特征方程**。

![|575](imgs/Pasted%20image%2020250914162432.png)

在写出特征方程之后，就要进行分析。

而在这里，就不再用之前的那种分析方法了，而是用：**状态转换真值表**

这个表的关键在于其中包括前一时刻的输入，直接按照 BCD 码的形式写下来即可。

然后是每个触发器的输入，分别是 $J_{1}K_{1}$ ， $J_{2}K_{2}$ 、 $J_{3}K_{3}$

最后面是要计算得到的 $Q_{1}^{n+1}$ 、 $Q_{2}^{n+1}$ 、 $Q_{3}^{n+1}$ 

其中的 $J_{1}K_{1}$ ， $J_{2}K_{2}$ 、 $J_{3}K_{3}$ 利用已经写出来的方程直接计算得到。

> [!note]
> 注意，在这里默认 $Q_{3}$ 为**最高位**

而接下来的分析，则是直接画出**状态转换图**：

![|550](imgs/Pasted%20image%2020250914163255.png)

进而得到功能

如果再加一个输出，也是没问题的：

![|600](imgs/Pasted%20image%2020250914163513.png)

> [!note]
> 当出现**挂起**状态的时候。
> 
> 解决方法有两个，一个是**置初始值**。
> 
> 另外一个则是使用**修正电路**（后面会讲的）

### 异步时序逻辑电路的分析

> [!note]
> 步时序逻辑电路的分析一般来说不能使用同步中使用的**状态转换真值表**。
> 
> 但是也不是绝对的，我们需要考虑是否有反馈，一般来说，如果没有反馈，那么是可以逐步分析触发器。
> 
> 当异步的部分，没有反馈线到前面的部分，那么可以将前面那部分当作同步的来分析，最后再来分析异步的部分。

依然是用例子来说明：

![|500](imgs/Pasted%20image%2020250914165214.png)

在这个电路中，前面两个触发器就组成了一个同步电路，最后面的哪个触发器才会结合成异步。而这个异步的并没有反馈给前面的触发器，这样就可以分两部分来分析。

> [!note]
> 个人感觉不如使用脉冲线的方法来分析来的直观，这样直接分析比较容易出错。

对于 $Q_{2}$ 来说，要注意的是：由于它被 $Q_{1}$ 控制 $CP$ 端。且是**下降沿**触发。所以只有在 $Q_{1}$ 在从 $1$ 跳变到 $0$ 的时候才会发生触发。

下面画状态图：

![|575](imgs/Pasted%20image%2020250914171228.png)

注意，在分析完循环的状态之后，还需要分析以下没有出现的状态的情况，会不会回到循环里面。

综上所述，可以得到上面这个是一个**无挂起异步六进制计数器**

再来一个例子说明：

![|550](imgs/Pasted%20image%2020250914181521.png)

这里的关键点在于 $Q_{1}$ 是受到 $Q_{0}$ 的下降沿控制的。也就是当 $Q_{0}$ 从 $1$ 变成 $0$ 的时候，就会触发变化。

下面画出状态图：

![|550](imgs/Pasted%20image%2020250914182739.png)

##  同步时序逻辑电路的设计

理论上说，只要是能描述出来的问题都可以用时序逻辑电路来实现。

### 一般步骤

一般步骤：

1. 根据一般问题描述，得到原始的状态图（状态表）**重中之重**
2. 状态化简（等效的，合二为一）
3. 状态分配
4. 选触发器（ $D$ 、 $JK$ ）
5. 确定激励方程组和输出方程组 （求解 $J_{1}$ 、 $k_{1}$ 等）
6. 画图以及确定能否自启动（如果挂起如何修复）

### 序列检测器

序列检测器要实现的是对于输入进来的一组序列，当出现要检测到的 $1001$ （任意的），当满足此序列，就输出为 $1$ ，否则输出为 $0$ 。当然，有可能会出现下面图中的：出现**重叠**的情况，这种需要额外确定，**是否可以重叠**。

![|525](imgs/Pasted%20image%2020250915153231.png)

下面用一个例子来说明：

设计一个检测 $1001$ 序列**可重迭**的电路：

对于这种**序列检测电路**，针对一开始的**初始状态**，一般设置为**要检测序列的第一位元素的相反状态**。

![|500](imgs/Pasted%20image%2020250915153914.png)

注意，对于每一个现有状态来说，存在两种情况，一种是输入为 $0$ ，一种是输入为 $1$ 。这意味着对于每个状态都只有**两条输出**：

![|550](imgs/Pasted%20image%2020250915154506.png)

![|550](imgs/Pasted%20image%2020250915155359.png)

状态图和状态表如上所示。

> [!note]
> **这里之所以是四个状态，原因在于它要检测的有四位，也就是至少要有四个状态**。
> 
> 而对于每一个现在的状态，对于不同的输出要做出不同的反应。、
> 
> 一般来说，当在现在的状态下面，如果输入了一个对检测序列有用的，那么就需要转向下一个状态。
> 
> 反过来，如果输入了一个打破检测序列的，那么就需要考虑到多层输入。
> 
> 比如说，在这里要检测 $1001$ ，如果输出一个 $11111101001$ ，那么对于 $1$ 这个状态来说，下一个输入如果还是 $1$ ，那么就需要在自身这个状态这里循环，如果来的是 $0$ ，就需要跳到下一个状态。
> 
> 如果现在的状态是 $0$ ，那么对于再输入为 $0$ 的，它满足跳转到下一个序列。而对于再输入一个 $1$ 的。就需要回到 $B$ 了。避免出现 $0111$ 这类的情况。

> [!important]
> 这里存在的问题是，对于 $C$ 这个状态，当输入为 $0$ 的时候，为什么要跳转到 $D$ 。
> 
> 原因在于当输入为 $01001$ 的时候，如果是遇到输入为 $0$ 反馈给本身，那么对于另外一种情况：输入为 $1$ 来说，就无法判断输出为 $1$ 还是输出为 $0$ ，因为当序列的第一个为 $0$ ，第二个为 $1$ 的时候，对于输入 $1$ 来说应该是输出为 $0$ ，但是如果已经输入了 $0100$ ，最后一个输入为 $1$ 的时候，这时候的输出应该为 $1$ ，自相矛盾。

下面就是需要分析可不可以进行化简的问题。

> [!note]
> 如果表中的状态存在两部分的效果是一样的。那么就可以化简。

很明显，在这里是不需要化简的。

然后是进行**状态分配**

理论上来说， $ABCD$ 是随便放的。

而如何才算是**好**呢？

有三个原则：

1. 输出完全相同，现态**相邻**（ABC 两两相邻，在这里是矛盾的）
2. 同一个现态，次态**相邻**（对于 $A$ 来说，它的两个次态要相邻）
3. 次态相同，现态**相邻**（在这里只有 $AD$ 的一个次态都是 $A$ ）

![|500](imgs/Pasted%20image%2020250915163311.png)

分配之后，所有 $A$ 都是 $00$ ，所有 $B$ 都是 $01$ ，所有 $C$ 都是 $11$ ，所有 $D$ 都是 $10$

然后是根据分配的结果，得到**二进制化的状态表**：

![|575](imgs/Pasted%20image%2020250915163926.png)

接下来是将其对于每一个输出项： $Q_{1}^{n+1}$ 、 $Q_{2}^{n+1}$ 、 $Z$

将他们的**卡诺图**画出来。

> [!important]
> 注意，卡诺图的变量分配顺序是按照 BCD 码的顺序来分配的： $00$ 、 $01$ 、 $11$ 、 $10$ 。
> 
> 这也就意味着，我们在提取变量的时候，必须按照卡诺图的格式来提取。
> 
> 在这里，刚好 $C$ 是 $11$ ，不需要变换顺序。
> 
> 而如果 $D$ 是 $11$ ，$C$ 是 $10$，那么需要手动在后面将他们两个的顺序进行颠倒。 
> 
> 目的就是为了要得到卡诺图的状态。


![|575](imgs/Pasted%20image%2020250915164610.png)

得到卡诺图之后的，就是参照 $JK$ 触发器的特征方程：

$$
Q^{n+1} = J\overline{Q^{n}} + \overline{K}Q^{n}
$$
将每一个的特征方程的出来：

> [!note]
> **注意，在这里进行的不是卡诺图的化简，而是要在凑形式**

![|575](imgs/Pasted%20image%2020250915165237.png)

最后就是将触发器的图画出来：

![|625](imgs/Pasted%20image%2020250915165658.png)

### 任意进制计数器

下面以五进制计数器为例子来说明：

这五个状态如果题目没有说，那就是随机的，五进制的意思是有五个状态再进行循环，并非是从 0 加到 4.

而第一步是将真值表画出来。

![|350](imgs/Pasted%20image%2020250917140327.png)

然后是用卡诺图来化简。

注意题目是用 $JK$ 还是 $D$ 触发器。

![|600](imgs/Pasted%20image%2020250917140801.png)

如果题目中没有提到无关状态是否会**自启**，或者**挂起**，那么一般设为 $d$ 来处理。

> [!note]
> 注意，这里必须要进行分析**多余状态**。
> 
> 一种方法是将多余的状态直接代入到特征方程中，进而得到是否能进入到循环中。
> 
> 如果是用卡诺图的方法来判断，那么就之间观察这个输入对应的卡诺图上的位置是什么，如果这个值被圈起来了，代表是 $1$，如果没有被圈起来就是代表为 $0$
> 
> 所以在这里 $000$ 的次态是 $011$

![|500](imgs/Pasted%20image%2020250917142614.png)

而 $010$ 的次态输出为 $111$ ， $100$ 的次态输出为 $111$ 。也就是都是自启的，没有挂起状态。

最后就是画图即可。将 JK 触发器连接起来。

### 挂起的修复

如果分析出来，存在挂起的状态，那么在设计的过程中还需要进行修复。

下面还是以一个例子来分析：

![|550](imgs/Pasted%20image%2020250917143331.png)

首先在得到电路图之后，要先把特征方程写出来。

然后利用特征方程，再将**状态转换真值表**列出来。

然后是状态转换关系表、关系图：

![|575](imgs/Pasted%20image%2020250917143618.png)

然后可以发现出现了挂起问题。

> [!note]
> 解决方法则是将其中一个状态的**次态**变成**循环**中的任意一个状态即可。
> 
> 例如将 $100$ 的次态由原来的 $111$ 换成 $110$

![|525](imgs/Pasted%20image%2020250917144908.png)

因为改变的是 $Q_{0}^{n+1}$ 在 $Q_{2}Q_{1}Q_{0}$ 在 $100$ 状态下的值，所以如果要进行改变，可以使用卡诺图的方法来改变。

![|350](imgs/Pasted%20image%2020250917145017.png)

然后再按照改变之后 $J$ 和 $\overline{K}$ 将电路进行修改即可修正**挂起状态**

### 状态化简

状态化简主要解决的问题是将电路中可能出现相同作用的部分统一起来，减少元器件的使用。

#### 等价状态

> [!note]
> 等价状态，这里指的是**现态相等**，如果满足下面的条件，则可以得到现态相等
> 
> 有两个条件：
> 
> 1. 输出完全相同
> 
> 2. 次态等效

首先是**输出完全相同**，这部分比较起来还是比较简单的。只需要看最后的结果即可。

然后是**次态等效**，这里又分成好几种情况：

第一种是**次态相同**，或者各自**维持原状**。

![|400](imgs/Pasted%20image%2020250918153501.png)

> [!note]
> 维持原状的意思本质上是次电路实现的公式是一样：就是保持输出不变。

第二种是**次态交错**：

![|350](imgs/Pasted%20image%2020250918153131.png)

第三种是**次态循环**

![|525](imgs/Pasted%20image%2020250918153914.png)

更复杂一点是：

![|475](imgs/Pasted%20image%2020250918153955.png)

$A$ 、 $B$ 是否等效取决于 $C$ 、 $D$ 

$C$ 、 $D$ 是否等效取决于 $E$ 、 $F$ 

$E$ 、 $F$ 是否等效又反过来取决于 $A$ 、 $B$

这就构成了**循环次态**。

但是，如果最后面的 $E$ 、 $F$ 之间如果不是**等效**的，那么前面的所有都不是等效的了。

![|425](imgs/Pasted%20image%2020250918154355.png) \

#### 等价特性

##### 传递性

$$
(A,B),(B,C) \rightarrow (A,C)
$$
$A$ 、 $B$ 等效， $B$ 、 $C$ 等效，那么可以推断出 $A$ 、 $C$ **等效**。

##### 等价类

等价类是**等价状态的集合**

比如上面的 $A$ 、 $B$ 等效， $B$ 、 $C$ 等效，那么可以推断出 $A$ 、 $C$ **等效**，那么可以认为是两两等效。

用集合的形式表示就是： $(A,B,C)$

当然如果 $D$ 是单独的一个，也就是**没有等效**的，也是一个集合： $(D)$

##### 最大等价类

最大等价类就是我们最后要找的目标。

例如： $(A,B,C)(D,E)(F)(G)$ ，这就是四个**等价类**。他们就构成了**最大等价类**。

$$
(A,B,C)(D,E)(F)(G) \Rightarrow A^{\prime}B^{\prime}C^{\prime}D^{\prime}
$$


#### 例子

下面这个例子是比较简单，可以直接看出来。

![](imgs/Pasted%20image%2020250918155523.png)

第二种方法是针对比较复杂的情况：使用的方法是**隐含表法**

#### 隐含表法

> [!note]
> 方法叫做：**取“头”少“尾”**

列一个表，形如：

![|375](imgs/Pasted%20image%2020250918155906.png)

方法是：

1. 做表
2. 顺序比较
3. 关联比较
4. 写出最大等价位

下面用一个例子来说明：

![|600](imgs/Pasted%20image%2020250918160615.png)

到上面这个表这一步已经完成了前两步，接下来是后面两步：

![|600](imgs/Pasted%20image%2020250918161058.png)

先将上面表中需要进行判断的判断出来。

然后是利用**传递性**将**最大等价类**求出来

得到最大等价类是：

$$
(ADF)(BE)(CG)
$$

然后在用得到的这三个最大等价类画一个新的状态表。

![|475](imgs/Pasted%20image%2020250918161857.png)

> [!note]
> 还是要对着原来的表将最大等价类的表画出来。
> 
> 注意替换问题：
> 
> 以 $s_{0}$ 为例。现在的 $s_{0}$ 由 $ADF$ 组成，所以输出就是 $ADF$ 中任意一个的输出。
> 
> **次态**则也是由 $ADF$ 决定。原来 $A$ 的次态是还是 $A$ ，而 $A$ 属于 $s_{0}$ ，所以 $s_{0}$ 的次态就是 $s_{0}$
> 
> 只需要理解他们都是**等价状态**（次态和输出都是一样的）即可

再来一个例子：

![|625](imgs/Pasted%20image%2020250918162654.png)

然后就是画出改进后的状态图。

### 设计中 Mealy 型和 Moore 型的区别

常见的输出与变化有关的是 $Mealy$ 型，它的输出受到脉冲的调控。

而 $Moore$ 型，则只与状态有关。

所以在画图的时候， $Moore$ 型的状态会比 $Mealy$ 型的多一些。此外 $Moore$ 型的输出标在每个**状态**的下面。如下图：

![|600](imgs/Pasted%20image%2020250918164040.png)

> [!note]
> 注意，在这里的，这两种形式的区别还是比较大的。
> 
> 因为 $Moore$ 型，因为有 $5$ 个状态，所以需要 $3$ 个触发器。
> 
> 而 $Mealy$ 型只需要 $2$ 个即可。

当然也要**具体情况具体分析**

## 异步时序电路的设计

> [!important]
> 这部分不算是重点

流程上还是一样，依然是先画出**状态转换图**或者**状态转换表**。

而在过程上，用触发器的激励表来显示比较合适。

![|170](imgs/Pasted%20image%2020250921171434.png)

> [!note]
> 而在过程中，我们发现，在进行状态转换的时候，我们将其中一部分的触发器的 $JK$ 都设置为 $1$ ，那么意味着，只要来一个 $CP$ 脉冲，就会在原来输出的基础上进行翻转。那么可以设计电路去控制 $CP$ ，但是最少要有一个触发器的 $CP$ 是受外部控制的，这样才能构成**异步触发器**

下面用例子来说明：

首先是高位的触发器。

![|600](imgs/Pasted%20image%2020250921172052.png)

由于这里依然是按照有外部 $CP$ 的方法来进行判断。所以依据的是 $JK$ 触发器的**激励表**

从 $Q_{0}^{n}$ 到 $Q_{0}^{n+1}$ ， $JK$ 分别为 $0$ 和 $d$ （无关项）

![|600](imgs/Pasted%20image%2020250921172407.png)

这一部分，完全是按照同步时序逻辑电路的设计方法来实现的。

下面则是来设计 $CP_{1}$ 和 $CP_{2}$ 控制这两部分脉冲的电路。

这部分的电路设计的主要依据是当有 $CP$ 脉冲的时候，才会发生跳变。

![|600](imgs/Pasted%20image%2020250921174315.png)

> [!important]
> 总体的设计思路就是令其中的至少一个为同步时序逻辑电路设计。
> 
> 其他的触发器让 $JK$ 保持为 $1$ ，用 $CP$ 以及根据它的状态转换表实现控制 $CP$ 实现状态转换。

这里发现对于 $CP$ 的门电路设计过于复杂。那么可以适当的对 $JK$ 也进行控制，不再一直保持 $1$ 。那么在这样的情况下，就需要结合 $CP$ 的真值表和 $J$ 、 $K$ 的真值表来一起分析。

首先是无关项，这个直接先写上，然后是分析 $CP$ 脉冲的真值表，因为我们现在是要化简，所以根据之前得到真值表，其中一部分状态下 $CP$ 是等于 $0$ 的。所以这个时候 $J$ 、 $K$ 是无关项。

然后是分析当 $CP = 1$ 的时候，会发生变化，这个时候就要对 $JK$ 进行重新设计，设计的过程还是要对照 $JK$ **激励表**

![|600](imgs/Pasted%20image%2020250921180200.png)

然后是 $Q_{2}$ 的触发器：

![|600](imgs/Pasted%20image%2020250921180609.png)

当然，除此之外，可以直接让 $Q_{2}$ 的触发器接外面的 $CP$ ，也就是换成同步时序电路。

这样总体上来看也是异步的。